---

mindmap-plugin: basic

---

# 7. 캡슐화

## 7.1 레코드 캡슐화 하기<br/>Encapsulate Record
- Background
   - 대부분의 언어에서 데이터 레코드를 표현하는 구조 제공
      - dictionary
      - class
   - 레코드 다룰 때 주의할 점
      - 계산해서 얻을 수 있는 값과 그렇지 않은 값 구별해야 함<br/>(클래스 캡슐화)
      - 명시적으로 어떤 데이터를 쓰는지를 위해 Map은 자제
      - JSON 등 포맷으로 직렬화 하는 경우<br/>출력형식이 바뀔 수 있으므로 캡슐화 하는 것이 좋다
- Procedure
   - 레코드를 담은 _변수를 캡슐화 (6.6)절_
   - 레코드를 감싼 단순한 클래스로 해당 변수 내용을 교체 하고 접근자 생성
   - 테스트
   - 원본 레코드 대신 새로 정의한 클래스 타입의 객체를 반환하는 함수 만들기
   - 레코드를 반환하는 예전 함수를 새로 만든 함수로 변경
   - 한 부분 바꿀 때 마다 테스트

## 7.2 컬랙션 캡슐화 하기<br/>Encapsulate Collection
- Background
   - (나는) 가변 데이터는 모두 캡슐화
   - 언제 어떻게 수정되는지 추적하기 쉬움<br/>(데이터 변경 자체를 추적하기 굉장히 어려움)
   - 주의할 점
      - 컬렉션 요소를 변경하는 작업은 클래스 메소드를 따로 만든다
      - 컬렉션을 반환하도록 막는 것은 아님
         - 그렇게 되면 컬렉션이 제공하는<br/>다채로운 인터페이스를 사용할 수 없게 됨
         - getter는 컬렉션 자체가 아니라 복사본을 반환하도록 해야함
      - 컬렉션을 통째로 변경할 수 있는 setter는 제거
   - **한 패턴을 적용하기로 했다면 통일해서 사용하자**
- Procedure
   - 아직 컬렉션을 캡슐화 하지 않았다면 _변수 캡슐화하기 (6.6절)_
   - 컬렉션에 원소를 추가/제거 하는 함수 생성<br/>(컬렉션 통째로 변경하는 세터는 모두 제거,<br/>인수로 받은 컬렉션은 복사본을 사용)
   - 정적 검사 수행
   - 컬렉션을 참조하는 부분을 찾고 하나씩 클래스로 변경 후 테스트
   - 컬렉션 getter를 수정해서 원본 내용을 수정할 수 없는 읽기 전용 프록시나<br/>복제본을 반환하게 처리
   - 테스트

## 7.3 기본형을 객체로 바꾸기<br/>Replace Primitive with Object
- Background
   - 프로그램을 규모가 커질수록 primitive type<br/>의 값들이 필요하게 된다
   - ex. 전화번호 문자열 데이터가 나중에는<br/>지역 코드 추출, 포멧팅 등이 필요할 수 있다
   - (나는) 데이터가 단순히 출력 이상의 기능이 필요하다면 클래스로 변경
- Procedure
   - 아직 변수를 캡슐화하지 않았다면 _캡슐화 (6.6절)_ 부터 진행
   - 단순한 값 클래스(value class)를 생성.<br/>생성자는 기존 값을 인수로 받아서 저장하고, 이 값을 반환하는 getter 추가
   - 정적 검사 수행
   - 값 클래스의 인스턴스의 setter와 getter 수정이 필요하면 변경
   - 테스트

## 7.4 임의변수를 질의함수로 바꾸기<br/>Replace Temp with Query
- Background
   - 임시변수
      - 코드의 결과값을 뒤에서 다시 참조하기 위해 사용
      - 계산된 결과를 반복적으로 계산하지 않기 위해 생성
   - 여러 곳에서 똑같은 방식으로 계산되는 변수는 함수로 추출하라
   - 주의할점: 변수를 스냅샷처럼 사용하는 경우 사용하면 안됨
- Procedure
   - 변수가 사용되기 전에 값이 확실히 결정되는지,<br/>즉 매번 다른 결과를 내지 않는지 확인
   - 읽기전용으로 만들 수 있는 변수는 읽기전용으로 만듬
   - 테스트
   - 변수 대입문을 함수로 추출
   - 테스트
   - _변수 인라인하기 (6.4절)_로 임시 변수 제거

## 7.5 클래스 추출하기<br/>Extract Class
- Background
   - 클래스는 반드시 명확하게 추상화하고<br/>주어진 소수의 역할만 수행해야함
   - 역할이 많아진  클래스는 이해하기 어렵기 때문에 분리해야함
   - 함께 변경되는 일이 많거나<br/>서로 의존하는 데이터가 많다면 이도 분리할 수 있다는 신호
- Procedure
   - 클래스의 역할을 분리하는 방법을 선정
   - 분리된 역할을 담당할 클래스를 새로 생성
   - 원래 클래스의 생성자에서<br/>새로운 클래스의 인스턴스를 생성하여 필드에 저장
   - 분리될 역할에 필요할 필드들을 새 클래스로 이동.<br/>이동할 때마다 테스트
   - 양쪽 클래스의 인터페이스를 살펴보면서<br/>메소드를 제거하고 이름도 새로운 환경에 맞게 변경
   - 새 클래스를 외부로 노출할 지 결정

## 7.6 클래스 인라인하기<br/>Inline Class
- Background
   - _클래스 추출하기 (7.5절)_ 와 반대되는 리팩토링 기법
   - 제 역할을 못하는 클래스가 있다면 인라인
   - 주로 역할을 옮기는 리팩토링 이후 남은 역할이<br/>거의 없을 때 이 클래스를 가장 많이 사용하는 클래스로 옮긴다
   - 두 클래스의 기능을 다시 배분하고 싶을 때<br/>인라인 하는 기법을 사용하기도 함
      - 애매한 역할을 하는 두 클래스가 있을때<br/>그것을 합쳐서 _새로운 클래스 추출 (7.5절)_ 을<br/>하는게 더 나을 수 있기 때문
- Procedure
   - 소스 클래스(인라인 하려는 클래스)의<br/>public 메소드들을 타겟 클래스에 생성
   - 소스 클래스의 메소드를 사용하는 코드를<br/>모두 타겟 클래스의 위임 메소드를 사용하도록 변경<br/>바꿀때마다 테스트
   - 소스 클래스의 메소드와 필드를 모두 타겟클래스로 옮김<br/>옮길 때마다 테스트
   - 소스 클래스를 삭제

## 7.7 위임 숨기기<br/>Hide Delegate
- Background
   - 모듈화 설계를 제대로하는 핵심은 캡슐화임
   - 캡슐화가 잘 되어 있다면 코드 변경시<br/>고려해야할 모듈 수가 적어져서 코드를 변경하기 쉬워짐
   - 객체를 알고 있는 모든 객체를 변경하는 문제를 해결하기 위해<br/>객체를 노출하지 않으면 된다
   - 객체가 다른 객체와 결합하면 안되는 경우 사용하기 좋음
- Procedure
   - 위임 객체의 각 메소드에 해당하는 위임 메소드를 서버 객체에 생성
   - 클라이언트가 위임 객체 대신 서버를 호출하도록 변경.<br/>하나씩 변경할 때마다 테스트
   - 모두 수정했다면 서버로부터 위임 객체를 얻는 접근자 제거
   - 테스트

## 7.8 중재자 제거하기<br/>Remove Middle Man
- Background
   - _위임 숨기기 (7.7절)_ 에 반대되는 리팩토링
   - 클래스에 위임이 너무 많다면 바로 접근을 허용하는게 더 나을 수 있음
      - 결합 해야하는 구조라면 결합하는게 더 나을 수 있음
   - 객체가 단순히 중개자(middle man) 역할만해준다면 이 리팩토링 기법 고려
- Procedure
   - 위임 객체를 얻는 getter 생성
   - 위임 메소드를 호출하는 클라이언트가 이 getter를 거치도록 수정
   - 하나씩 바꿀 때마다 테스트 진행
   - 모두를 수정했다면 위임 메소드 삭제

## 7.9 알고리즘 교체하기<br/>Substitute Algorithm
- Background
   - 목적을 달성하는 방법 중 더 나은 방법을 찾아낸 경우<br/>코드를 간명한 방식으로 고치는 것
   - 거대하고 복잡한 알고리즘은 교체하기 어려우므로<br/>방법 수행하기 전에 반드시 메소드를 가능한 잘게 나눴는지 확인
- Procedure
   - 교체할 코드를 함수 하나에 모음
   - 이 함수만을 테스트 하는 동작을 검증하는 테스트 준비
   - 대체할 알고리즘 준비
   - 정적 검사 수행
   - 기존 알고리즘과 새 알고리즘의 결과를 비교하는 테스트 수행.<br/>두 결과가 같다면 리팩토링 종료.<br/>그렇지 않다면 기존 알고리즘을 참고해서 새 알고리즘 테스트, 디버깅
   - 기존 알고리즘 삭제