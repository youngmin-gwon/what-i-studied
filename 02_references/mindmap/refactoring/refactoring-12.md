---
title: refactoring-12
tags: []
aliases: []
date modified: 2025-11-07 08:45:42 +09:00
date created: 2024-12-09 21:31:10 +09:00
mindmap-plugin: basic
---

## 상속 다루기

### 12.1 메소드 올리기

- Background
  - 중복 코드 제거는 중요하다,
  - 한쪽의 변경이 다른 쪽에는 업데이트 되지 않을 수도 있는, 중복을 놓치는 문제가 생기기 쉽기 때문이다.
  - 메소드 올리기를 적용하는 가장 쉬운 예는 메소드들의 본문 코드가 똑같을 경우다.
  - 이럴 땐 그냥 복사해서 슈퍼 클래스에 붙여 넣기만 하면 끝이다.
  - 리팩터링이 제대로 되었는 지를 검증하려면 테스트가 여전히 잘 작동하는지 확인하면 된다. 그치만 이 방법은 얼마나 테스트를 잘 만들어 놓았는가에 의존한다.
  - 매소드 올리기 리팩토링을 적용하려면 선행 단계를 거쳐야 하는 경우가 많다.
  - 예로 서로 다른 두 클래스의 두 메소드를 매개변수화 하면 궁극적으로 같은 메소드가 된다. __(함수를 매개변수화 하기 (11.2 절))__
  - 또 메소드 올리기를 적용하기에 복잡한 상황은 해당 메소드에서 참조하는 필드들이 서브 클래스에만 있는 경우다.
  - 이런 경우에는 필드를 먼저 슈퍼 클래스로 옮기는 __필드 올리기 (12.2 절)__ 을 먼저 적용하고 메소드에 올려야 한다.
  - 마지막으로 두 메소드의 전체 흐름은 비슷하지만 세부 내용이 다르다면 __템플릿 메소드 만들기 디자인 패턴__ 을 고려하자.
- Procedure
  - 똑같이 동작하는 메소드인지 살펴본다. (실질적으로 하는 일은 같지만 코드만 다르면 본문 코드가 똑같아질 때까지 리팩토링 한다.)
  - 옮길 메소드에서 다른 메소드를 호출하거나, 필드를 참조하는데 이게 슈퍼 클래스에서도 충분히 가능한지 확인한다.
  - 메소드 시그니처가 다르다면 __함수 선언 바꾸기 (6.5 절)__ 로 슈퍼 클래스에서 사용하고 싶은 형태로 통일한다.
  - 수퍼 클래스에 메소드를 생성하고, 대상 메소드의 코드를 복사해 붙여넣는다.
  - 정적 검사를 수행한다.
  - 서브 클래스 중 하나의 메소드를 제거한다.
  - 테스트한다.
  - 모든 서브 클래스의 메소드가 없어질 때까지 다른 서브 클래스의 메소드를 하나씩 제거한다.

### 12.2 필드 올리기

- Background
  - 서브 클래스들이 독립적으로 시간을 두고 개발되었거나 뒤늦게 하나의 계층 구조로 통합되어 있는 경우라면 필드가 중복되는 경우가 생길 수 있다.
  - 항상 그런 것은 아니기 때문에 필드가 어떻게 사용되고 있는지 분석해야 한다.
  - 분석 결과 필드들이 비슷한 방식으로 쓰인다고 판단되면 슈퍼 클래스로 올리자.
  - 이렇게 하면 얻을 수 있는 것으로 데이터 선언 중복을 제거하는게 가능하고 그 선언을 바탕으로 하는 동작을 슈퍼 클래스로 올겨서 중복을 제거할 수 있다.
- Procedure
  - 후보 필드들을 사용하는 곳 모두가 그 필드를 똑같은 방식으로 사용하는지 분석한다.
  - 분석이 끝나고 그렇다고 판단되면 리팩토링을 시작할 수 있다. 필드의 이름이 똑같은지 보자. 다르다면 같도록 바꾸자. __(필드 이름 바꾸기 (9.2 절))__
  - 슈퍼 클래스에 새로운 필드를 생성한다.
  - 서브 클래스들의 필드를 제거한다.
  - 테스트한다.

### 12.3 생성자 본문 올리기

- Background
  - 생성자는 일반 메소드와 많이 달라서 나는 생성자가 하는 일에 제약을 둔다. __(Validation, 초기화 로직 등인가?)__
  - 생성자는 할 수 있는 일과 호출 순서에 제약이 있기 때문이다. __(생성자 대신 팩토리 함수로 바꾸는게 더 나은지 생각해보는 것도 좋다. , 슈퍼 클래스의 생성자를 먼저 호출하는 걸 말하나?)__
- Procedure
  - 슈퍼 클래스에 생성자가 없다면 하나 정의한다. 서브 클래스의 생성자들에서 슈퍼 클래스의 생성자를 호출하는지 확인한다.
  - __문장 슬라이드 하기 (8.6 절)__ 을 이용해 공통 문장 모두를 super() 호출 직후로 옮긴다.
  - 공통 코드를 슈퍼 클래스에 추가하고 서브 클래스들에게서 제거한다. 생성자 매개변수 중 공통 코드로 참조하는 값은 super 로 건넨다.
  - 테스트한다.
  - 생성자 시작 부분으로 옮길 수 없는 공통 코드에는 __함수 추출하기 (6.1 절)__ 과 __메소드 올리기 (12.1 절)__ 을 차례로 적용한다.

### 12.4 메소드 내리기

- Background
  - 특정 서브 클래스 하나 (혹은 소수) 와만 관련된 메소드는 슈퍼 클래스에서 제거하고 서브 클래스에 두는 것이 더 깔끔하다. __(LSP 원칙.)__
  - 다만 이 리팩토링은 슈퍼 클래스에서 제공하는 기능이 어떤 서브 클래스에서 사용하는지 명확할 때 사용해야 한다.
  - 만약에 각 서브 클래스마다 다르게 동작해야 하는 부분이 있다면 이 기능의 많은 로직보다 다형성으로 바꾸는게 나을 경우가 있기 때문에.
- Procedure
  - 대상 메소드를 모든 서크 클래스에 복사한다.
  - 슈퍼 클래스에서 그 메소드를 제거한다.
  - 테스트한다.
  - 메소드를 사용하지 않는 서브클래스에선 제거한다.
  - 테스트한다.

### 12.5 필드 내리기

- Background
  - 서브 클래스 하나 (혹은 소수) 에서만 사용하는 필드는 해당 서브 클래스로 옮긴다.
- Procedure
  - 대상 필드를 모든 서브 클래스에서 정의한다.
  - 슈퍼 클래스에서 그 필드를 제거한다.
  - 테스트한다.
  - 이 필드를 사용하지 않는 서브 클래스에선 필드를 제거한다.
  - 테스트한다.

### 12.6 타입 코드를 서브 클래스로 바꾸기

- Background
  - 소프트웨어 시스템에서는 비슷한 대상을 특정 특성에 따라 구분해야 할 때가 있다.
  - 예로 직원을 담당 업무로 구분하거나 (엔지니어, 관리자, 영업자 등), 주무능ㄹ 시급성으로 구분 하거나 (급함, 보통) 등
  - 이런 일을 다루는 수단으로 타입 코드를 프로그래밍에서 자주 사용한다.
  - 타입 코드만으로는 불편한 상황은 없지만 그 이상으로 무언가 필요할 때가 있다.
  - 특성에 따라서 다르게 동작하도록 하거나, 특정 타입에 따라서 다른 동작이나 데이터가 필요하거나 할 때
  - 이런 방식은 서브 클래스를 사용하면 해결해줄 수 있다.
  - 물론 타입 코드르 사용할 때도 코드를 넣어줄 수 있다. 서브 클래스 방식이 관계를 더욱 명확히 드러내주기는 하지만.
  - 이번 리팩토링은 서브 클래스를 이용할 지, 타입 코드를 이용할 지 고민하는 문제다.
  - 서브 클래스는 하위 타입인 클래스를 만드는 방식이고 타입 코드는 속성을 클래스로 만들고 속성을 서브 클래스로 정의하는 방식이다.
- Procedure
  - 타입 코드 필드를 캡슐화한다. __(타입 코드를 사용하는 코드가 있을 수도 있기 때문에. 캡슐화해둔다. 서브 클래스에서도 재정의해서 컴파일 에러가 없도록 하기 위해서.)__
  - 타입 코드 값 하나를 선택해서 그 값에 해당하는 서브 클래스를 만든다.
  - 매개변수로 받은 타입 코드와 방금 만든 서브 클래스를 매핑하는 선택 로직을 만든다. __(선택 로직이라는 말은 어떤 객체를 생성할 지 선택하는 로직을 말한다. 직접 상속인 경우에는 생성자를 팩토리 함수로 바꿔서 호출하도록 하고 선택 로직을 팩토리에 넣는다. 간접 상속인 경우에는 선택 로직을 생성자에 두도록 한다.)__
  - 테스트한다.
  - 타입 코드 값 각각에 대해 서브 클래스 생성과 선택 로직 추가를 반복한다. 클래스 하나가 완성될 때마다 테스트한다.
  - 타입 코드 필드를 제거한다.
  - 테스트한다.
  - 타입 코드 접근자를 이용하는 메소드 모두에 __메소드 내리기 (12.4 절)__ 과 __조건부 로직을 다형성으로 바꾸기 (10.4 절)__ 을 이용한다.

### 12.7 서브 클래스 제거하기

- Background
  - 서브 클래스는 원래 데이터 구조와는 다른 변종을 만들어서 동작을 달라지게 하는 유용한 수단이다.
  - 하지만 소프트웨어가 커지면서 변종이 다른 모듈로 이동하거나 사라지기도 하면서 한 번도 활용되지 않기도 한다.
  - 더 이상 쓰이지 않는 서브 클래스는 그냥 슈퍼 클래스가 대체하는 게 최선이다.
- Procedure
  - 서브 클래스의 생성자를 팩토리 함수로 만든다.
  - 서브 클래스의 타입을 검사하는 코드가 있다면 그 검사 코드를 함수 추출과 함수 옮기기를 통해서 슈퍼 클래스로 옮긴다.
  - 서브 클래스의 타입을 나타내는 필드를 슈퍼 클래스에 만든다.
  - 서브 클래스를 참조하는 메소드가 방금 만든 타입 필드를 이용하도록 수정한다.
  - 서브 클래스를 지운다.
  - 테스트한다.

### 12.8 슈퍼 클래스 추출하기

- Background
  - 비슷한 일을 수핼하는 두 클래스가 있다면 공통 부분을 슈퍼 클래스에 넣을 수 있다.
  - 데이터라면 필드를, 동작이라면 메소드를 올리면 된다.
  - 객체 지향을 설명할 때 상속 구조는 현실 세계에서 활용하는 분류 체계에 기초해서 이용을 해야 한다고 말한다.
  - 하지만 내 경험에 비추어보면 상속은 프로그램이 성장하게 되면서 깨우치게 되고 슈퍼 클래스로 끌어올리고 싶은 공통 요소를 찾았을 때 수행하게 되는 경우가 많다.
  - 슈퍼 클래스 추출하기의 대안으로 __클래스 추출하기 (7.5 절)__ 이 있다.
  - 어느 것을 선택하느냐는 상속으로 해결할 지, 위임으로 해결할 지에 달렸다.
  - 슈퍼 클래스 추출이 더 쉬우므로 이것을 하는걸 먼저 권장한다. 나중에라도 위임이 더 나은 구조라고 판단되면 __슈퍼 클래스를 위임으로 바꾸기 (12.- 절)__ 을 적용해보자.
- Procedure
  - 빈 슈퍼 클래스를 만든다. 원래의 클래스들이 새 클래스를 상속받도록 한다.
  - 테스트한다.
  - __생성자 본문 올리기 (12.3 절), 메소드 올리기 (12.1 절), 필드 올리기 (12.2 절)__ 을 적용해서 공통 요소를 슈퍼 클래슬 ㅗ옮기자.
  - 서브 클래스에 남은 메소드들을 검토하자. 공통되는 부분이 있다면 함수로 추출해서 메소드에 올리기 (12.1 절) 을 적용하자.
  - 원래 클래스들을 사용하는 코드를 검토하여 슈퍼 클래스의 인터페이스를 사용하게 할지 고민해보자.

### 12.9 계층 합치기

- Background
  - 클래스 구조를 리팩토링 ㅏㅎ다 보면 기능들을 위로 올리거나 아래로 내리는 일은 다반사다.
  - 예컨대 계층구조도 진화하면서 어떤 클래스는 부모와 너무 비슷해져서 독립적으로 존재해야 할 이유가 사라지기도한다.
  - 그때 바로 그들을 합쳐야 할 시점이다.
- Procedure
  - 두 클래스 중 제거할 클래스를 고른다.
  - 필드 올리기, 내리기 메소드 올리기, 내리기 를 적용해서 하나의 클래스로 만든다.
  - 제거할 클래스를 참조하던 모든 코드가 남겨질 클래스를 참조하도록 바꾼다.
  - 빈 클래스를 제거한다.
  - 테스트한다.

### 12.10 서브 클래스를 위임으로 바꾸기

- Background
  - 특성에 따라 동작이 달라지는 객체들은 상속으로 표현하는게 자연스럽다.
  - 공통 데이터와 동작은 모두 슈퍼 클래스에 두고 서브 클래스는 자신에 맞게 기능을 추가하거나 오버라이드 하면 된다.
  - 객체 지향에서 이러한 매키니즘은 자연스럽다.
  - 하지만 상속은 단점이 있다.
  - 가장 명확한 단점은 한 번만 쓸 수 있는 카드라는 것이다.
  - 무언가가 달라져야 하는 이유가 여러 개여도 상속은 한 이뮤만 잡을 수 밖에 없다.
  - 예로 사람 객체의 동작을 나이대와 소득 수준에 따라 달라지게 하고 싶다면 서브 클래스는 젊은이와 어르신이 되거나 혹은 부자와 서민이 되어야 한다.
  - 둘 다는 안된다.
  - 또 다른 문제로 상속은 클래스들의 관계를 아주 긴밀하게 결합한다.
  - 부모를 바꾸면 자식들의 기능을 해치기가 쉽기 때문에 주의해야 한다.
  - 그래서 자식들이 슈퍼 클래스를 어떻게 상속해 스는지를 이해해야 한다.
  - 부모와 자식이 서로 다른 모듈에 속하거나 다른 팀에서 구현한다면 문제는 더욱 커진다.
  - 위임 (Delegate) 는 위의 두 문제를 모두 해결해준다.
  - 다양한 클래스에 서로 다른 이유로 위임할 수 있다.
  - 위임은 상속보다 결합도가 낮다. __(다시 정리하면 상속의 결합도는 높다. 자식 클래스는 부모 클래스를 이해하고 설계하기 떄문에 부모 클래스의 변경은 자식 클래스에게 많은 변화를 줄 수 있다.)__
  - 유명한 원칙이 있다.
  - __" 상속 보다는 컴포지션을 사용하라!"__
  - 여기서 컴포지션이 위임을 말하는 것이다.
  - 이 말은 상속은 위험하다고 상속을 사용하지 말라고도 하는데 나는 상속을 자주 사용한다.
  - 이렇게 하는 배경에는 __나중에라도 필요하면 언제든 서브 클래스를 위임으로 바꿀 수 있기 때문이다.__
  - 그래서 처음에는 상속으로 접근한 다음, 문제가 생기면 위임으로 갈아탄다.
  - 실제로 이 원칙을 주장한 디자인 패턴 책은 상속과 컴포지션을 함께 사용하는 방법을 설명해준다. __(여기서는 상속의 과용을 설명해준 것.)__
  - 디자인 패턴에 익숙한 사람이라면 이 패턴을 State Pattern 이나 Strategy Pattern 이라고 생각해도 좋다.
  - 구조적으로 보면 두 패턴은 위임 방식으로 계층 구조를 분리해준다.
- Procedure
  - 생성자를 호출하는 곳이 많다면 __생성자를 팩토리 함수로 바꾼다. (11.8 절)__ __(한번에 바꿨을 때 부작용 여파를 없애기 위해서.)__
  - 위임으로 활용할 빈 클래스를 만든다. 이 클래스의 생성자는 서브 클래스에 특화된 데이터를 전부 받아야 하며 보통은 슈퍼 클래스를 가리키는 역참조 (Back Reference) 도 필요하다.
  - 위임을 저장할 필드를 슈퍼 클래스에 추가한다.
  - 서브 클래스 생성 코드를 수정하여 위임 인스턴스를 생성하고 위임 필드에 대입해 초기화한다. (이 작업은 팩토리 함수에서 주로 하는데 위임 클래스 생성을 생성자에서 가능하다면 그렇게한다.)
  - 서브 클래스 메소드 중 위임 클래스로 이동할 것을 고른다.
  - __함수 옮기기 (8.1 절)__ 을 적용해 위임 클래스로 옮긴다. 원래 메소드에서 위임하는 코드는 지우지 않는다.
  - 서브 클래스 외부에도 원래 메소드를 호출하는 코드가 있다면 서브 클래스의 위임 코드를 슈퍼 클래스로 옮긴다. 이때 위임이 존재하는지를 검사하는 보호 코드로 감싸야한다.
  호출하는 외부 코드가 없다면 원래 메소드는 죽은 코드가 되므로 제거한다.

  - 테스트한다.
  - 서브 클래스의 모든 메소드가 옮겨질 때까지 과정을 반복한다.
  - 서브 클래스의 생성자를 호출하는 코드를 찾아서 슈퍼 클래스의 생성자를 사용하도록 수정한다.
  - 테스트한다.
  - 서브 클래스를 삭제한다.

### 12.11 슈퍼 클래스를 위임으로 바꾸기

- Background
  - 객체 지향 프로그래밍에서 상속은 기존 기능을 재활용하는 강력한 수단이다.
  - 기존 클래스를 상속해 입맛에 맞게 오버라이드 하거나 새 기능을 추가하면 된다.
  - 하지만 상속이 혼란과 복잡도를 키우는 방식으로 이뤄지기도 한다.
  - 자바의 스택 클래스가 그 예다.
  - 자바의 스택은 리스트를 상속하고 있는데 데이터를 저장하고 조회하는 리스트의 기능을 재활용하겠다는 생각이 초래한 결과다.
  - 재활용 관점에서는 좋았지만 이 상속에는 문제가 있다.
  - 리스트의 연산 중 스택에는 적용되지 않는게 많은데도 그 모든 연산이 스택 인터페이스에 그대로 노출되어 있다.
  - __이 보다는 스택에 리스트 객체를 필드에 두고 필요한 기능만 위임하는 식으로 했다면 더 나을 것이다.__
  - 자바의 스택이 슈퍼 클래스를 위임으로 바꾸는 이번 리팩터링을 적용할 좋은 예다.
  - __슈퍼 클래스의 기능들이 서브 클래스에 어울리지 않는다면 그 기능들을 상속을 통해 이용하면 안된다는 신호다.__
  - 제대로 된 상속이라면 서브 클래스가 슈퍼 클래스의 모든 기능을 사용해야 하고, 서브 클래스의 인스턴스를 슈퍼 클래스의 인스턴스로도 취급할 수 있어야한다.
  - 이외에 서브 클래스 방식 모델링이 합리적일 때도 슈퍼 클래스를 위임으로 바꾸기도 한다.
  - 슈퍼 / 서브 클래스가 아주 강하게 결합되어 있어서 슈퍼 클래스를 수정하면 서브 클래스가 망가지기 쉬울 경우를 말한다.
- Procedure
  - 슈퍼 클래스 객체를 참조하는 필드를 서브 클래스에 만든다. (이번 리팩토링이 끝나면 슈퍼 클래스가 위임 객체가 될 것이므로 위임 참조라고 부르겠다.) 위임 참조를 새로운 슈퍼 클래스 인스턴스로 초기화한다.
  - 슈퍼 클래스의 동작 각각에 대응하는 전달 함수를 서브 클래스에 만든다. (물론 위임 참조로 전달한다.) 서로 관련된 함수끼리 그룹을 묶어서, 그룹을 하나씩 만들 때마다 테스트한다.
  - 슈퍼 클래스의 동작 모두가 전달 함수로 오버라이드 되었다면 상속 관계를 끊는다.
