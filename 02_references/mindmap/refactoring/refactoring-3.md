---

mindmap-plugin: basic

---

# 3. 코드 스멜:<br/>제때 리팩토링 하기

## 기이한 이름<br/>(Misterious Name)
- 무슨 일을 하는지 모르게 하는 악취
- 코드를 명료하게 표현하는 것은 이름
- 리팩토링 기법으로 자주 변경하는 것
   - _함수 선언 바꾸기 (6.5절)_,<br/>_변수 이름 바꾸기 (6.7절)_,<br/>_필드 이름 바꾸기 (9.2절)_
- 명확한 이름이 떠오르지 않는다면 설계가 잘못된 것일 수 있음

## 중복 코드<br/>(Duplicated Code)
- 변경해야할 지점이 많아 수정이 어려워지는 악취
- D.R.Y 원칙 준수
- 서로 차이점이 없는지 확인하기
   - 차이점 있을시 활용:<br/>템플릿 메소드 패턴, 전략패턴
- 똑같을 때: _함수 추출하기 (6.1절)_
- 비슷할 때: _문장 슬라이스 (8.6절)_, _함수 추출하기 (6.1절)_
- 같은 부모 가진 서브클래스에서 중복 메소드: _메소드 올리기 (12.1절)_

## 긴 함수<br/>(Long Function)
- 아주 구체적인 일을 한다는 것을 드러내는 악취
- 주석으로 달아야 하는 부분이 있다면 그 부분은 함수로 빼기
   - 함수 이름은 동작 보다는 의도에 집중하기
- _함수 추출하기 (6.1절)_
- 임시 변수가 많을 때: _임시 변수를 질의 변수로 바꾸기 (7.4절)_
- 매개 변수가 많을 때:<br/><br/>_매개 변수를 매개변수 객체로 만들기 (6.8절)_,<br/>_객체 통째로 넘기기 (11.4 절)_
- 여전히 임시 변수, 매개 변수가 많을 때: _함수를 명령으로 만들기 (11.9절)_
- 조건문, 반복문:<br/><br/>_조건문 분해하기 (10.1절)_, _조건문을 다형성으로 바꾸기 (10.4절)_,<br/>_반복문 쪼개기 (8.7절)_

## 긴 매개변수 목록<br/>(Long Parameter List)
- 매개변수가 길면 코드를 이해하기 어렵다는 악취
- 1개 일때 가장 좋고 3개 이상 넘기지 말 것
- 매개변수까지 고려해서 함수 이름을 지어라
- 하나의 매개변수로 다른 매개변수를 구할 때:<br/>_매개변수를 질의 함수로 바꾸기 (11.5절)_
- 항상 함께 전달되는 매개변수가 있을 때:<br/>_매개변수를 객체로 만들기 (6.8절)_
- 플래그 역할 하는 매개변수 있을때:<br/>_플래그 인수 제거하기 (11.3절)_
- 매개변수로 넘기는 형태가 하나의 데이터 구조에서 각각 뽑아 던지는 경우:<br/>_객체 통째로 넘기기 (11.4절)_

## 전역 데이터<br/>(Global Data)
- 어디서든 가져와서 변경할 가능성이 있는 악취
- 클래스 전역 변수, 싱글톤 객체
- _변수 캡슐화 하기 (6.6절)_

## 가변 데이터<br/>(Mutable Data)
- 예상하지 못한 결과를 낼 수 있다는 악취
- _변수 캡슐화 하기 (6.6절)_
- 하나의 변수가 다른 용도로 사용되고 있을때:<br/>_변수 쪼개기 (9.1절)_
- 변경하는 부분만 따로 빼내기:<br/>_함수 추출하기 (6.1절)_, _문장 슬라이스하기 (8.6절)_
- 데이터를 하나의 클래스에 묶기:<br/>_여러함수를 클래스에 묶기 (6.9절)_, _여러함수를 변환함수로 묶기 (6.10절)_
- 변경 가능성 제거하기:<br/>_세터 제거하기 (11.7절)_
- 변수 유효범위 줄여 위험 줄이기:<br/>_여러 함수를 클래스로 묶기 (6.9절)_
- 한 변수가 다른 변수에 의해 생성되는 경우:<br/>_파생 변수를 질의 함수로 변경하기 (9.3절)_
- 내부 필드 데이터를 담고 있는 구조일 때:<br/>_참조를 값으로 바꾸기 (9.4절)_ 로 내부 필드가 아닌 전체 구조 변경하기

## 뒤엉킨 변경<br/>(Divergent Change)
- 하나의 모듈이 여러 가지 원인 때문에 변경될 때의 악취
- SRP가 제대로 지켜지지 않음
- 맥락을 나눠 적절한 책임을 가진 모듈로 만들어줘야 함
- 맥락을 나눌때:<br/>_단계 쪼개기 (6.11절)_
- 여러 맥락을 드나드는 함수가 있을 때:<br/>_함수 추출하기 (6.1절)_
- 맥락이 거대한 클래스 일때:<br/>_클래스 추출하기 (7.5절)_

## 산탄총 수술<br/>(Shotgun Surgery)
- 코드를 변경할 때마다 자잘하게 수정해야 하는 클래스가 많을 때의 악취
- _함수 옮기기 (8.1절)_, _필드 옮기기 (8.2절)_
- 비슷한 데이터를 다루는 함수가 많을 때:<br/>_여러 함수를 클래스로 묶기 (6.9절)_
- 구조를 변환하거나 보강하는 함수들이 많을 때:<br/>_여러 함수를 변환 함수로 묶기 (6.10절)_
- 묶은 함수를 다음 단계로 전달하는 구조일 때:<br/>_단계 쪼개기 (6.11절)_
- _함수 인라인 하기 (6.2절)_, _클래스 인라인 하기 (7.6절)_<br/>을 이용하여 분리된 로직 인라인 하기

## 기능편애<br/>(Feature Envy)
- 어떤 모듈의 함수가 자신이 속한 모듈의 함수나 데이터와의 상호작용보다<br/>다른 모듈과의 상호작용이 더 많을 때 풍기는 악취
- getter 메소드를 여러번 호출해서 다른 데이터에 접근, 상호작용할 때 발생
- 데이터 근처로 함수를 추출해서 옮기면 됨
- _함수 추출하기 (6.1절)_ 로 추출후 _함수 옮기기 (8.1절)_
- 디자인 패턴 사용 가능:<br/> _전략_, _방문자_

## 데이터 뭉치<br/>(Data Clumps)
- 몰려다니는 데이터를 묶지 않아 생기는 악취
- SRP 위반
- 변경해야하는 코드가 많아짐
- 특정 필드끼리 몰려다니는 경우:<br/>_클래스 추출하기 (7.5절)_
- 메소드의 파라미터끼리 몰려다니는 경우:<br/>_매개변수 객체 만들기 (6.8절)_, _객체 통째로 넘기기 (11.4절)_

## 기본형 집착<br/>(Primitive Obsession)
- 기본형을 고집하여 기본형 데이터를 기반으로 계산하는 로직 때문에<br/>코드를 이해하기 어려워 발생하는 악취
- 예시) if 조건절에서 기본형을 가지고 계산하는 방식
- 기본형을 클래스로 감싸서 추상화 해야 함
- _클래스 추출하기 (7.5절)_
- 조건절에서 타입을 이용하는 경우:<br/>_타입코드를 서브 클래스로 바꾸기 (12.6절)_, _조건부 로직을 다형성으로 바꾸기 (10.4절)_

## 반복되는 switch문
- 변경 포인트가 많아지는 악취
- 최악의 경우 딱 하나의 switch 문만 허용
- _조건부 로직을 다형성으로 바꾸기 (10.4절)_

## 반복문<br/>(Loop)
- 무슨 일을 하는지 파악하기 어려운 악취
- 일반적으로 반복문 안의 코드가 한 줄일 때 이해하기 쉽다
- _반복문을 파이프라인으로 바꾸기 (8.8절)_<br/>: 일급 함수를 지원하는 프로그래밍 언어에서 사용할 수 있는 방법
- Filter, Map 같은 파이프라인 연산을 사용하면 처리되는 과정을 쉽게 파악할 수 있음

## 성의 없는 요소<br/>(Lazy Element)
- 재활용을 위해 구조를 잡지 않아도 되는 경우의 코드
- _함수를 인라인하기 기법 (6.2절)_, <br/>_클래스 인라인 하기 (7.6절)_<br/>을 이용해 구조를 분해해 없애버리기
- 상속을 이용했을 때:<br/>_계층 합치기 (12.9절)_

## 추측성 일반화<br/>(Speculative Generality)
- 먼 확장성을 고려해 지금의 코드베이스를 망치는 악취 (YAGNI)
- 클래스:<br/>_계층 합치기 (12.9절)_
- 쓸데 없이 위임하는 코드:<br/>_함수 인라인 하기 (6.2절)_, _클래스 인라인 하기 (7.6절)_
- 테스트 코드에서 주로 발생
   - 테스트 케이스 먼저 제거
   - _죽은 코드 제거하기 (8.9절)_

## 임시필드<br/>(Temporary Field)
- 클래스 필드를 모두 사용하지 않고,<br/>특정 상황에서만 사용하는 경우 이해가 어려움
- _클래스 추출하기 (7.5절)_
- 기존 클래스에 임시 필드의 여부와<br/>관련해서 동작하는 메소드가 있는 경우:<br/>_특이 케이스 추가하기 (10.5절)_

## Message Chain
- 한 객체를 통해 다른 객체를 연속적으로 찾아가는 과정
- Demeter's law 을 위반
- 다른 모듈에 의존하는 경향이 높아지는 악취
- 클래스는 필요할 때만 협력하고<br/>스스로 처리할 수 있는 응집도가 있어야 함
- _위임 숨기기 (7.7절)_,<br/>_함수 추출하기 (6.1절)_,<br/>_함수 옮기기 (8.1절)_

## 중개자<br/>(Middle Man)
- 객체가 다른 객체를 직접 호출하는 구조가 아닌 대신<br/>호출해주는 중개자 객체가 있고,<br/>이게 그렇게 필요한 객체가 아니라면 악취가 발생
- 이해하기 어려워 악취가 발생
- 다른 객체가 대신 호출해주면 좋은 경우도 있음<br/>(프록시 패턴)
- _중개자 제거하기 (7.8절)_

## 내부자 거래<br/>(Insider Trading)
- 모듈 사이에 은밀한 결합으로 발생하는 악취
- 결합도 낮추고 응집도 높여야 함
- _필드 옮기기 (8.2절)_,<br/>_함수 옮기기 (8.1절)_<br/>으로 결합 줄이기
- 여러 모듈이 같은 관심사를<br/>공유해서 결합하는 일이 많은 경우:<br/>_위임 숨기기 (7.7절)_
- 부모와 자식 클래스간의 결합이 많아지는 경우:<br/>_서브 클래스를 위임으로 바꾸기 (12.10절)_,<br/>_부모 클래스를 위임으로 바꾸기 (12.11절)_

## 거대한 클래스<br/>(Large Class)
- 많은 역할을 가질 확률 높음
- 중복된 코드 가질 확률 높음
- 관련 필드 묶기:<br/>_클래스 추출하기 (7.5절)_
- 상속 관계가 더 나은 경우:<br/>_슈퍼 클래스 추출하기 (12.8절)_,<br/>_타입 코드를 서브 클래스로 바꾸기 (12.6절)_

## 서로 다른 인터페이스의 대안 클래스들<br/>(Alternative Classes with Different Interfaces)
- 역할에 의존하도록 하고 구현체에 의존하지 않도록 함으로써<br/>DIP, OCP를 지킬 수 있음
- 비슷한 기능인데 인터페이스가 다른 경우:<br/>_함수 선언 바꾸기 (6.5절)_ 을 통해 메소드 시그니처를 같도록 변경
- 대안 클래스들 사이 중복 코드 발생:<br/>_슈퍼 클래스 추출하기 (12.8절)_

## Data Class
- Getter/Setter만 있는 클래스는 그 자체로 협력할 수 없고,<br/>마음대로 사용할 가능성이 큼
- 결합도가 높아지고 SRP를 위반하는 악취를 발생
- 예외: _단계 쪼개기 (6.11절)_의 중간 결과
- _함수 옮기기 (8.1절)_ 나<br/>_다른 클래스들에 있는 함수 추출하기 (6.1절)_<br/>로 역할 잡기

## 상속 포기하기<br/>(Refused Bequest)
- 자식 클래스가 부모클래스의 인터페이스를 따르지 않는 악취
- 한 두개 차이나는 경우:<br/>_메소드 내리기 (12.4절)_, _필드 내리기(12.5절)_
   - 무조건 권하는 방법은 아니지만 유용함
- 부모의 인터페이스를 따를 필요 없는 경우:<br/>_서브 클래스를 위임으로 바꾸기 (12.10절)_,<br/>_슈퍼 클래스를 위임으로 바꾸기 (12.11절)_

## 주석<br/>(Comments)
- 주석을 사용할 것이라면 올바르게 사용하자
- 주석을 사용하기 전에 리팩토링을 진행해보자