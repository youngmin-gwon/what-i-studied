---
title: random-access
tags: [algorithm, computer-science, memory]
aliases: [랜덤 액세스, 임의 접근]
date modified: 2025-12-18 16:49:20 +09:00
date created: 2025-12-18 16:21:20 +09:00
---

## 랜덤 액세스 (Random Access) 란?

랜덤 액세스(Random Access, 임의 접근)는 **위치에 상관없이 언제나 똑같은 시간(O(1))에 데이터에 접근할 수 있는 방식**을 말한다. 이는 데이터의 저장 위치에 따라 접근 속도가 달라지는 순차 접근 (Sequential Access)과 대비되는 개념이다.

### 💡 Why it matters (Context)

컴퓨터의 성능, 특히 **속도**에 결정적인 영향을 미친다. 메모리(RAM)가 랜덤 액세스를 지원하기 때문에, CPU 는 메모리의 어느 주소에 있는 명령어든 즉시 가져와 실행할 수 있다. 만약 메모리가 순차 접근만 지원했다면, 프로그램 실행 속도는 지금보다 수천 배 느렸을 것이다.

### 직관적인 비유

- **랜덤 액세스 = 책 (Book)**: 300 페이지를 펼치고 싶으면 바로 300 페이지를 펴면 된다. 1 페이지부터 넘길 필요가 없다.
- **순차 접근 = 두루마리 (Scroll) / 비디오 테이프**: 중간 내용을 보려면 처음부터 감아서 해당 위치까지 가야 한다.

---

## 역사적 배경과 필요성

초기 컴퓨터 저장 장치인 **펀치 카드**나 **자기 테이프(Magnetic Tape)** 는 대표적인 순차 접근 장치였다. 데이터를 찾으려면 테이프를 물리적으로 감아야(Seek) 했기에 시간이 오래 걸렸다.

**문제점**:
- 데이터 처리가 느리다.
- 데이터베이스처럼 수시로 데이터를 읽고 써야 하는 작업에 부적합하다.

이를 해결하기 위해 1940 년대 후반부터 **윌리엄스 튜브(Williams Tube)** 나 **자기 코어 메모리(Magnetic Core Memory)** 같은 초기 형태의 RAM 이 개발되었고, "어느 위치든 즉시 접근 가능" 한 특성이 컴퓨터 아키텍처의 비약적인 발전을 이끌었다.

---

## 기술적 상세 (Technical Details)

### 1. O(1) 복잡도의 비밀

자료구조에서 **배열(Array)** 은 인덱스를 통해 데이터에 접근할 때 $O(1)$ 의 시간 복잡도를 가진다. 이는 배열이 메모리 상에서 연속적으로 할당되고, 랜덤 액세스가 가능하기 때문이다.

$$주소 = 시작\_주소 + (인덱스 \times 데이터\_크기)$$

위 공식으로 CPU 는 단 한 번의 계산으로 물리적 메모리 주소를 알아내고 접근한다. 반면, **[Linked List](../../01_inbox/algorithm/01_data-structures/linear.md)** 는 원하는 요소를 찾기 위해 처음부터 노드를 따라가야 하므로 $O(n)$ 이 걸린다.

### 2. 하드웨어별 특성 (RAM vs Disk)

- **RAM (Random Access Memory)**: 이름 그대로, 모든 셀에 접근하는 시간이 거의 동일하다.
- **HDD (Hard Disk Drive)**: 물리적인 헤드가 트랙으로 이동(Seek)하고 플래터가 회전해야 하므로, 데이터 위치에 따라 접근 시간이 다르다. 엄밀히 말하면 완전한 랜덤 액세스가 아니며, **순차 읽기**가 랜덤 읽기보다 압도적으로 빠르다.
- **SSD (Solid State Drive)**: 물리적 움직임이 없고 플래시 메모리 주소로 접근하므로 HDD 보다 월등히 빠르며, RAM 에 가까운 랜덤 액세스 성능을 보인다.

---

## 🏗️ 메모리 계층 구조 (Memory Hierarchy) 와 랜덤 액세스

랜덤 액세스가 $O(1)$ 이라고 해서 모든 접근이 물리적으로 같은 속도인 것은 아니다. CPU 와 데이터 사이의 거리(**[메모리 계층 구조](memory-layout-and-cache.md)**)에 따라 실제 소요 시간은 수백 배 차이난다.

1. **Registers**: CPU 내부. 가장 빠른 랜덤 액세스 (1 cycle 이하).
2. **L1/L2/L3 Cache**: CPU 근처. 매우 빠름.
3. **Main Memory (RAM)**: 우리가 흔히 말하는 $O(1)$ 랜덤 액세스의 기준. 하지만 캐시보다 **100 배 이상 느리다.**
4. **SSD/HDD**: 가장 멀고 느리다.

>[!TIP] **알고리즘의 실제 성능**
>이론적으로 $O(1)$ 랜덤 액세스라 하더라도, 데이터가 캐시에 없어서 RAM 까지 갔다 와야 한다면(**Cache Miss**), 순차적으로 데이터를 읽어 캐시를 최대한 활용하는 방식보다 훨씬 느릴 수 있다.

---

## 🔄 순차 접근 (Sequential Access) 이란?

순차 접근은 데이터를 처음부터 끝까지 순서대로 읽거나 쓰는 방식이다. 랜덤 액세스가 불가능한 하드웨어(테이프)뿐만 아니라, 성능 최적화를 위해 의도적으로 사용되기도 한다.

### 순차 접근의 장점
- **Prefetching**: 데이터가 순차적으로 읽힐 것임을 알면, 커널이나 하드웨어는 미리 다음 데이터를 캐시에 올려둔다.
- **단순함**: 복잡한 인덱싱 계산이 필요 없다.
- **매체 최적화**: HDD 나 자기 테이프 같은 기계적 장치에서는 헤드 이동을 최소화하므로 랜덤 액세스보다 훨씬 빠르다.

### 비교 요약

| 특성 | 랜덤 액세스 (Random Access) | 순차 접근 (Sequential Access) |
| :--- | :--- | :--- |
| **접근 시간** | 일정함 ($O(1)$) | 위치에 따라 다름 ($O(n)$) |
| **대표 매체** | RAM, SSD, 배열 | 자기 테이프, 연결 리스트, 파일 스트림 |
| **장점** | 빠른 검색, 임의 위치 읽기/쓰기 용이 | 데이터 스트리밍에 적합, 캐시 효율 극대화 |
| **단점** | 하드웨어 구조가 복잡함 | 중간 데이터 검색 시 매우 느림 |

---

## 📚 관련 문서

- [메모리 계층 구조](memory-layout-and-cache.md): 캐시 지역성과 하드웨어 성능의 관계.
- [복잡도와 Big-O](../../01_inbox/algorithm/00_fundamentals/complexity-and-big-o.md): $O(1)$ 과 하드웨어 병목 현상 이해.
- [운영체제 커널](../operating-systems/kernel.md): VFS 와 파일 시스템에서의 입출력 관리.
- [선형 자료구조](../../01_inbox/algorithm/01_data-structures/linear.md): 배열(랜덤 액세스) vs 연결 리스트(순차 접근).
