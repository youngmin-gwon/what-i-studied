# Python 알고리즘 구조 공부

## 파이썬 자료형

![[_assets/algorithm/python_type_layer.png]]

- 파이썬은 C나 자바처럼 성능에 대한 우선순위가 높은 언어가 아님
- 편리한 기능 제공에 우선순위를 둔 언어인 만큼 느린 속도와 더 많은 메모리를 차지하더라도 다한 기능을 제공하는데 관심을 둠
  - eg. bool의 원시 타입(primitive type)은 1비트이지만 객체인 Boolean은 128비트 차지함
  - 공간을 희생하고 편리한 기능을 제공하기 위함
- 파이썬은 __모든 것이 객체__

### 객체

- 불변 객체와 가변 객체로 나뉨

| 클래스 | 설명                              | 불변객체 |
| ------ | --------------------------------- | -------- |
| bool   | 부울                              | o        |
| int    | 정수                              | o        |
| float  | 실수                              | o        |
| list   | 리스트                            | x        |
| tuple  | 튜플                              | o        |
| str    | 문자                              | o        |
| set    | 중복된 값을 갖지 않는 집합 자료형 | x        |
| dict   | 딕셔너리                          | x        |

### 숫자

- int만 제공
  - 커지면 자동으로 long타입으로 변환됨
- bool은 엄밀히 따지면 논리 자료형이지만, 파이썬에서는 내부적으로 1과 0으로 처리되는 int의 브 클래스임
- object > int > bool
- 임의 정밀도란?
  - 무제한 자릿수를 제공하는 정수형
  - 어떻게 가능한가?
    - 정소를 숫자의 배열로 간주하면 가능
  - 계산속도가 저하됨
  - 하지만 숫자를 단일형으로 처리할 수 있으므로 언어를 매우 단순한 구조로 들 수 있을 뿐만 아니라, 언어를 사용하는 입장에서도 더이상 오버플로우를 걱정할 필요가 없어 잘못된 계산 오류를 방지할 수 있음

### 매핑

- 키와 자료형으로 구성된 복합 자료형
- 파이썬에서 제공하는 것은 dictionary

### 집합

- 중복된 값을 갖지 않는 자료형
- set

### 시퀀스

- =수열
- 배열이 없는 파이썬에서는 list라는 시퀀스 타입이 사실상 배열의 역할을 수행함
- 시퀀스는 불변/가변으로 나뉘게 됨
- str은 불변
  - 다음 예제에서 보면 메모리에 있는 값을 변경하는 것이 아니라 메모리 주소를 참고하는 것이 바뀜
  - 가변 객체라면 변경이 가능해야하지만 str은 불가능

```python
a = 'abc'
id('abc')
# 4317530408
id(a)
# 4317530408
a = 'def'
id('def')
# 4318831648
id(a)
# 4318831648

a[1]='d'
# Traceback (most recent call last):

## 추가정보

# is는 id()값을 비교하는 함수임
a = [1,2,3]
a == a
# True
a == list(a)
# True
a is a
# True
a is list(a)
# False

a = [1,2,3]
a == copy.deepcopy(a)
# True
a is copy.deepcopy(a)
# False

```

#### list

- 리스트 주요 연산 시간 복잡도

| 연산           | 시간복잡도 | 설명                                                                                                                                             |
| -------------- | ---------- | ------------------------------------------------------------------------------------------------------------------------------------------------ |
| len(a)         | $O(1)$     | 전체 요소의 개수를 리턴한다                                                                                                                      |
| a[i]           | $O(1)$     | 인덱스 i의 요소를 가져온다                                                                                                                       |
| a[i:j]         | $O(k)$     | i부터 j까지 슬라이스의 길이만큼인 k개의 요소를 가져옴. 이 경우 객체 k에 대한 조회가 필요하므로 O(k)                                              |
| elem in a      | $O(n)$     | elem 요소가 존재하는지 확인한다. 처음부터 순차 검색하므로 n만큼 시간 소요                                                                        |
| a.count(elem)  | $O(n)$     | elem 요소의 개수를 리턴                                                                                                                          |
| a.index(elem)  | $O(n)$     | elem 요소의 인덱스를 리턴                                                                                                                        |
| a.append(elem) | $O(1)$     | 리스트 마지막에 elem 요소를 추가, Dart에서는 amortized constant (list는 buffer로 구현되므로, buffer가 다 차면 buffer를 추가할 공간이 필요하므로) |
| a.pop()        | $O(1)$     | 리스트 마지막 요소를 추출. 스택 연산                                                                                                             |
| a.pop(0)       | $O(n)$     | 리스트 첫번째 요소를 추출. 큐 연산. 이 경우 전체 복사가 필요하므로 O(n)이다. 큐연산을 주로 사용한다면 리스트보다는 O(1)에 가능한 deque를 권장    |
| del a[i]       | $O(n)$     | i에 따라 다르다. 최악의 경우 O(n)이다                                                                                                            |
| a.sort()       | $O(nlogn)$ | 정렬. 팀소트를 사용하며, 최선의 경우 O(n)에도 실행될 수 있음                                                                                     |
| min(a), max(a) | $O(n)$     | 최솟값/최댓값을 계산하기 위해서는 전체를 선형 탐색해야 함                                                                                        |
| a.reverse()    | $O(n)$     | 뒤집는다. 리스트는 입력 순서가 유지되므로 뒤집게 되면 입력 순서가 반대로 됨                                                                      |

#### dict

- 인덱스를 숫자로만 지정하는 리스트와 달리 문자를 포함해 다양한 타입을 키로 활용할 수 있음
  - 해시할 수 있다면 숫자, 문자, 집합까지 불변 객체를 모두 키로 사용할 수 있음
- 해시 테이블은 다양한 타입을 키로 지원하면서도 입력과 조회 모두 O(1)에 가능함
  - 최악의 경우 O(n)이 될 수 있으나 대부분의 경우 훨씬 더 빨리 실행 됨
  - 분할 상환 분석에 따른 시간 복잡도는 $O(1)$
- 딕셔너리 주요 연산 시간 복잡도

| 연산         | 시간 복잡도 | 설명                            |
| ------------ | ----------- | ------------------------------- |
| len(a)       | $O(1)$      | 요소 개수를 리턴                |
| a[key]       | $O(1)$      | 키를 조회하여 값을 리턴         |
| a[key]=value | O(1)        | 키/값을 삽입                    |
| key in a     | $O(1)       | 딕셔너리에 키가 존재하는지 확인 |

- 리스트만큼 빈번하게 사용되는 자료형
- 원래 해시 테이블을 이용한 자료형은 순서가 유지되지 않아 collections.OrderedDict()라는 별도의 자료형을 사용해야 했지만, 3.7 버전부터는 내부적으로 인덱스를 이용해 입력 순서를 유지하록 개선함
  - 코딩테스트에서는 입력 순서가 유지될거라 기대말아야 함
- 딕셔너리를 효율적으로 생성하기 위한 추가 모듈
  - collections.OrderedDict(): python 3.6 이하에서 입력 순서가 유지되는 해시테이블
  - collections.Counter(): 요소의 값을 키로 하고 개수를 값 형태로 만들어 카운팅하는 객체
  - collections.defaultDict(int): 존재하지 않는 키를 조회할 경우, 에러 메세지를 출력하는 대신 디트 값을 기준으로 해당키에 대한 딕셔너리 아이템을 생성

#### string

- ord(): 문자열 -> ASCII 코드
- chr(): ASCII 코드 -> 문자열
