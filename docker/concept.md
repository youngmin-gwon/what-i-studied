## Overview

컨테이너라고 불리는 느슨하게 격리된 환경을 가상화해주는 프로덕트 

애플리케이션을 패키징하고 실행할 수 있는 기능을 제공

격리와 보안을 통해 주어진 호스트에서 많은 컨테이너를 동시에 실행 가능 

컨테이너는 가볍고 애플리케이션을 실행하는 데 필요한 모든 것을 포함하므로 현재 호스트에 설치된 것에 의존할 필요가 없음

작업하는 동안 동일한 컨테이너를 쉽게 공유할 수 있으며, 공유하는 모든 사람이 같은 방식으로 작동하는 동일한 컨테이너를 얻을 수 있습니다.

## 장점
1. 개발/배포를 위한 빠르고 일관된 환경 제공
	- 개발자가 애플리케이션, 서비스를 제공하는 로컬 컨테이너를 사용하여 표준화된 환경에서 작업할 수 있도록 함으로써 개발 수명 주기를 간소화함
		- 지속적인 통합과 지속적인 전달(CI/CD) 워크플로우에 적합
2. 반응형 배포 및 확장
	- 휴대성이 뛰어나 개발자의 로컬 노트북, 데이터 센터의 물리적 또는 가상 머신, 클라우드 공급자 또는 혼합 환경에서 실행할 수 있음
	- 이식성과 가벼운 특성은 워크로드를 동적으로 관리하고, 비즈니스 요구에 따라 거의 실시간으로 애플리케이션과 서비스를 확장하거나 해체할 수 있게 해줌
3. 같은 하드웨어에서 더 많은 작업량 실행
	- 도커는 가볍고 빠르기 때문에 더 많은 서버 용량을 사용할 수 있음

# Architecture
![Docker Architecture](docker_architecture.svg)
## 1. docker daㅓmon
- `dockerd`
- 도커 API 요청을 수신
- 이미지, 컨테이너, 네트워크 및 볼륨과 같은 도커 객체를 관리
- 도커 서비스를 관리하기 위해 다른 데몬과 통신
## 2. docker client
- `docker`
- 도커와 상호 작용하는 주요 방법
- `docker run`과 같은 명령을 사용할 때, 클라이언트는 이러한 명령을 `dockerd`로 전송하여 실행
- 도커 API를 사용
- 하나 이상의 데몬과 통신할 수 있음
## 3. docker registries
- 도커 이미지를 저장하는 곳
- 기본적으로 Docker Hub에서 이미지를 찾도록 구성(Docker Hub = Github for docker)
	- 개인 레지스트리를 실행할 수도 있음
- `docker pull` 또는 `docker run` 명령을 사용할 때, 필요한 이미지는 구성된 레지스트리에서 가져옴
- 도커 푸시 명령을 사용하면 이미지가 구성된 레지스트리로 푸시됩니다.
## 4. docker objects
- 도커를 구동시 사용하는 컨테이너, 네트워크, 볼륨, 플러그인 및 기타 개체
### 1) images
- 도커 컨테이너를 만들기 위한 설정사항이 있는 수정 불가 템플릿
- 종종, 이미지는 몇 가지 추가 customization과 함께 다른 이미지를 기반으로 함
	- 예를 들어, 우분투 이미지를 기반으로 하는 이미지를 만들 수 있지만, 아파치 웹 서버와 애플리케이션뿐만 아니라 애플리케이션을 실행하는 데 필요한 구성 세부 사항을 설치할 수 있음
- 자신만의 이미지를 만들거나 다른 사람들이 만든 이미지 사용 가능
	- 자신만의 이미지를 구축하려면, 이미지를 만들고 실행하는 데 필요한 단계를 정의하기 위한 간단한 구문 생성: `Dockerfile`
		- `Dockerfile`은 각 명령은 이미지에 레이어를 생성
		- `Dockerfile`을 변경하고 이미지를 다시 만들면, 변경된 레이어만 다시 빌드됨 
			- 다른 가상화 기술과 비교할 때 이미지를 가볍고, 작고, 빠르게 만들 수 있는 이유 중 하나
### 2) containers
- image의 실행 가능한 인스턴스
- 하나 이상의 네트워크에 연결하거나, 저장소를 연결하거나, 현재 상태에 따라 새 이미지를 만들 수도 있음
- 컨테이너의 네트워크, 스토리지 또는 기타 기본 하위 시스템이 다른 컨테이너 또는 호스트 컴퓨터에서 얼마나 격리되어 있는지 제어할 수 있음
- 이미지 + 생성하거나 시작할 때 제공하는 구성 옵션으로 정의됨
- 컨테이너가 제거되면, 영구 저장소에 저장되지 않은 상태의 변경 사항이 사라짐

`docker run` 예시

```bash
docker run -i -t ubuntu /bin/bash
```

- 우분투 컨테이너를 실행하고, local cli 세션에 /bin/bash를 실행
1. 로컬에 우분투 이미지가 없다면, 도커는 `docker pull ubuntu`를 수동으로 실행한 것처럼 구성된 레지스트리에서 가져옴
2. `docker container create`을 수동으로 실행한 것처럼 새 컨테이너를 만듬
3. 최종 레이어로 컨테이너에 읽기-쓰기 파일 시스템을 할당. 이를 통해 실행 중인 컨테이너는 로컬 파일 시스템에서 파일과 디렉토리를 만들거나 수정할 수 있음.
4. 네트워킹 옵션을 지정하지 않았기 때문에, 컨테이너를 기본 네트워크에 연결하기 위한 네트워크 인터페이스 생성. 여기에는 컨테이너에 IP 주소를 할당하는 것이 포함함. 기본적으로 컨테이너는 호스트 컴퓨터의 네트워크 연결을 사용하여 외부 네트워크에 연결할 수 있음
5. 컨테이너를 시작하고 /bin/bash를 실행한다. 컨테이너가 대화식으로 실행되고 터미널에 연결되어 있기 때문에(-i 및 -t 플래그로 인해), 출력이 터미널에 기록되는 동안 키보드를 사용하여 입력을 제공할 수 있음
6. /bin/bash 명령을 종료하기 위해 exit를 입력하면 컨테이너가 중지되지만 제거되지 않기 때문에 다시 시작하거나 제거할 수 있음