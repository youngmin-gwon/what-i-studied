# Chain of Responsibility

#BehavioralPattern

## Description

![Untitled](Untitled%2054.png)

- 일련의 핸들러를 따라 요청을 전달할 수 있는 패턴
- 요청을 받으면 각 핸들러는 요청을 처리할지 아니면 체인의 다음 핸들러로 전달할지 결정

## Case

### Situation

- 온라인 주문 시스템을 구축한다고 가정해보자. 많은 기능들이 필요하겠지만 유저에 대한 인증이나, Admin 권한을 가진 사용자의 경우 모든 주문을 조회한다던지 하는 기능들이 필요할것이다.
- 시스템이 비대해져가면서 비밀번호 brute force 어택을 막기 위한 기능, 요청에 대한 validation, 같은 요청에 대해 cache를 반환하는 기능이 필요할수도 있다.
- 이 상태에서 또 다른 기능을 추가하면 로직은 복잡해진다. 하나를 변경할 때 다른 기능에 영향을 줄 수도 있고, 만약 이 기능들중 일부분의 기능이 다른 기능구현에 필요하다면 중복코드가 발생한다. 이렇게 되면 시스템을 관리하며 유지보수하기가 매우 힘들어진다

![Untitled](Untitled%2055.png)

### Solution

- 다른 행동 패턴들과 유사하게 책임 연쇄 패턴도 핸들러라는 단일 객체를 사용한다. 위의 문제점과 같은 상황에서는 각 단계별 행동들이 단일 메소드를 가지는 클래스가 되고, 요청은 단일 메소드의 인자가 된다.
- 책임 연쇄 패턴은 핸들러들을 연결하여 체인 형태로 구성한다. 체인에서 각 핸들러들은 다음 핸들러를 참조하는 필드를 가지고 있으며, 요청을 처리하고 넘긴다.
- 또 하나의 특징이 있는데 마치 알고리즘에서 더 탐색할 필요가 없는 그래프 경로를 탐색하지 않는 가지치기 처럼, 각 핸들러는 요청을 다음 핸들러에 넘길지 말지 결정할 수 있다.
- 패턴 사용시 여러 핸들러를 하나의 체인으로 연결하고 클라이언트가 해당 체인을 따라 요청을 전달할 수 있음 ⇒ **각 핸들러는 요청을 수신하고 처리 및/또는 추가로 전달**
- 요청 추가/제거/재정렬/처리순서 변경 할 수 있음
- 여러 종류의 요청을 다양한 방식으로 처리할 것이 예상되지만, 요청이나 처리 순서가 컴파일 타임에 정해지지 않는 경우 사용 해야함

![Untitled](Untitled%2056.png)

- 주의해야 할 점
    - 요청 수행이 보장되지 않음
    - 발신자와 수신자 사이에 느슨한 결합을 도입하고 요청이 체인의 모든 핸들러에 의해 처리될 수 있기 때문에 실제로 처리된다는 보장이 없음

## Structure

![Untitled](Untitled%2057.png)

1. ***Handler***
    - 요청을 처리하기 위한 인터페이스 정의
    - 모든 핸들러가 BaseHandler를 상속받아 사용한다면 하지 않아도 됨
2. ***BaseHandler***
    - chain 다음 객체의 reference를 가짐
    - default 행위를 정의함
    - 모든 핸들러 클래스 공통 보일러플레이트 코드 포함
3. ***ConcreteHandler***
    - 요청을 실제 처리하는 코드 정의
      - 해당 객체에서 처리하거나 다음으로 넘기거나 하는 방식
      - 핸들러는 초기화 된 이후로는 immutable함
4. ***Client***
    - 필요에 따라 핸들러 체인을 만들고 요청을 보냄

- 적용성
    - 프로그램이 다양한 방식으로 다양한 종류의 요청을 처리할 것으로 예상되지만 정확한 요청 유형과 순서를 미리 알 수 없는 경우 사용
    - 특정 순서로 여러 핸들러를 실행해야 하는 경우 사용
    - 핸들러 세트와 그 순서가 런타임에 변경되어야 하는 경우 사용
- 장점
    - 요청 처리 순서를 제어할 수 있음
    - 작업을 수행하는 클래스에서 작업을 호출하는 클래스를 분리할 수 있음 ⇒ Single Responsibility Principle
    - 기존 코드를 손상시키지 않고 새 핸들러를 도입할 수 있음 ⇒ Open/Closed Principle
- 단점
    - 일부 요청은 처리되지 않을 수 있음
- 다른 패턴과의 관계
    - Command, Mediator, Observer
        - 모두 요청의 발신자와 수신자를 연결하는 다양한 방법을 다룸
            - CoR : 잠재적 수신자 중 하나가 처리할 때까지 잠재적 수신자의 동적 사슬을 따라 순차적으로 요청을 전달
            - Command : 발신자와 수신자 간의 단방향 연결을 설정
            - Mediator : 송신자와 수신자 간의 직접 연결을 제거하여 중재자 개체를 통해 간접적으로 통신하도록 함
            - Observer : 수신자가 수신 요청을 동적으로 구독 및 구독 취소할 수 있음
    - Composite
        - CoR은 주로 Composite과 함께 사용됨
            - 이 경우 leaf component가 요청을 받으면 모든 상위 component의 체인을 통해 component tree의 root까지 전달할 수 있음
    - Command
        - CoR의 핸들러를 Command를 이용해서 구현할 수 있음
        - 이 경우, 요청으로 표시되는 동일한 컨텍스트 개체에 대해 다양한 작업을 실행할 수 있음
        - 다른 방법
            - request 자체를 command로 구현
            - 이 경우, 체인으로 연결된 일련의 다른 컨텍스트에서 동일한 작업을 실행할 수 있음
    - Decorator
        - 매우 비슷한 클래스 구조를 가지고 있음
            - 재귀 구성을 이용해서 연속된 객체의 연산을 수행함
        - 하지만 결정적으로 다른 점이 있음
            - CoR : 서로 독립적으로 임의의 작업을 실행할 수 있음. 언제든지 요청을 다음으로 전달하지 않고 끝낼 수 있음
            - Decorator : 기본 인터페이스와 일관성을 유지하면서 객체의 동작을 확장함. 요청 중간에 끝내는 것이 불가능

