---

mindmap-plugin: basic

---

# 10. 조건부 로직 간소화<br/>Simplifying Conditional Logic

## 10.1 조건문 분해하기<br/>Decompose Conditional
- Background
   - 복잡한 조건부 로직은 프로그램을 복잡하게 만드는 가장 흔한 원흉이다.
   - 다양한 조건, 그에 따라 동작도 다양한 코드를 작성하면 꽤 긴 함수가 탄생한다.
   - 긴 함수는 그 자체로 읽기가 어렵고 조건문은 이 어려움을 증가시킨다.
   - 긴 함수에 있는 목적이 제대로 드러나지는 않는다.
   - 거대한 코드 블록이 주어지면 코드를 부위별로 분해한 다음 각 덩어리에 의도가 들어나도록 함수로 바꿔주자.
   - __조건문이 보이면 나는 조건식과 각 조건절에 이 작업을 해주길 좋아한다.__ __(즉 복잡한 조건식을 의도가 드러나는 코드로 바꿔주는 작업.)__
- Procedure
   - 조건식과 그 조건식에 딸린 조건절 각각을 __함수로 추출한다. (6.1 절)__

## 10.2 조건식 통합하기<br/>Consolidate Conditional
- Background
   - 비교하는 조건은 다르지만 그 결과로 수행하는 동작은 똑같은 코드들이 있다면 통합하라.
      - 하나로 통합하는 과정에서 함수 추출을 통해 코드의 의도를 더욱 명확하게 살릴 수 있기 떄문이다.
   - **함수로 추출하기는 무엇을 하는지에 대한 코드를 왜 하는지로 표현할 수 있는 리팩토링 기법이다.**
   - 이 기법을 왜 하는지를 알면 응용을 할 수 있다.
   - 독립된 로직이라고 판단이 든다면 이 기법을 사용하지 않는게 낫다.
- Procedure
   - 해당 조건식들 모두에 부수효과가 없는지 확인한다. (있다면 질의 함수와 변경 함수 분리하기 (11.1 절) 을 통해 분리하자.) **(부수효과가 있는 예제는 어떤 경우일까?)**
   - 조건문 두 개를 선택해서 두 조건문의 조건식들을 논리 연산자로 결합한다.
   - 테스트한다.
   - 조건이 하나만 남을 때까지 반복한다.
   - 하나로 합쳐진 조건식을 함수로 추출할지 고민해본다.

## 10.3 중첩 조건문을 보호 구문으로 바꾸기<br/>Replace Nested Conditional with Guard Clauses
-
   - Background
      - 조건문이 사용되는 케이스
         - 참인 경로와 거짓인 경로 모두 정상적인 로직이 필요한 경우.
         - 참과 거짓 경로 중 한쪽만 정상적인 로직이 필요한 경우.
      - 참, 거짓인 경로 모두 정상적인 로직이라면 if - else 절로 확실하게 두 동작을 보여주라
      - 한쪽만 정상 경로인 경우는 정상경로를 제외하고 빠르게 반환해준다.
-
   - Procedure
      - 교체해야 할 조건 중 가장 바깥 것을 선택하여 보호 구문으로 바꾼다.
      - 테스트한다.
      - 이 과정을 반복한다.
      - 모든 보호 구문이 같은 결과를 반환한다면 보호 구문의 조건식을 통합한다. (10.2 절)

## 10.4 조건부 로직을 다형성으로 바꾸기<br/>Replace Conditional with Polymorphism
- Background
   - 복잡한 조건부 로직은 프로그래밍에서 해석하기 가장 난해하다.
   - 클래스와 다형성을 이용하면 확실하게 분리하는게 가능하다.
   - 기본 동작은 가장 일반적이거나 가장 직관적인 동작이다.
   - 그 다음 변형 동작은 각각의 서브 클래스에 넣는다.
   - 기본 동작과 변형 동작이 섞여 있다면 코드가 지저분해질 수 밖에 없다.
   - 그러므로 가장 직관적이고 일반적인 코드는 슈퍼 클래스에 넣고, 기본 동작과 차이를 나타내는 변형 동작들은 서브 클래스에 넣도록 하는 방식이 있다.
- Procedure
   - 다형성 동작을 표현하는 클래스들이 없다면 만들어준다. 이왕이면 적합한 인스턴스를 알아서 만들어주는 팩토리 함수도 함께 만든다.
   - 호출하는 코드에서 팩토리 함수를 사용하게 한다.
   - 조건부 로직 함수를 슈퍼 클래스로 옮긴다.
   - 같은 방식으로 각 조건절을 해당 서브클래스에서 메소드로 구현한다.
   - 슈퍼클래스 메소드에는 기본 동작 부분만 남긴다.

## 10.5 특이 케이스 추가하기<br/>Replace Special Case
- Background
   - 데이터 구조의 특정 값을 확인한 후 똑같은 동작을 반복하는 코드가 곳곳에 등장한다면 이를 해결해야 한다.
   - 이 같은 경우는 반복되는 코드들을 한 곳으로 모아야 효율적이다.
   - 특수한 경우의 공통 동작을 하나에 모아서 사용하는 경우가 특이 케이스 패턴 (Special Case Pattern) 이라고 한다.
   - 특이 케이스는 여러 형태로 표현할 수 있다. 값 객체로 표현하는 것도 가능하고 어떠한 동작을 수행할 수도 있다.
   - 이 패턴이 주로 사용되는 경우가 null 인 경우라서 널 객체 패턴 (Null Object Pattern) 이라고도 하는데 널 외에도 특이 케이스 패턴을 적용할 수 있다.
- Procedure
   - 컨테이너(=클래스)에 특이 케이스인지 검사하는 속성을 추가하고 false 를 반환한다.
   - 특이 케이스 객체를 만든다. 이 객체는 특이 케이스인지를 검사하는 속성만 포함하고 이 속성은 true 를 반환한다.
   - 클라이언트에서 특이 케이스인지를 검사하는 코드를 함수로 추출한다. 모든 클라이언트가 값을 직접 비교하는 대시 방금 추출한 함수를 사용하도록 고친다.
   - 코드에 새로운 특이 케이스 대상을 추가한다. 함수의 반환 값으로 받거나 변환 함수를 적용하면 된다.
   - 특이 케이스를 검사하는 함수 본문을 수정하여 특이 케이스 객체의 속서을 사용하도록 한다.
   - 테스트 한다.
   - 여러 함수를 클래스로 묶기 (6.9 절) 이나 여러 함수를 변환 함수로 묶기 (6.10 절) 을 적용하여 특이 케이스를 처리하는 공통 동작을 새로운 요소로 옮긴다.
   - 아직도 특이 케이스 검사 함수를 이용하는 곳이 남아 있다면 검사 함수를 인라인 (6.2 절) 한다.

## 10.6 Assertion 추가하기<br/>Introduce Assertion
- Background
   - 특정한 조건 내에서만 동작하는 코드가 있을 수 있다.
      - 예로 제곱근 계산은 입력이 양수 일때만 동작할 수 있다.
   - 객체로 접근을 하면 필드 값을 기반으로 동작을 할 수도 있다.
   - 이런 조건이 코드에 명시적으로 드러나면 좋겠지만 그렇지 않은 경우도 있다. 알고리즘을 보고 연역적으로 알아내야 하는 경우도 있다.
   - 주석으로라도 표현이 되어있으면 좋고 가장 좋은 방법은 assertion 을 이용해서 코드 자체에 삽입해놓는 것이 가장 좋다.
   - 어서션 (Assertion) 은 항상 참이라고 가정하는 조건부로 이게 참이 아닌 값이 넘어온다면 프로그래머가 실수했다는 뜻이다.
   - 어서션의 실패는 시스템의 다른 부분에서 절대 검사하지 않아야하고 어서션이 있고 없고가 프로그램 기능 동작에 아무런 영향을 주지 않도록 작성해야 한다. __(단지 검사로만 이용을 해야한다 라는 뜻.)__
   - 그래서 어서션을 컴파일러에 켜고 끌 수 있는 스위치를 제공하는 프로그래밍 언어도 있다.
   - 어서션을 오류 찾기에 활용하라는 사람도 있다.
   - __물론 좋은 일이지만 어서션의 본질적인 목적은 프로그램이 어떠한 상태여야 하는지 다른 개발자들에게 설명해주는 도구라는 점이다.__
   - 디버깅하기도 편하고 소통 수단으로서의 가치도 있어서 나는 추적하던 버그를 잡은 뒤에도 어서션을 코드에 남겨 두기도 한다.
   - 테스트 코드가 있다면 어서션의 디버깅 용도는 줄어든다. __(테스트가 설명해주는 부분이 있기 때문에)__
   - 단위 테스트를 꾸준히 축해서 시각을 좁혀 놓으면 어서션보다 나을 때가 많다. 하지만 소통 측면에서 어서션은 매력적이다.
- Procedure
   - 참이라는 가정이 보이면 그 조건을 명시하는 Assertion을 추가한다.

## 10.7 제어 플래그를 탈출문으로 바꾸기
- Background
   - 제어 플래그는 코드의 동작을 바꾸는 곳에서 나온다.
   - 제어 플래그를 사용하면 코드를 이해하기 어려워지므로 이를 리팩토링해서 쉽게 바꾸자.
   - 제어 플래그의 주 서식지는 반복문이다.
   - break 문이나 continue 문에 익숙하지 않은 사람이거나, 함수의 return 을 적절하게 이용하지 못하면 나온다.
- Procedure
   - 제어 플래그를 사용하는 코드를 함수로 추출할지 고려한다.
   - 제어 플래그를 갱신하는 코드 각각을 적절한 제어문으로 바꾼다. 하나씩 바꿀 때마다 테스트한다.
   - 모두 수정했다면 제어 플래그를 제거한다.