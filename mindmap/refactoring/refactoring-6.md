---

mindmap-plugin: basic

---

# 6. 기본적인 리팩토링

## 6.1 함수 추출하기<br/>Extract Function
- Background
   - 가장 많이 사용하는 리팩토링 중 하나
   - 코드 조각을 찾아 무슨 일을 하는 지 파악 후<br/>독립된 함수로 추출하고 목적에 맞는 이름을 붙이는 것
      - Large Function<br/>(6줄 넘는 함수, 한화면 넘지말 것)
      - 하나의 기능만 담당하는 함수
      - 변경과 조회 분리
      - 중복 제거 -> 재사용성 증가
      - 목적과 구현 분리
   - 컴파일러가 캐싱을 잘해주기 때문에 성능 문제 없음
      - 성능 최적화를 위한 일반 지침
         -
            - 1. 하지마라
            - 2. 아직 하지마라
- Procedure
   - IDE 이용해 추출
   - 주의사항
      - **함수가 무엇을 하는지** 드러나게 이름 짓기
      - 연관된 문장들을 합쳐서 한번에 넘겨주는<br/>_문장 슬라이스 (8.6절)_ 도 필요할 수 있다
      - 필요한 변수 다 넘겨주는지 확인
         - 코드 안에서 변하거나 새로 생기는 변수 주의
         - 함수 안에서 수정되는 부분이 함수 밖에서도 유지가 되는지를 보자.<br/>(원시 변수를 넘기는 부분 즉 Call By Value 로 인해서 수정해도 변경이 안되는 부분)
      - 값을 반환할 변수가 여러개 일때
         - 반환하는 함수 값 자체를 여러개로 만들려고 한다면 이를 합치기
         - _임시변수를 질의 함수로 바꾸기 (7.4절)_,<br/>_변수 쪼개기 (9.1절)_

## 6.2 함수 인라인하기<br/>Inline Function
- Background
   - 필요 없는 함수 호출을 제거하기 위한 방법
   - 함수 본문이 함수 이름만큼 명확한 경우가 있다면 함수를 제거하는게 좋다
   - 리팩토링 과정에서 잘못 추출한 함수들이 있다면 이를 제거하기 위해 인라인
   - 간접 호출을 너무 과하게 쓰는 경우가 있을 때 인라인
- Procedure
   -
      - 1. 다형메소드 인지 확인
   -
      - 2. 인라인 할 함수를 호출하는 곳을 모두 찾아 교체
   -
      - 3. 인라인 하기 까다로운 부분이 있다면 이를 남겨놓고<br/>가볍게 바꿀 수 있는 부분부터 바꾼다
   -
      - 4. 함수 선언부를 제거
   - 주의사항
      - 변수의 이름이 달라서 여러번 이름을 바꿔야 하는 경우
         - 컴파일 에러가 안나는 선에서 한 문장씩 옮기며 테스트 진행

## 6.3 변수 추출하기<br/>Extract Variable
- Background
   - 하나의 표현식이 너무 복잡하다면<br/>표현식의 일부를 지역변수로 추출해서 관리하면 이해하기 쉽다
   - 변수를 추출하기로 결정했다면<br/>그것이 적용할 문맥이 어디까지 필요한지 살펴봐야 함
      - 이 함수 안에서만
         - 지역변수
      - 다른 함수에서도 사용
         - 함수로 추출하는게 나을 수 있음
   - 이런 맥락을 고려하면 중복 작성이 줄 수 있음
- Procedure
   -
      - 1. 추출하려는 표현식에 부작용 없는지 확인
   -
      - 2. 불변 변수를 선언하고 이름을 붙일 표현식의 복제본을 대입
   -
      - 3. 원본 표현식을 새로 만든 변수로 교체
   -
      - 4. 테스트
   -
      - 5. 표현식을 여러 곳에서 사용한다면 각각 교체

## 6.4 변수 인라인하기<br/>Inline Variable
- Background
   - 변수는 함수 안에서 특정한 의미를 가져서 코드의 이해를 도와줌
   - 하지만 변수가 많으면 리팩토링에 방해가 되고, 원래 표현식과 다르지 않을 때도 있음
- Procedure
   -
      - 1. 대입문의 우변(표현식)에서 부작용이 생기지 않는지 확인
   -
      - 2. 변수가 불변으로 선언되지 않았다면 불변으로 만든 후 테스트
   -
      - 3. 이 변수를 가장 처음으로 사용하는 코드를 찾아 대입문 우변의 코드로 변경
   -
      - 4. 테스트
   -
      - 5. 변수를 사용하는 모든 부분을 교체후 테스트
   -
      - 6. 변수 선언문과 대입문을 삭제
   -
      - 7. 테스트

## 6.5 함수 선언 바꾸기<br/>Change Function Declaration
- Background
   - 좋은 함수 이름은 무슨 일을 하는지 바로 알 수 있지만,<br/>나쁜 이름은 혼란을 일으킨다
   - 좋은 이름은 한번에 잘 짓기 힘들다
      - 함수의 목적을 주석으로 설명해보자
      - 역할에 집중해서 작명해보자
   - 매개변수는 함수와 어울려서 함수의 문맥을 정해줌
      - 활용 범위가 넓어질 뿐 아니라,<br/>다른 모듈과의 결합이 줄어듬
      - 어느 수준에 매개변수를 넘기는지 결정하는 것은 어렵다
      - ex) 대여한 지 30일이 지났는지를 기준으로<br/>지불 기한이 넘었는지 판단하는 함수<br/><br/>매개변수로 지불 객체 or 마감일?
         - 마감일: 날짜만 결합하면 되므로 다른 모듈과 결합하지 않아도 됨<br/>=> 신경쓸 요소가 적음
         - 지불: 여러 속성을 전달받을 수 있음<br/>=> 캡슐화 수준이 높아짐
      - 각각의 장단점이 있으므로 정답이 없음.<br/>우리에게 필요한 것은 _**고칠 수 있는 능력**_
- Procedure
   - 간단한 절차
      -
         - 1. 매개변수를 제거하기 전에 먼저<br/>함수 본문에서 매개변수를 참조하는 곳이 없는지 확인
      -
         - 2. 메소드 선언을 원하는 형태로 변경
      -
         - 3. 기존 메소드 선언을 참조하는 부분을 모두 찾아 변경
      -
         - 4. 테스트
   - 마이그레이션 절차<br/>(호출하는 곳이 많거나, 호출과정이 복잡하거나,<br/>호출대상이 다형 메소드이거나, 선언이 복잡한 경우)
      -
         - 1. 이어지는 추출단계를 수월하게 만들어야 한다면<br/>함수 본문을 적절히 리팩토링
      -
         - 2. 함수 본문을 새로운 함수로 추출<br/>(새로운 함수 이름은 임시로 해놔도 됨)
      -
         - 3. 추출한 함수에 매개변수를 추가해야 한다면 추가
      -
         - 4. 테스트
      -
         - 5. 기존 함수를 인라인
      -
         - 6. 함수 이름을 적절하게 변경
      -
         - 7. 테스트

## 6.6 변수 캡슐화하기<br/>Encapsulate Variable
- Background
   - 함수는 데이터보다 다루기 수월함
      - 함수를 변경할 때는 함수가 다른 함수를 호출하도록<br/>변경만 해주면 쉽게 바꾸는게 가능
      - 데이터는 데이터를 사용하는 모든 부분을 바꿔줘야 함
   - 그래서 접근할 수 있는 유효범위가 넓은 데이터는<br/>그 데이터의 접근을 독점하는 함수를 만드는 것이 좋음
   - (나는) 유효범위가 하나보다 넓은 가변 데이터는 모두 캡슐화
   - 데이터에 대한 결합도가 높아지는 것을 막을 수 있음
   - 객체 지향에서 객체의 데이터를 항상<br/>private으로 유지해야 한다고 강조하는 이유
      - 데이터 자체로 접근을 한다면 변경 어려움이 있음
   - 자기 클래스 안에서 필드 접근할 때<br/>getter를 쓰는 self-encapsulation을 강조하는 경우도 있지만<br/>과한 듯 보임
      - self-encapsulation을 해야할 정도라면<br/>클래스를 쪼개는게 바람직함
   - 불변 데이터는 가변 데이터 보다 캡슐화 할 이유가 적음
- Procedure
   -
      - 1. 변수로의 접근과 갱신을 전담하는 캡슐화 함수를 만듬
   -
      - 2. 정적 검사 수행
   -
      - 3. 변수를 직접 참조하던 부분을 모두 적절한 캡슐화 함수 호출로 변경.<br/>하나씩 바꿀 때 마다 테스트
   -
      - 4. 변수 접근 범위 제한
   -
      - 5. 테스트
   -
      - 6. 변수 값이 레코드라면 _레코드 캡슐화하기 (7.1절)_ 을 적용할지 고려

## 6.7 변수 이름 바꾸기<br/>Rename Variable
- Background
   - 개발을 진행하다 보니 문제를 더 잘 이해하게 되어<br/>그에 맞도록 이름을 변경하거나<br/>사용자의 요구사항이 변경되서<br/>그에 맞게 이름을 변경해야 하는 경우
- Procedure
   -
      - 1. 이름을 변경할 때 사용범위 고려.<br/>폭 넓게 사용되는 변수라면 _변수 캡슐화 하기 (6.6절)_ 고려
   -
      - 2. 이름을 바꿀 변수를 참조하는 곳을 찾아 하나씩 변경
   -
      - 3. 테스트

## 6.8 매개변수 객체 만들기<br/>Introduce Parameter Object
- Background
   - 데이터 항목 여러개가 여러 함수에 몰려다니는 경우<br/>데이터 구조로 모아준다
   - 파라미터 개수를 줄여 함수의 이해가 쉬워짐
   - 데이터 사이 관계가 명확해져 하나의 책임을 가질 수 있게 함
   - 이 리팩토링의 진정한 힘은 코드를 더 근본적으로 바꿔 줌<br/>(새로운 책임을 가진 객체가 만들어 짐)
      - 이러한 데이터 구조를 새로 발견하면<br/>이 데이터 구조를 활용하는 형태로 프로그램을 재구성하게 됨
      - 이 과정에서 새로 만든 데이터 구조(ex. 추상화)가<br/>문제를 보다 간결하게 표현할 수 있음
- Procedure
   -
      - 1. 적당한 데이터 구조가 없다면 새로 만든다
   -
      - 2. 테스트
   -
      - 3. _함수 선언 바꾸기 (6.5절)_로 새 데이터 구조로 매개변수를 활용
   -
      - 4. 테스트
   -
      - 5. 함수 호출 시 새로운 데이터 구조 인스턴스를 넘기도록 수정.<br/>하나씩 테스트
   -
      - 6. 기존 매개변수를 사용하던 코드를 새 데이터 구조의 원소를 사용하도록 변경
   -
      - 7. 다 바꾼후 기존 매개변수 사용하는 함수 제거 후 테스트

## 6.9 여러 함수를 클래스로 묶기<br/>Combine Functions into Class
- Background
   - 함수 호출시 공통 인수로 전달되는<br/>공통 데이터를 사용하는 함수가 여럿 있을 때 사용
   - 클래스로 묶으면 이 함수들이 공유하는 공통 환경을 더 명확하게 표현할 수 있음
   - 각 함수에 전달되는 인수를 줄여서 함수 호출이 간결해짐
   - 새로운 클래스와 관련해 놓친 연산을 찾아서<br/>새 클래스의 메소드로 뽑아내는 것도 좋다
   - 또 다른방법:<br/>_여러 함수를 변환 함수로 묶기 (6.10 절) _<br/>(맥락에 따라 잘 사용하기)
- Procedure
   -
      - 1. 함수들이 공유하는 _공통 데이터 레코드를 캡슐화 (7.1절)_ 한다
   -
      - 2. 공통 레코드를 사용하는 함수 각각을 새 클래스로 옮긴다.<br/>(_함수 옮기기 (8.1절)_)
   -
      - 3. 데이터를 조작하는 로직들은<br/>_함수로 추출 (6.1절)_ 해서 새 클래스로 옮긴다

## 6.10 여러 함수를 변환함수로 묶기<br/>Combine Functions into Transform
- Background
   - 소프트웨어는 데이터를 입력받아 여러 정보를 도출
   - 정보를 반복적으로 도출하는 로직이 있다면<br/>한 곳에 모으는 것이 바람직함
   - 검색과 갱신을 일관적으로 적용하는게 가능해짐
   - _여러함수를 클래스로 묶기 (6.9절)_로 처리해도 됨
      - 원본 데이터가 코드안에서 갱신되는 경우에는<br/>클래스로 문제 해결하는 편이 나음<br/>(데이터 변경을 클래스가 담당하는게 나음.<br/>데이터와 그 데이터를 다루는 메소드는 가까이 있는게 좋음)
      - 변환 함수로 묶는다면<br/>원본 데이터가 수정되면 일관성이 깨질수 있음
- Procedure
   - 1. 변환할 레코드를 입력받아서 값을 그대로 반환하는 변환 함수 만들기<br/>(깊은 복사를 이용하자. 원본을 바로 바꾸지 않는지가 중요할 수 있음)
   - 2. 묶을 함수 중 하나를 골라서 본문 코드를 변환 함수로 옮기고 레코드에 새 필드로 기록.<br/>그런 다음 클라이언트가 이 필드를 사용하도록 수정
   - 3. 테스트
   - 4. 나머지 묶을 함수 반복해서 처리

## 6.11 단계 쪼개기<br/>Split Phase
- Background
   - 서로 다른 두 대상을 한꺼번에 다루는 코드에 적용
   - 두 대상을 한번에 생각하는 것이 아니라<br/>한 대상씩 생각하기 위함
   - 다른 모듈의 상세 내용을 전혀 기억하지 않아도 되는 장점이 있음
   - 각 단계가 확연히 다른일을 수행하도록 해야함
- Procedure
   -
      - 1. 두 번째 단계에 해당하는 코드를 독립함수로 추출
   -
      - 2. 테스트
   -
      - 3. 중간 데이터 구조를 만들고 앞에서 추출한 함수의 인수로 추가
   -
      - 4. 테스트
   -
      - 5. 추출한 두번째 함수의 매개변수 검토.<br/>그 중 첫번째 단계에서 사용되는 것은 중간 데이터로 옮긴다.<br/>하나씩 옮길 때 마다 테스트
   -
      - 6. 첫 번째 단계 코드를 함수로 추출하면서<br/>중간 데이터 구조를 반환하도록 만듬