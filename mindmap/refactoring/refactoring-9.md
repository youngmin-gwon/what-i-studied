---

mindmap-plugin: basic

---

# 9. 데이터 조직화<br/>Organizing Data

## 9.1 변수 쪼개기<br/>Split Variable
- Background
   - 변수는 다양한 용도로 사용한다.
   - 그치만 변수를 사용할 땐 딱 하나의 역할만으로 사용해야 한다. 한 변수를 여러가지 목적으로 사용하면 코드를 이해하는데 혼란을 줄 수 있고 추후에 버그를 낼 가능성이 높다.
   - 이 말은 변수에 한번보다 많은 대입을 하는 경우에는 문제가 있다는 뜻이다.
   - 물론 여러번의 대입이 필요한 변수도 있다. 반복문을 돌아서 값을 누적시키는 변수의 경우.
- Procedure
   - 변수를 처음 선언한 곳 즉 대입하는 곳에 변수 이름을 바꾼다. (이때 가능하면 불변으로 선언하자. 그래야 컴파일 에러를 만나서 다음 대입 장소를 쉽게 알 수 있다.)
   - 이 변수의 이름을 다음 대입하는 곳까지 쭉 따라서 만들자.
   - 두 번째 대입하는 곳을 만나면 거기에서도 적절한 이름을 지어주자 (여기서도 불변으로 하자.)
   - 아까와 같이 쭉 따라서 두 번째 선언한 변수로 쭉 따라서 교체한다.
   - 테스트한다.
   - 이런 작업을 반복하면 된다.

## 9.2 필드 이름 바꾸기<br/>Rename Field
- Background
   - 이름이 중요하다는 사실은 다들 안다.
   - 프로그램 곳곳에 쓰이는 레코드의 필드들의 이름은 특히 더 중요하다.
   - 이런 이름들로 인해 데이터 구조를 이해하기 더 쉬워지고 결국에 프로그램을 이해하기 더 쉬워진다.
   - 데이터 구조가 중요한 만큼 프로젝트를 진행하면서 더 깊은 이해를 바탕으로 더 적합한 이름이 보인다면 즉시 이를 반영하도록 하자.
- Procedure
   - 레코드의 유효 범위가 제한적이라면 이름을 바꾸고 테스트해보자. 테스트를 통과한다면 이후 작업은 할 필요가 없다.
   - 레코드가 캡슐화되어 있지 않다면 캡술화부터 한다. __(자바에선 캡슐화가 되어있다.)__
   - 캡슐화된 객체 안 private 필드 명을 바꾸고 그에 맞게 내부 메소드를 수정한다.

## 9.3 파생 변수를 질의 함수로 바꾸기<br/>Replace Derived Variable with Query
- Background
   - 파생 변수란 말 자체부터 정확하게 정의하자면 기존의 변수를 조합해서 새로운 변수를 추출하는 걸 말한다. __(즉 기존의 변수들이 업데이트가 되면 이 변수에도 영향이 갈 여지가 있다는 뜻이다.)__
   - 가변 데이터는 소프트웨어에 문제를 일으키는 요소 중 하나다.
   - 주로 일으키는 문제는 한 쪽에서 업데이트 되서 연결된 다른 쪽에서 연쇄효과를 일으켜서 문제를 찾기 어렵게 만든다. __(여기서의 리팩토링 기법은 문제가 났을때 추적하기 위함. 비교적 쉽게 해결하기 위함이다.)___
   - __그렇다고 가변 데이터를 사용하지 않을 수도 없기 때문에 일단 가변 데이터를 사용하는 경우라면 유효 범위를 제한시켜 놓는게 가장 기본적이다.__
   - 또 효과가 좋은 방법으로 값을 계산해낼 수 있는 변수들은 모두 제거하고 함수로 만들어 두는게 더 나을 수 있다. __(매번 값을 계산해서 가지고 있다라는 것 보다 계산하는게 더 문제를 해결하기 쉽다. 함수 자체가 또 목적이 드러나므로 이해하기 더 쉬울수 있다. 함수를 찾는것 vs 변수에 값을 대입하는 부분을 찾기 이므로.)__
   - 물론 여기에는 합당한 예가 있다. 피연산자 데이터가 불변인 경우. 계산 결과도 일정할 것이므로 문제를 해결하기 쉽다. __(불변으로 만들어져있다는 것 자체가 문제의 원인을 찾기가 쉽다.)__
- Procedure
   - 변수 값이 갱신되는 지점을 모두 찾는다. 필요하다면 __변수 쪼개기 (9.1 절)__ 을 통해서 원인을 찾기 쉽게 구별시켜 놓자. __(주로 가변 데이터의 경우 변하는 값과 변하지 않는 값 이 두 요소로 나누는 것 같다.)__
   - 해당 변수의 값을 계산해주는 함수를 만든다.
   - 해당 변수가 사용되는 곳에 Assertion 을 추가해서 함수의 결과와 변수의 값이 같은지 확인한다.
   - 테스트한다.
   - 변수를 읽는 코드를 모두 함수 호출로 대체한다.
   - 테스트한다.
   - 변수를 선언하고 갱신하는 코드를 죽은 코드 제거하기 (8.9 절)로 없앤다.

## 9.4 참조를 값으로 바꾸기<br/>Change Reference to Value
- Background
   - 객체를 다른 객체에서 사용한다고 하면 참조 또는 값으로 취급한다.
   - 참조냐 값이냐에 따른 가장 극명한 차이는 변경인데 참조의 경우에는 내부의 객체의 값이 변경되면 전파되지만 값인 경우에는 새로운 객체가 전달되므로 기존 객체에는 영향이 없다.
   - 클래스 필드르 값으로 다룬다면 내부 객체의 클래스를 수정해서 값 객체 (Value Object) 로 만들 수 있다.
   - 값 객체로 다루면 불변성을 줄 수 있으므로 대체로 활용하기 쉽고 프로그램 외부로 던져줘도 나중에 그 값이 나 몰래 바뀌어서 내부에 영향을 줄까 걱정하지 않아도 된다. __(여기서의 리팩토링 기법은 문제가 났을 때 해결하기 쉽도록 하는 기법이다.)__
   - 그렇다면 참조 객체를 사용하는 경우는 언제일까?
   - 예컨대 특정 객체를 여러 객체에서 공유하고자 한다면, 한 객체의 변경이 다른 객체도 알아야 한다면 이런 경우에는 객체를 참조로 다뤄야한다.
- Procedure
   - 후보 클래스가 불변인지 혹은 불변이 될 수 있는지 확인한다. __(값 객체는 변경해서 사용하는게 아니라 새로 생성해서 사용하는 것이므로.)__
   - 각각의 세터를 하나씩 제거한다. (11.7 절) __(세터를 제거하는 이유가 다른 곳에서 변경하지 못하도록, 변경하는 곳이 있다면 컴파일 오류를 내도록 하기 위해서. 컴파일 오류가 있는 곳에는 새로운 객체를 사용하도록 하기 위해서.)__
   - 이 값 객체의 필드들을 사용하는 동치성 (equality) 비교 메소드르 만든다.

## 9.5 값을 참조로 바꾸기<br/>Change Value to Reference
-
   - Background
      - 하나의 데이터 구조 안에 논리적으로 똑같은 데이터 구조를 참조하는 레코드가 여러 개 있을 때가 있다.
      - 예로보면 주문 목록을 읽다 보면 같은 고객의 요청 주문이 여러 개 섞여 있을 수 있다.
      - 이때 고객을 값으로도, 참조로도 다룰 수 있는데 __둘의 차이는 변경의 유무만 신경쓰면 된다. 물론 복사를 하면 더 많은 메모리를 사용한다는 점이 있지만 크게 문제가 되진 않는다.__
      - __논리적으로 같은 데이터를 물리적으로 복제할 때 가장 큰 문제점은 데이터를 갱신할 때 일관성의 문제다.__
      - 데이터를 갱신하면 모든 복제본의 데이터가 빠짐없이 갱신되어야 하고 하나라도 빠지면 안된다라면 연결된 참조로 바꿔주는게 좋다.
      - 값을 참조로 바꾸면 엔터티 하나당 객체가 단 하나만 존재하게 되는데 그러면 보통 이런 객체들을 한데 모아놓고 클라이언트들의 접근을 관리해주는 일종의 저장소가 필요해진다.
      - 각 엔터티를 표현하는 객체를 한 번만 만들고, 객체가 필요한 곳에서는 모두 이 저장소로부터 얻어쓰는 형태가 된다.
- Procedure
   - 같은 부류애 속하는 객체들을 보관할 저장소를 만든다.
   - 생성자에서 이 부류의 객체들 중 특정 객체를 정확히 찾아내는 방법이 있는지 확인한다.
   - 호스트 객체의 생성자들을 수정하여 필요한 객체를 이 저장소에서 찾도록 한다. 하나씩 수정할 때마다 테스트한다.

## 9.6 매직 리터럴 바꾸기<br/>Change Magic Literal
- Background
   - 매직 리터럴 (Magic Literal) 이란 소스 코드에 등장하는 일반적인 리터럴 값을 말한다.
   - 예컨대 움직임을 계산하는 코드에서라면 9.806655 라는 숫자가 산재해 있다. __(중력 가속도를 말하는 듯)__
   - 이런 숫자는 특별한 의미가 있어서 이런 의미를 알지 못한다면 코드를 읽는 사람은 이해하기 어렵다. 이런 코드를 매직 리터럴 이라고 한다.
   - 이런 매직 리터럴 코드를 보면 코드 자체가 어떤 의므를 나타내는지 분명하게 드러내 주는게 좋다.
   - 리팩토링 기법은 쉽다. 숫자대신 상수를 정의하고 상수를 사용하도록 바꾸면 된다.
   - 매직 리터럴은 대체로 숫자가 많지만 다른 타입의 리터럴도 특별한 의미를 지닐 수 있다.
   - 예컨대 "M" 은 남성을 "서울" 은 본사를 뜻할 수도 있다.
   - 일반적으로 해당 값이 쓰이는 모든 곳을 적절한 이름의 상수로 바꿔주는 방법이 가장 좋다.
   - 상수로 바꾸는 것과 함께 다른 방법이 있는데 비교 로직이 있다면 고려해볼 수 있는 방법이다.
   - 예를 들어 `aValue == "M"` 을 `aValue == MALE_GENDER` 로 바꾸기보다. `isMale(aValue)` 라는 함수 호출로 만드는 걸 선호한다.
   - 상수를 사용할 땐 상수를 과용하는 것도 의미없다. `int ONE = 1` 과 같은 의미없는 상수는 사용하지 않아도 된다.
   - 그리고 리터럴이 함수 하나에서만 쓰이고 함수가 충분한 맥락을 제공해주고 있다면 상수를 사용하지 않아도 된다.
- Procedure
   - 상수를 선언하고 매직 리터럴을 대입한다.
   - 해당 리터럴이 사용되는 곳을 모두 찾는다.
   - 찾은 곳 각각에서 리터럴이 세 상수와 똑같은 의미로 쓰였는지 확인하며, 같은 의미라면 상수로 대체한 후 테스트한다.