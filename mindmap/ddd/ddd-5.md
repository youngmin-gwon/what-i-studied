
---

mindmap-plugin: basic

---

# 5. 소프트웨어에서 표현되는 모델

## 객체 구분법
-
   - 도메인 개념을 담은 객체를 설계가 어렵기 때문에 모델 요소의 의미를 명확하게 하고 특정 종류의 객체를 도출하기 위한 설계 구분법 탄생함
-
   - 이외의 것
      - Module
         - high cohesion, low coupling
         - 모듈로 쪼개지는 것은 코드가 아닌 개념
            - 한번에 생각할 수 있는 양에는 한계가 있고(=결합도를 낮춰야함)
            - 일관성 없는 단편적인 생각은 획일적인 생각을 섞어놓은 것 처럼 이해하기 어렵다(=응집도를 높여야함)
         - module도 하나의 의사소통 매커니즘이므로, 분할되는 객체의 의미에 따라 module을 선택하라
         - 시스템의 내력을 말해주는 module을 골라 일련의 응집력 있는 개념들을 해당 module에 담아라
         - 서로 독립적으로 이해하고 논리적으로 추론할 수 있다는 의미에서 낮은 결합도가 달성되도록 노력하라
         - ubiquitous language를 구성하는 것으로 module의 이름을 부여하면 도메인에 대한 통찰력을 줄 수 있다
            - 모델에 초점을 맞춰 사고하면 지엽적인 해결책이 아닌 더욱 심층적인 해결책이 만들어진다
         - 단순하게 유지하라
- 구분법에 따른 모델 표현법
   - Entity
      - 연속성과 식별성이 이어지는 객체
      - 생명주기 동안 형태와 내용이 급격하게 바뀔수 있지만 연속성은 유지해야 함
      - 의미에 따라 분류한다면 모델이 더욱 투명해지고 구현은 견고해짐
      - 주의사항
         - 한 객체가 속성보다는 식별성으로 구분될 경우 모델 내에서 이를 해당 객체의 주된 정의로 삼아라
         - 클래스 정의를 단순하게 하고 생명주기의 연속성과 식별성에 집중하라
         - 객체의 일치여부를 판단하는 요구사항에 주의하라
            - == 연산 주의
            - 각 객체에 대해 유일한 결과를 반환하는 연산을 정의하라
               - 식별성을 정의하려면 도메인을 이해해야 한다
               - 어떤 데이터 속성, 여러 속성 조합으로 고유키 생성
                  - yymmdd
               - 고유키가 없다면, 각 인스턴스에 유일한 기호를 덧붙임
               - 시스템에서 ID 자동으로 생성
                  - ID가 사용자에게 중요하지 않은 경우: 이름이 동일한 연락처 구분
                  - ID가 사용자에게 중요한 경우: 화물 조회번호
                  - ID가 컴퓨터 시스템 범위를 넘어야 하는 경우: 두 병원 간에 의료 기록을 교환하는 경우
         - 외부에서 가져오거나 시스템에서 자체적으로 만들어 내는 임의의 식별자 일 수도 있지만, 모델에서 식별성을 구분하는 방법과 일치해야 한다
      - 모델링
         - entity의 가장 기본적 책임:
   - Value Object
      - 식별성을 갖지 않으면서 사물을 서술하는 객체
         - 어느 것인지 보다, 무엇인지가 더 중요한 경우
      - 반드시 단순하지 않음
         - 여러 value object 조립
         - entity 참조
      - 주의사항
         - 모델에 포함된 어떤 요소의 속성에만 관심이 있다면 value object로 구현하라
         - 불변적으로 다뤄라
         - 아무런 식별성도 부여하지 말고 entity를 유지하는데 필요한 설계상의 복잡성을 피하라
         - 구성하는 속성은 개념적 완전성을 형성해야 한다
            - 원시 타입을 가능한 사용하지 않아, 더 응집력 있는 value object를 만들 수 있음
      - 모델링
         - 객체를 안전하게 공유할 수 있으려면 해당 객체가 불변적이어야 한다
            - 특정 언어에서는 불변성을 지원하지 않더라도, 직접 개념적으로 구분을 해줘 이러한 구분을 유용하게 만들어야 한다
            - 변경을 허용할 때가 있지만, 가급적으로 변하게 하지 않아야한다
               - 변경이 가능하다면 그것을 공유해서는 안된다
               - 변경 가능한 구현에 영향을 주는 요인
                  - value가 자주 변경되는 경우
                  - 객체 생성이나 삭제에 비용이 많이 드는 경우
                  - value를 공유할 일이 그리 많지 않거나 클러스터링을 향상시키기 위해서나 다른 기술적인 이유로 공유가 보류된 경우
         - value object는 많아지는 경향이 있으므로 성능 최적화를 위한 별도의 대안을 마련하는 것이 중요할 수 있다
            - flyweight 패턴
         - 복사와 공유 중 어느 것이 경제성 면에서 더 나은지 구현 환경에 따라 달라진다
            - 복사의 경우 객체의 개수가 굉장히 많아져 시스템이 무거워질 수도 있음
            - 공유의 경우 분산 시스템에서 느려질 수 있음
            - 공유가 도움이 되고 문제가 적게 일어나는 경우
               - 공간을 절약하거나 데이터베이스 내의 객체 수를 줄이는 것이 중요한 경우
               - 통신 부하가 낮은 경우
               - 공유 객체의 불변성이 엄격하게 지켜지는 경우
   - Service
      - 모델에서 독립적인 인터페이스로 제공되는 연산
      - 주로 활동으로 이름을 짓는다
         - 연산의 이름을 ubiquitous language의 일부가 되게끔 구성
      - 상태를 캡슐화 하지 않음
      - service의 매개변수와 결과는 도메인 객체여야 한다
      - 잘 만들어진 service의 특징
         - 연산이 원래부터 entity나 value object의 일부를 구성하는 것이 아니라 도메인 개념과 관련이 있다
         - 인터페이스가 도메인 모델의 외적 요소의 측면에서 정의된다
         - 연산이 상태를 갖지 않는다
      - service는 모든 계층에서 사용될 수 있다
         - 도메인 계층에서 사용되는 것들과 다른 계층에서 사용되는 것들을 구분하여 계층간의 경계를 선명하게 구분해야 함

## 연관관계를 쉽게 다루기
- 탐색방향을 부여
   - 가능한 관계는 한방향으로만 하기
   - 두 방향을 모두 탐색해야한다는 요건이 없을 경우 탐색 방향을 추가하면 상호의존성이 줄어들고 설계가 단순해짐.
- 한정자(qualifier)를 추가
   - 다중성(multiplicity)을 1:1로 줄이게 해줌
   - 중요한 규칙을 명시적으로 모델에 포함할 수 있음
- 중요하지 않은 연관관계를 제거

## Model Driven Design의 효과를 놓치지 않으면서 구현과 조화를 이루기 위한 기본적 사항

## 모델링 패러다임
- 객체지향 패러다임이 가장 지배적
   - 개념은 단순하지만, 중요한 도메인 지식을 포착할만큼 풍부한 것으로 입증되었기 때문
   - 개발자 커뮤니티와 설계 문화가 성숙함
- 반드시 객체 패러다임만 써야하는 것은 아님
   - 도메인의 중요한 부분이 다른 패러다임에 속하는 것으로 보일 때는 구현을 지원하는 도구를 혼용해 모델에 어울리는 패러다임의 각 부분을 모델링 하는 편이 더 낫다
   - (어렵지만) 여러 패러다임을 적용한다면, 모든 패러다임에서 작용할 수 있는 단 하나의 모델을 적용해야함
- 객체가 아닌 요소를 객체 지향 시스템에 혼합하는 4가지 휴리스틱
   - 구현 패러다임을 도메인에 억지로 맞추지 않는다
   - 유비쿼터스 언어에 의지한다
   - UML에 심취하지 않는다
   - 회의적이어야 한다