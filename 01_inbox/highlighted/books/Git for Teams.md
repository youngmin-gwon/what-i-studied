## Metadata
- Author: Emma Jane Hogbin Westby
- [Apple Books Link](ibooks://assetid/C890693458A9353AA686BECC1F6370DD)

## Highlights
Version control should never be the hard part.

---
product backlog

---
I think the real advantage is that you can do more of your thinking in private.

---
It is appropriate to add your Code of Conduct (CoC) document to the project’s supporting website. If you do not have a separate website for your project, you could add your CoC as a wiki page within GitHub.

---
Needs Testing

---
In your ticket tracker add a comment to the ticket to include a note about the rationale for the approach you took and some kind of proof that the work was been completed.

---
Suggesting changes to a project from collocated repositories

---
Pivotal Tracker, JIRA, Redmine, and Unfuddle

---
rebasing

---
conventions allow us to quickly pick up the patterns of how a software project runs and integrate our work without disrupting the flow for others on the team.

---
When working on new code, GitHub Flow has the developers create a descriptively named feature branch and commit their work regularly to this branch.

---
Apache License

---
The restrictions are presumably handled via Git’s pre-commit hooks to ensure access control is respected.

---
ensuring your branch is kept up to date with rebasing

---
Merge the ticket branch into the branch develop, and, assuming there are no merge conflicts, push the updated branch to the central repository

---
Governance model: contributors with collocated repositories


Integration merge: performed by the reviewer


Integration branch: develop

---
does not require an extensive testing infrastructure to start using

---
This pattern works extremely well for small teams with no peer review requirements.

---
GNU General Public License (GPL)

---
The easiest branching strategy to understand

---
ensure the branch is up to date with develop

---
Publishing a Stable Release

---
how to chain these methods together to create a custom access model that is perfect for your team.

---
Your job is to engage in conflict resolution and choose the best shared history for the work in question.

---
Identify roles within a complete team


Structure meetings so they have useful outcomes


Recognize key phrases from people who are working in an opposing state from what the team should be working on

---
Access Models

---
Technical review board or Project Management Committee

---
Ensure the ticket branch is up-to-date and then merge your work in the branch develop, and, assuming there are no merge conflicts, push the updated branch to the central repository.

---
square brackets ([#1234])

---
commit message with

---
If developers start their work from the wrong branch, it can be squirrelly to get everything back in sync.

---
the GitLab Flow model.

---
multiple access models for a given project

---
Post-Launch Hotfix

---
disadvantages

---
If your content isn’t code

---
During the demo, each person who completed work should list the ticket number he or she was working on, and show the outcome of that work. Having this demo once a week encourages an “always be finishing” culture, which breaks work into small, doable chunks.

---
merging

---
When developers think their work is complete, or when they need help with their work, they will issue a pull request to the master branch.

---
Scheduled Deployment

---
Git does not have the ability to control access—instead, it allows any developer full read/write access to the repository

---
adding a pound sign (#) will automatically link the commit message to the ticket number

---
disadvantages

---
Adding square brackets around the ticket number

---
The easiest way to be consistent is to follow a set of rules, or a checklist.

---
what if you have changes committed in your repository that are only mostly finished? This is where we start to move away from a purely continuous deployment strategy, and toward multiple branches in a scheduled deployment strategy.

---
workflow

---
integration branches

---
Choosing a Convention

---
just a simple content tracker

---
Shared Maintenance Model

---
Refer back

---
It is assumed that code will be checked and verified before it is committed to the main

---
GitFlow conventions will feel very familiar to software developers once they understand the process of how and where their typical tasks happen in the branching convention.

---
do anything they want with your code as long as they provide attribution back to the original authors of the work

---
Create a local copy of a remote repository


Initialize version control for an existing set of files


Create a new repository from an empty project directory


Examine the history of a repository via its commit messages


Work with branches to isolate different streams of work


Make commits to a local repository


Use tags to highlight individual commits


Connect your project to a remote code hosting system

---
the general rule is that the person who created a work owns the right to copy and distribute the work

---
Pull Request

---
rarely should a ticket be reopened after it has passed a code review, quality assurance review, and a client review.

---
changes from other developers are never forced into your work; instead, it is your decision of when to incorporate

---
Evolving Workflows

---
A rebasing strategy can be more difficult especially if it is not performed regularly; however, it does give your history a cleaner graph that is easier to review.

---
a branch is a way to separate parallel thinking about how a piece of code might evolve

---
useful for projects with very strict regulations on who could commit

---
developers should always be able to determine from which branch they should begin their work.

---
For a bigger feature

---
“Can we try …”


“I know we’re done, but what about …?”


“OMG! I just had this great idea …”


“Have you thought about doing it like this instead?”

---
Pencil, OmniGraffle, Dia, and Inkscape.

---
may not actively participate in every code review, but ultimately retains the control to reject or reverse any decision made

---
Optionally, push your ticket branch to the code hosting repository.

---
disadvantages

---
A Basic Workflow

---
Choosing an appropriate branching strategy for your team requires a conversation with your teammates about how you want to release your work.

---
Git might be INTP, and Subversion might perhaps be ESFJ.

---
Perform a review of the work according to the original ticket description

---
You cannot copyright an idea

---
advantages

---
Resolves

---
requires a change notice that describes how the derivative work changes from the previous version

---
code hosting systems have incorporated pre-commit hooks that can be used to limit access per-branch.

---
Individual contributors make a clone, or fork, of the project to their own repository on the code hosting system

---
Dispersed Contributor Model

---
 a good model for versioned software

---
Your project, and each of the component parts within the project, should have an opening sequence, the bulk of the activity, and a wrap-up

---
if the work is re-framed as a way to help a person, you’re more likely to get it done.

---
make a final commit with the keyword “Resolves” and then the ticket number: Resolves #1234.

---
Establishing conventions with your team will help to maintain consistency, which will help you to quickly decipher the history of your code.

---
open-engage-close sequence

---
Kanban-style system

---
Governance model: contributors with shared maintenance


Integration merge: performed by the reviewer


Integration branch: develop

---
this clause prevents employees from starting at a new job and reverse engineering or creating an equivalent piece of work from the one they developed for their former employer

---
Branches don’t care what changes they’re tracking! They just are.

---
By using your documentation to complete your work, you ensure your documentation is always up to date

---
This license allows you to grant redistribution rights, with or without modification, for commercial or noncommercial use.

---
A creative thinker’s greatest asset is the ability to find unpredictable solutions to problems

---
Card

---
fully reviewed and tested by the community, the coders can make a merge request or pull request from their public clone to the main repository.

---
You can make new branches, think about new ideas in code and—only when you’re ready

---
increase collaboration between departments

---
requirement for developers to remove old branches as they are rolled into master.

---
When you share a branch with others

---
If you are working on tickets that have subtasks, ensure the branch name uses the most relevant ticket number

---
searchable system

---
When updating a branch

---
the use of a bug tracker to capture all requirements.

---
introduce two additional types of branches:

---
which features should be incorporated into the master branch for deployment

---
advantages

---
For most projects starting today, this model is not appropriate

---
make a copy of a repository

---
DAG

---
Ready for Work

---
outside work, and when to share your own.

---
When the community is happy with the solution, they mark an issue as Reviewed and Tested by the Community

---
Meeting

---
The team will need to, instead, adhere to a patch formatting policy (signed or not), and a commit message style

---
a stripped down version of GitFlow

---
three main parts

---
Indeed, most open source projects will have different levels of access for different contributors.



---
Documenting Your Process

---
I don’t think there is any one system that is better at tracking software development

---
Meta ticket or Epic ticket

---
Benevolent Dictator for Life (BDFL)

---
Collect stories

---
Collocated Contributor Repositories Model

---
long-running public branch

---
If you encounter a public project that does not have an explicit license, and you want to incorporate the work into your own, get in touch with the project maintainers first and ask them to add a license to their work.

---
“I’m ready to move on to …”


“No. We’ve already made a decision …”


“I don’t know why I think this, but …”


“Last time we tried this …”


“So I think the real problem is …”


“My gut tells me …”

---
idea of a location or snapshot for some of the branches

---
It does, however, help to understand some of the more advanced commands, such as bisect, if you are able to think about commits as whole ideas

---
Issue-Based Version Control

---
the public clone, coders can solicit feedback on their work to date.

---
Listen with intention

---
not always obvious where to start

---
Basic workflow


Integration branches


Release schedules


Post-launch hotfixes

---
Flickr

---
A trusting, empathetic team is more likely to help its coworkers with the specific Git commands necessary to get the job done.

---
There aren’t very many branches

---
care just enough about the people you work with

---
begin a ticket

---
control over who is allowed to write to the primary project repository

---
easier to communicate plans to outside stakeholders by using the Scrum approach to time-boxed sprints.

---
If you are working on only part of the larger feature, you should use the smallest relevant ticket number

---
no guessing about the purpose of each branch

---
Leadership Models

---
all new work is done in a feature branch

---
rebasing will make future work easier (even though it can be more time consuming in the moment).

---
In Progress

---
Push your branch to the code hosting repository

---
understanding thinking

---
project branch, and that, generally, the developers are trusted

---
Integration merge: performed by original developer


Integration branch: develop

---
Authorship, copyright, and distribution licenses

---
these release branches should follow semantic versioning conventions, although GitLab Flow does not explicitly require it.

---
Code of Conduct

---
the community most active on a given part of the system is encouraged to find solutions that are appropriate.

---
write down what you want to work on

---
rapid deployment of code.

---
State Branching

---
test

---
email

---
quick to undo the mistake

---
The assumption is that the main branch contains deployment-ready code. If your team doesn’t have a testing infrastructure, it can be risky

---
Self-managing teams are often filled with trust and respect for one another

---
“So what you’re saying is …?”


“Just to clarify …”


“Can you tell me how …?”


“Is this related to …?”


“So I made this spreadsheet …”


“That must feel horrible!”

---
you can generate entirely new ways of approaching problems, allowing you to improve your workflow and solve bigger problems.

---
The agreement varies per company, but the gist of most of them is “if you choose to submit a contribution, you agree to reassign your copyright to the project.”

---
someone who’s being asked to do too much without the right amount of context is definitely going to miss something, eventually.

---
MIT License

---
Understanding Branches

---
less confusion

---
How to choose a branching convention for your team


Mainline development


Branch-per-feature deployment


State branching


Scheduled deployment

---
In Progress

---
Mainline Branch Development

---
Ongoing Development

---
start to get into the habit of writing yourself love notes for what you plan to do with your software

---
look inward to our own team

---
the leader of the project has final say over every decision about every aspect of the code base.

---
Being aware of these preferences can help us to have stronger collaboration while building new features, more productive code reviews, and overall, a healthier, happier team.

---
optional build step

---
create a second clone of the repository—this time from the forked repository to your local workstation

---
Single Repository

---
update the status

---
anything that has not been deemed relevant for this work effort (or sprint)

---
Copyright and Contributor Agreements

---
Commits

---
Consensus-driven, leader-approved

---
quality assurance team

---
In Definition, In Development, and In Testing.

---
The analytic thinker’s greatest asset is the ability to see patterns and bring clarity to a situation.

---
create a new branch.

---
Example 4-1. Template workflow

---
Cultivating Empathy

---
In Progress

---
A fourth dimension, personal spirit, is used to indicate how likely a person is to engage

---
ensuring you keep the ticket branch up to date with any changes that might have been incorporated into the branch master since you started your work

---
Using ticketing systems, however, can make teams dependent on sticking with that particular system if the decisions aren’t also captured in the commit messages for each change to the repository.

---
The workflow you use may change before and after the launch of your product.

---
Dispersed Contributor Repositories

---
variant of this model

---
If I’m trying to brainstorm how to solve a merge conflict in Git, and you tell me I shouldn’t have used rebase, we’re at odds in the conversation. I’m trying to use my “green” thinking to go through a problem, and you’ve just used your “red” thinking to stop the conversation.

---
scheduled deployments can get quite complex in their branching patterns.

---
you either are a committer for any

---
When you are working in a distributed team, it becomes much easier to think of people on your code team as “resources” and not as human beings.

---
Git is just a simple content tracker; it does not include access control mechanisms out of the box

---
The trick to a motivated, cohesive team is to respect each of the individuals on the team and, where possible, to optimize the process to suit their preferences.

---
only a very few people are able to commit code

---
advantages

---
three most popular models

---
On Deck

---
No matter what the issue, understanding and dealing with the underlying social problems first can make learning and using Git a lot easier.

---
Find mentors from within your code community, and offer to mentor others.

---
when you are working with collocated contributors, you need a chain of repositories in place to be able to share your work back.

---
understanding information (analytic), and understanding people (compassion)

---
Part of your testing process should include a security review

---
These branches are kept up to date with the work being done by other developers via an integration branch.

---
Product Manager: Name
Dev site: URL
Branch deployed on dev site: name of branch
Live site: URL
Branch deployed on live site: name of branch
When starting a dev ticket, branch from: name of branch
When starting a hotfix ticket, branch from: name of branch
When updating your work, use: git command
When merging your work post review, use: git command

---
Documenting Encoded Decisions

---
more appropriate for code that is automatically loaded onto a user’s device (for example, a website)

---
including the keyword “resolves” will automatically move a ticket from In Progress to the next state

---
Team

---
Project methodologies that track the work of people will all have some variation of these basic ideas:

---
Wrap-Up and Retrospectives

---
easier for people to select the right branch when merging

---
Problem

---
fewer emergency fixes, because any code that is saved into the main branch is ready to be deployed.

---
central code hosting system

---
A community code of conduct allows you to explicitly detail what is expected of those who participate in your project.

---
In the GitHub Flow branching model, anything in the master branch is deployable

---
give you the number for the branch you will create to work on your ticket.

---
an insider language that can make onboarding more difficult if there are a lot of open features.

---
When you have completed your work

---
Perform a review of the work according to the original ticket description

---
delete their local copies of the ticket branch

---
Run relevant tests for your code to ensure typos and basic errors are caught

---
branch on the repository, or you are limited to making your contributions through pull requests

---
if you were using extra contractors and you wanted to limit their ability to accidentally add something to the repository that hadn’t first undergone a review of some kind

---
feature branches

---
An official project repository

---
Creative Commons license

---
acts as your backup, so don’t skimp on this step

---
the person who can best describe a problem is the most likely to solve it

---
disadvantages

---
advantages

---
short-lived private branch

---
making onboarding more difficult

---
Once you have a way of tracking your ideas, the process for doing work should follow these steps:

---
Completed

---
If you are not responsible for your deployments, bring the operations team on board as early as you can as well

---
creative thinking, understanding thinking, and decision thinking

---
begin with the end in mind

---
Run relevant tests for your code to ensure typos and basic errors are caught.

---
The branching strategy that you use depends on your release management process

---
Distribution Licenses

---
most force you to limit control on a per-repository basis

---
decision thinking

---
If you are a distributed team, you may also want to have a few scheduled social calls. Lullabot, a wholly distributed company of approximately 50 people, adds the following nonproject calls to its schedule. The aim of these additional meetings is to develop a greater empathy between staff members:

---
Ticket Progression

---
Leadership models, which can set the tone for how contributions are made to your project

---
Ready for Development, Ready for Code Review, Ready for Testing, Ready for Client Approval, and Ready for Deployment.

---
Trusted Developers with Peer Review

---
Individual preferences for different thinking strategies can derail teams quickly

---
If I have two unrelated ideas that I am working on, I might be lazy and choose to commit everything, or I might stash some of the work to save it for later. For these simple projects, it doesn’t warrant separating thinking into different branches in order to work efficiently

---
production environment

---
completely relevant to the work at hand

---
Done

---
Shared maintenance

---
the ticket can be closed.

---
Most branching strategies separate the work in your project by coarse ideas

---
however, now that the branch has been shared, someone else could also be adding commit objects to their copy of the branch

---
I recommend finding a small unit of time to iterate through

---
accept the pull request

---
there is an extra maintenance requirement for developers who need to keep their features up to date while waiting to be rolled into the deployed branch.

---
you will also need to decide how your team will incorporate new work into shared branches; and keep branches up to date.

---
Any commit objects you create are local and exclusively yours until you choose to explicitly share them with a remote repository.

---
Balsamiq for very basic diagrams

---
There are no fixed rules built into Git that will help you to control access to your code

---
Docker and/or Vagrant to create an exact replica of your environment.

---
Untrusted Developers with QA Gatekeepers

---
Preferences for different thinking strategies can derail progress. Ensuring the right strategies are being used at the right time can reduce friction, and make work faster and more fun.

---
working on tickets, or issues

---
Rationale

---
close the ticket

---
A branch always begins from a specific point in the code base

---
This is radically different than the centralized model of version control where committing a change automatically uploads the work.

---
Confirmation

---
Over-communicating is a great habit to get into, but that doesn’t mean wasting all of your time in meetings. A successful team will only meet to achieve very specific outcomes.

---
From the branch develop, create a new branch whose name includes the ticket ID and a terse description of the work

---
Branching Strategies

---
The function of a short-lived branch is to sandbox the development of a new idea. These new ideas could be bug fixes, feature additions, or experimental refactoring. It’s up to you!

---
Governance model: contributors with shared maintenance

---
When it is time to release software, the build master can selectively choose which features to include in the build and create a new integration branch for deployment

---
are relatively small

---
delete your local ticket branch and the remote copy of the ticket branch.

---
Through branch naming conventions, GitLab Flow makes it clear what code is going to be used in what environment, and therefore what conditions might need to be met before merging in commits.

---
Conversation

---
Access can be limited or open for any given repository

---
This pause in the automated process is refered to as a merge conflict

---
Collocated contributor repositories

---
if you are anticipating others contributing as well, you should consider outlining how you want the project to be run.

---
submit their requested changes in the form of a merge request or pull request

---
Git further does not allow you to be locked out of only some branches, as you might find in Subversion.

---
get to know the community that built the products you will be working with

---
the reviewer will now close the ticket and notify the developer that his or her work has been merged into the main branch

---
project maintainers

---
sign the individual commits before sharing them; however, this makes it more difficult to unpack the history of who made which changes if multiple people were involved.

---
Collocated Contributor Repositories,

---
Because the branch names are extremely specific to the context of that team

---
update

---
Releasing Software According to Schedule

---
Not Now

---
Before launch, you will likely have fewer integration branches, because the concept of a hotfix is unlikely to be an issue.

---
Do Not Allow Your Project Managers to Overcategorize!

---
In Progress

---
Begin each commit message with the ticket number enclosed in square brackets: [#1234]

---
a distributed version control system

---
subdivide this stage into separate subcategories, such as:

---
GitHub

---
requires anyone who distributes your code or a derivative work to make the source available under the same terms

---
it’s just the convention of what type of work is committed to the branch that differs.

---
Branch-Per-Feature Deployment

---
Basic tools to document your team’s process


Where documentation should be placed


What types of things need to be documented


Sample states for your ticketing system

---
cognitive overhead for developers who are new to software deployment

---
Codes of Conduct, which establish firm guidelines for expected and acceptable behavior of contributors

---
For very novice teams, there is not always an obvious answer to how branches should be kept up to date. Two strategies were offered: rebasing or merging.

---
patch file

---
Quality assurance test

---
A more modern approach to this model is to use fork, or clone, repositories on a single code hosting system.

---
not as trendy as continuous deployment

---
No matter which system you use, I encourage you to track at least the rationale for the decisions that are made about why features are being built in an easy-to-read and

---
Having dispersed repositories isn’t specific to projects that communicate via mailing lists

---
Needs Testing

---
Dispersed contributors