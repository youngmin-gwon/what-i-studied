# 02. 명령, 인용, 확장 규칙

## 시험 포인트
- **확장 순서**: 브레이스 → 틸드 → 파라미터 → 명령 → 산술 → 경로(glob) → 단어 분리
- 단어 분리와 글로브를 제어하는 **더블 쿼트**의 중요성
- `$( )` 명령 치환 vs 백틱 `` ``: 중첩/가독성/이스케이프
- **파라미터 확장 옵션**: `${var:-default}`, `${var:=default}`, `${var:?msg}`, `${var:+alt}`
- **패턴 제거**: `${var%pattern}`, `${var%%pattern}`, `${var#pattern}`, `${var##pattern}`
- **산술 확장**: `$(( ))`와 `let` 비교, 정수만, 64bit, 진법 표기
- **브레이스 확장**: `{a,b}`, `{1..5}`, `foo{bar,baz}{1..3}` → globs와 순서 차이

## 확장 순서와 단어 분리
- 확장 후 공백이 생기면 단어 분리가 일어나므로, 값이 공백을 포함할 가능성이 있으면 항상 `"..."`로 보호.
- `set -f`(noglob)으로 글로브 비활성화 가능. 단, 스크립트 시작부에서만 사용.
- IFS는 단어 분리와 `read` 동작에 영향. 시험에서 자주 묻는 기본값: 공백·탭·개행.

## 인용 패턴
- **"$var"**: 거의 모든 경우의 정답. 내부 `"`는 `\"`, `$`/````는 그대로 동작.
- **'$var'**: 확장 없는 리터럴. 히어독에서 `<<'EOF'`와 함께 사용하면 안전하게 원문 유지.
- **$'string'**: C-style 이스케이프 허용(`\n`, `\t`, `\xFF`). Bash 확장.
- **$"string"**: 지역화(locale) 번역 문자열. 시험에서는 거의 사용 안 함.

## 명령 치환
- `$(cmd)` 선호. 중첩과 가독성이 좋고, 인용 규칙이 명확.
- 백틱은 `\`를 중첩마다 2배로 이스케이프해야 하므로 피함.
- 줄바꿈 포함 가능. 결과 끝의 개행 한 줄은 자동 제거.

## 파라미터 확장 디폴트/필수
- `${var:-word}`: var unset/null → word 사용(읽기)
- `${var:=word}`: var unset/null → word 대입 후 사용(쓰기)
- `${var:?msg}`: var unset/null → 오류 출력하고 비정상 종료. 필수 인자 검사에 사용
- `${var:+word}`: var set/non-null → word 사용, 아니면 빈 문자열
- `null`과 `unset`을 구분하려면 `${var+set}` 패턴을 활용.

## 부분 문자열·길이
- `${#var}`: 문자열 길이. 배열 길이와는 다름(`"${#array[@]}"`).
- `${var:offset:length}`: 부분 문자열. 음수 offset은 뒤에서부터(Bash 4.2+).
- `${var/pat/repl}`: 첫 매치 치환, `//`는 전체 치환, `/#/##`는 접두사 패턴 제거, `%/%%`는 접미사 제거.

## 산술 확장
- `$(( expr ))` 결과는 문자열로 확장. 정수만, 부동소수 불가.
- 표현식 내에서는 변수에 `$` 생략 가능: `$((a + b*3))`
- 0으로 시작하면 8진수, `0x` 16진수, `10#value`로 진법 지정 가능.
- 오버플로는 C 정수처럼 wrap-around. 시험에서 32/64bit 차이를 언급하기도 함.

## 브레이스 확장
- **파싱 전 확장**: 파일이 없어도 그대로 펼침 → 의도치 않은 인자 폭발 주의
- 예시: `mkdir -p project/{bin,src,tests}` → 한 번에 디렉터리 생성
- 숫자: `{01..05}`는 zero-padding 유지, 역순 `{5..1}`, step `{1..10..2}`
- 글로브와 다름: `{a,b}`는 존재와 무관하게 확장, `*`는 매칭되는 파일 없으면 그대로 남거나 nullglob

## 경로 확장(globbing)
- `*`, `?`, `[abc]`, `[!abc]`, `[^abc]` 기본. `extglob` 옵션으로 `@(p1|p2)`, `!(pat)`, `?(pat)` 등 사용.
- `shopt -s nullglob` → 매칭 없으면 빈 리스트, `failglob` → 오류 발생, `dotglob` → 숨김파일 포함
- `globstar`(`**`)는 `shopt -s globstar` 후 디렉터리 재귀 매칭

## 틸드 확장
- `~` → HOME, `~user` → 해당 사용자의 홈, `~+` → PWD, `~-` → 이전 디렉터리(OLDPWD)
- 인용하면 확장되지 않음: `"~"`는 그대로 문자

## 예제: 안전한 명령 조립
```bash
log_dir=${LOG_DIR:-/var/log/myapp}
file="$log_dir/$(date +%Y-%m-%d).log"
mkdir -p "$log_dir"
if [[ -n ${DEBUG:-} ]]; then set -x; fi
some_cmd --output "$file" --filter "${pattern:-.*}"  # 단어 분리, 글로브 예방
```

## 5분 실습
1. `${var:-x}`와 `${var:=x}` 차이를 unset/null/set 케이스로 확인
2. `set -f`로 글로브 비활성화 후 `echo *` 결과 비교
3. `printf '%s\n' {1..3}{a,b}`와 `printf '%s\n' *{a,b}`의 차이를 관찰
4. `foo="a b*c"; printf '%s\n' $foo` vs `"$foo"`의 단어 분리 차이 비교

## 체크리스트
- [ ] 변수/명령 치환 결과는 기본적으로 더블 쿼트로 보호
- [ ] 기본 IFS를 바꿨다면 복원하거나 지역화(`local IFS=$'\n'`)
- [ ] 브레이스 확장은 파일 존재와 무관하므로 인자 폭발 가능성 검토
- [ ] 글로브 동작(nullglob/failglob/dotglob)과 `set -f` 사용 여부를 명시
- [ ] `${var:?message}`로 필수 인자 검증, 에러 메시지는 stderr로 출력

## 심화: 확장 충돌을 피하는 법
- **확장 순서 착각**: `echo $foo*`는 `$foo` 확장 후 글로브 동작. 의도치 않은 매칭 방지 위해 `echo "$foo"*`처럼 분리.
- **IFS 오염**: `IFS=:`로 바꾼 뒤 복원하지 않으면 이후 `"$@"` 확장 결과가 달라짐. 함수 내부에서 `local IFS`로 제한.
- **명령 치환 트레일링 개행**: `$(cmd)`는 마지막 개행 제거. 개행 보존이 필요하면 `mapfile -t arr < <(cmd)` 사용.
- **정규식 구분**: `[[ $s =~ regex ]]`에서 regex는 인용하면 리터럴. 변수에 담긴 정규식을 쓰려면 `[[ $s =~ $re ]]`(단어 분리/글로브 위험은 없음).
- **brace vs glob**: `foo{bar,baz}`는 파일 없어도 두 인자로 분리, `foo*`는 파일 없으면 그대로 또는 빈(옵션에 따라). 스크립트에서 brace 사용 시 의도적으로 인자 늘어난다는 점을 문서화.

## 실전 패턴 모음
- **안전한 기본값**: `: "${REQUIRED:?environment REQ is missing}"`처럼 `:`(no-op)으로 체크 후 종료.
- **동적 명령 생성**: 배열에 옵션을 쌓은 뒤 `cmd "${args[@]}"`로 실행하면 공백/특수문자 안전.
- **여러 확장 조합**: `out="${base%.*}-$(date +%Y%m%d).${base##*.}"` → 접두/접미 제거와 명령 치환 조합 예시.
- **글로브 설정 제어**: `shopt -s nullglob dotglob` 후 `files=("/tmp/myapp"/*.log)`; 종료 시 `shopt -u nullglob dotglob`.

## 연습 문제
1. `files=$(ls *.txt)`가 왜 위험한지 설명하고, 안전한 대안 코드를 작성하라.  
2. `${var:-default}`와 `${var:+alt}`의 차이를 표로 정리하고, unset/null/set 세 경우의 결과를 적으라.  
3. `[[ $path == *.txt ]]`와 `[ "$path" = *.txt ]`의 동작 차이를 설명하라.  
4. `echo {01..05..2}`의 결과를 예측하고, 숫자 패딩 규칙을 설명하라.  
5. `foo=$(printf 'a\nb\n')` 이후 `${foo%%$'\n'*}`와 `${foo%$'\n'*}`의 차이를 설명하라.
