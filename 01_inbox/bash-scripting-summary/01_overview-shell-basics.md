# 01. Bash와 쉘 기본 개념

## 시험 포인트
- 로그인/비로그인, 인터랙티브/비인터랙티브 쉘 로딩 순서 구분
- `#!/bin/bash` 셔뱅 의미, PATH 탐색 순서, 해시 테이블
- 명령 형태: `명령 인자` vs `키워드` vs `빌트인`, 종료 상태 규칙(0=성공)
- 스크립트 실행 권한, 실행비트 없이 `bash script.sh`로 실행하는 방법
- POSIX sh와 Bash 확장 차이: 배열, `[](../.md)`, brace expansion 등

## 쉘의 역할
- **명령 인터프리터**: 사용자가 입력한 문자열을 파싱→확장→실행
- **스크립트 실행기**: 파일에 적힌 명령을 순차 실행하며, 별도의 프로세스 없이 빌트인 실행
- **환경 조율**: 변수, 함수, alias, ulimit, 셸 옵션(`set`) 관리
- **잡 제어**: 포그라운드/백그라운드, 시그널 전달

## 쉘 종류와 선택
- **POSIX sh**: 최소 공통분모, /bin/sh는 배포판마다 dash/bash/busybox로 다를 수 있음
- **Bash**: 대중적 확장 풍부, 스크립트 시험에서도 기본 가정인 경우 많음
- **Zsh/Ksh/Fish**: 상호 호환성 주의. 시험에서는 Bash 또는 POSIX sh에 집중
- **어떤 셸을 쓸까?**: 시스템 스크립트는 보수적(`/bin/sh`), 팀/개인 자동화는 Bash 4/5 권장

## 실행 흐름 및 로딩 파일
- **인터랙티브 로그인**: `/etc/profile` → `~/.bash_profile` → `~/.bashrc`(보통 here) → `~/.bash_logout`
- **인터랙티브 비로그인**: `~/.bashrc`만 읽음(터미널 새 창, tmux pane 등)
- **비인터랙티브**: `$BASH_ENV`가 지정된 경우 그 파일 실행. crontab/systemd는 기본적으로 로그인 셸이 아님
- **실전 팁**: 환경 변수 설정은 `~/.bashrc`, PATH 등은 `~/.profile`/`~/.bash_profile`에 둔다.

## 셔뱅(shebang)
```bash
#!/usr/bin/env bash   # 환경에 설정된 bash 탐색, 이식성 ↑
#!/bin/bash           # 절대경로 명시, 빠름
```
- 첫 줄로 인터프리터를 지정. 실행 비트(`chmod +x`) 필요.
- 파일을 `bash file.sh`로 실행하면 셔뱅은 무시됨(지정된 bash 사용).
- shebang 없고 실행 비트만 있으면 커널이 `sh`로 실행 시도 → dash 등으로 실행될 수 있어 문법 호환 필요.

## 명령 해석 단계 (간략)
1. **토큰화**: 공백 기준 분할, 인용/이스케이프 처리
2. **확장**: 브레이스 확장 → 틸드 → 파라미터 → 명령 치환 → 산술 → 경로(glob) → 단어 분리
3. **리디렉션 적용**: `<`, `>`, `>>`, `2>`, `&>` 등
4. **명령 실행**: 빌트인 우선 → 함수 → PATH 탐색 순으로 실행 파일 결정
5. **종료 상태**: 0 성공, 1 일반 실패, 126 실행 불가, 127 명령 없음, 시그널+128

## PATH와 해시
- 실행 파일 탐색 시 PATH를 왼쪽부터 검색, 찾으면 경로 해시 테이블에 저장해 후속 호출 가속
- `hash -r`로 해시 초기화, PATH 변경 후 실행 파일이 바뀌지 않을 때 점검
- `command -v name` 또는 `type -a name`으로 실제 실행 대상 확인

## 빌트인 vs 외부 명령
- **빌트인**: `cd`, `echo`, `read`, `set`, `umask`, `ulimit` 등. 서브프로세스 없이 실행되어 빠름
- **키워드**: `if`, `for`, `case`, `while`, `function`, `time`, `[](../.md)` 등 문법 요소
- **외부 명령**: PATH를 통해 찾는 실행 파일. 파이프라인에서 새 프로세스 생성
- 실전: 파이프라인에서 `echo | grep` 대신 `[](../.md)` 사용 시 포크/프로세스 감소 → 속도 ↑

## 인용과 이스케이프 기본
- **싱글 쿼트 ' '**: 리터럴, 확장 전혀 없음
- **더블 쿼트 " "**: 변수/명령 치환/백슬래시 일부 해석. 단어 분리와 글로브 방지
- **백슬래시\\**: 한 글자 이스케이프. 줄바꿈 직전의 `\`는 명령 지속(line continuation)
- **습관**: 변수는 거의 항상 더블 쿼트로 감싸기. 예: `"$var"` `"${array[@]}"`

## 스크립트 실행 권한
- `chmod +x script.sh` 후 `./script.sh` 실행(디렉터리에 실행 비트 필요)
- 실행 비트 없이 `bash script.sh`로도 실행 가능(현재 셸의 bash 사용)
- 안전성: 실행 권한과 쓰기 권한을 분리(옵션 스크립트는 750/700 권장)

## Bash vs POSIX sh 호환성 표
- Bash 전용: 배열/연관배열, `[](../.md)`, `(( ))` 산술, `==` glob 매칭, `**` globstar, `shopt`, 히어스트링 `<<<`
- POSIX sh: `$(command)` 치환, `$(( ))` 산술, `case`, `for`, `while`, `set -e`, `${var%pattern}` 등 기본 확장
- 시험에서 호환성을 물을 때는, **배열/연관배열/`[](../.md)`/프로세스 서브스티튜션** 사용 여부를 구분해 설명

## exit 코드와 오류 처리 관례
- **0**: 성공. test 성공도 0.
- **1**: 일반 실패. `grep`에서 미매칭도 1.
- **2**: 쉘 내장 misuse, `bash`에서 옵션 오류.
- **126**: 파일 접근 가능하지만 실행 불가(권한 문제 등)
- **127**: 명령 없음
- **128+N**: 시그널 N으로 종료(예: 130=Ctrl+C)
- `set -e` 사용 시 파이프라인, `&&/||`, `if`, `while` 조건의 실패 동작 예외를 암기

## 라인 지속과 명령 구분
- **라인 지속**: `\`로 끝내거나 더블/싱글 쿼트, `<<EOF` 히어독, `(`서브셸 등 미완성 구문 유지
- **명령 구분자**: `;`, `&`(백그라운드), `&&`(앞 성공 시), `||`(앞 실패 시), `|`(파이프)
- `cmd1 && cmd2 || cmd3`는 `cmd1` 성공 시 `cmd2` 실행 후 실패하면 `cmd3` 실행될 수 있음. 확실한 분기엔 `if` 사용.

## 실습: 5분 체크
1. 현재 셸이 로그인/비로그인인지 `shopt login_shell`로 확인
2. `type -a cd`와 `type -a ls` 결과 비교(빌트인 vs 외부)
3. PATH에 없는 임시 스크립트를 `./tmp.sh`로 실행한 뒤 PATH 수정 후 `hash -r` 필요성을 확인
4. `set -o posix`를 켜고 배열 사용 시 오류 메시지 관찰

## 체크리스트
- [ ] 셔뱅은 `/usr/bin/env bash` 사용, 파일 인코딩은 UTF-8 가정
- [ ] 변수/경로는 반드시 더블 쿼트. 글로브 필요 시 별도 처리
- [ ] POSIX 호환 여부를 문서화(팀 스크립트에 주석으로 명시)
- [ ] `set -u`, `set -o pipefail` 등 안전 옵션을 켜기 전에 예외 흐름을 설계했는가?
- [ ] PATH 변경 후 `hash -r` 적용 및 `command -v`로 검증

## 심화 정리: 셸 상태 머신 관점
- **입력 루프**: 프롬프트 표시 → 한 줄 읽기 → 파싱 → 실행 → 종료 코드 저장(`$?`)
- **옵션 상태**: `set`/`shopt`로 토글되는 전역 플래그. 스크립트 중간에 변동하면 이후 모든 구문에 영향.
- **히스토리**: 기본적으로 `~/.bash_history`. 비인터랙티브에서는 off. `HISTCONTROL=ignoreboth`, `set -o history` 등 시험에서 옵션 이름을 기억해두면 가점.
- **컴맨드 캐싱**: 해시 테이블(`hash`). PATH 변경 직후에는 의도한 바이너리가 맞는지 확인 필요.
- **환경 전파**: `export`로만 자식에 전파. 함수/alias는 그대로 전달되지 않음(단, `export -f`는 Bash만 지원).

## 시험 자주 묻는 함정
- **`which` vs `type -a`**: `which`는 `alias`/쉘 함수까지는 모를 수 있음. 시험 답으로는 `command -v`나 `type -a` 선호.
- **`#!/bin/sh` 스크립트에서 Bash 문법 사용**: `[](../.md)`, 배열, `source` 등은 실패. 의도적이면 shebang을 Bash로.
- **`dash` 기본 시스템**: Debian/Ubuntu의 `/bin/sh`는 dash. `/etc/init.d` 스크립트는 POSIX 문법만 사용해야 함.
- **`echo` 구현 차이**: `echo -e`는 POSIX 미보장. 시험에서 이식성을 묻는다면 `printf` 사용이 정답.
- **CRLF 파일**: `bash`는 CR이 남으면 `^M` 보임. `dos2unix` 또는 `tr -d '\\r'` 언급.

## 실전 시나리오 예시
1) **지원 환경 파악**  
서버에 로그인 → `echo $SHELL`, `/etc/shells` 확인 → `bash --version`으로 4.x/5.x 여부 파악 → `/bin/sh`가 무엇인지 `ls -l /bin/sh`로 확인.

2) **스크립트 실행 방식 결정**  
운영 작업: `/bin/sh`로 작성해도 되는지? 배열/연관배열 필요하면 `#!/usr/bin/env bash`. 실행 권한 부여 후 `chmod +x`.

3) **최초 실행 검증**  
`set -Eeuo pipefail` 설정 → 필수 인자 검증 → `command -v`로 외부 의존성 확인 → `LOG` 디렉터리 생성 → 메인 로직 호출.

4) **배포/배시즘(확장) 고지**  
파일 상단 주석: `# Requires bash 4.0+ (associative arrays)`처럼 명시. 시험 답안에서도 버전 요구사항을 언급하면 가산점.

## 연습 문제(서술형)
1. 로그인 셸과 비로그인 셸이 읽는 파일을 순서대로 적고, macOS/iTerm2에서 새 탭을 열었을 때 어떤 파일이 실행되는지 설명하라.  
2. `which` 명령이 신뢰할 수 없는 이유를 쓰고, 더 나은 대안을 제시하라.  
3. `/usr/local/bin`보다 `/opt/custom/bin`을 우선 사용해야 한다. PATH를 안전하게 재정의하는 코드와, 해시 테이블을 비우는 명령을 적으라.  
4. `set -u`가 켜진 상태에서 존재하지 않는 변수에 접근하면 어떻게 되는지, 이를 회피하는 안전한 파라미터 확장 패턴을 예시와 함께 적으라.  
5. `/bin/sh`가 dash인 시스템에서 `[-f file](../../-f file.md)` 구문을 실행하면 어떤 일이 일어나는가? 대안을 적으라.
