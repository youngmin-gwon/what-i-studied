# 13. 모의고사 Q&A 세트

> 시험 직전 빠르게 풀어보는 단답/서술/시나리오 문제 모음. 각 문항 뒤에 간략 해설을 포함했습니다.

## Part A. 단답 문제 (기본기)
1. **`set -e`가 무시되는 세 곳**을 적으시오.  
   **A:** `if/while` 조건식, `! cmd`, `cmd1 && cmd2 || cmd3`의 &&/|| 오른쪽, 파이프라인(마지막 명령 제외). 보완책: `set -o pipefail`, 명시적 종료 처리.
2. **Bash에서 배열 길이**를 구하는 표현은?  
   **A:** `${#arr[@]}`. 문자열 길이는 `${#str}`.
3. **`[[ $a == $b ]]`와 `[ "$a" = "$b" ]`의 차이**는?  
   **A:** `[[ ]]`는 글로브 확장/단어분리 없음, `==`는 패턴 매칭. test는 단순 문자열 비교이며 인용 필수.
4. **명령 치환 결과의 마지막 개행 처리**는?  
   **A:** `$(cmd)`는 마지막 개행 1개 제거. 여러 개행이 있으면 하나만 제거.
5. **`$@`와 `$*`의 차이**는?  
   **A:** 인용 시 `"$@"`는 각 인자 분리, `"$*"`는 IFS 첫 글자로 join. 미인용 시 둘 다 단어 분리.
6. **히어독에서 변수 확장을 막는 방법**은?  
   **A:** 구분자를 인용: `<<'EOF'`. 개행 전 탭 무시하려면 `<<-EOF`.
7. **`trap 'cleanup' EXIT`의 호출 시점**을 설명하라.  
   **A:** 스크립트 종료 시(정상/비정상 모두), `exit`, 마지막 명령 반환, ERR 트랩 후 등. 단, `exec`로 대체된 프로세스는 제외.
8. **`command -v foo`와 `which foo` 차이**는?  
   **A:** `command -v`/`type`은 쉘 내장/함수/alias까지 확인. `which`는 PATH 실행파일만(환경 따라 다름) → 시험에서는 `command -v` 추천.
9. **`hash -r`의 역할**은?  
   **A:** 명령 경로 해시 테이블 초기화. PATH 변경 후 잘못된 바이너리 호출을 방지.
10. **`set -u` 상태에서 안전하게 기본값을 주는 패턴**은?  
    **A:** `${var:-default}` 또는 `${var:=default}`. 단순 `$var` 접근은 오류.

## Part B. 파일/입력 관련
11. **NUL-종단 find/xargs 패턴**을 쓰시오.  
    **A:** `find . -type f -print0 | while IFS= read -r -d '' f; do ...; done` 또는 `xargs -0 -n1 cmd`.
12. **`cat file | while read`가 변수에 반영되지 않는 이유**는?  
    **A:** 파이프 오른쪽 `while`이 서브셸에서 실행되어 부모 변수 변경 미반영. `< file` 리디렉션 사용.
13. **파일 테스트 연산자 `-nt`, `-ot`, `-ef`의 의미**를 설명하라.  
    **A:** `-nt` 새로움(newer), `-ot` 오래됨(older), `-ef` 동일 inode(하드링크/심링크 판별).
14. **`read -r`에서 `-r` 옵션을 빼면 발생하는 문제**는?  
    **A:** 역슬래시가 이스케이프 처리되어 경로/문자열이 손상될 수 있음.
15. **히스토리 확장을 끄는 방법**은?  
    **A:** 스크립트에서는 기본 off. 인터랙티브에서 `set +H` 또는 `set -o histexpand` 비활성화.

## Part C. 시나리오 문제
16. **문제**: `logs/*.log` 파일을 하루보다 오래된 것만 gzip으로 압축하고, 7일보다 오래된 gz는 삭제하라.  
    **해설**: `find logs -name '*.log' -mtime +0 -print0 | xargs -0 -n1 gzip`; `find logs -name '*.gz' -mtime +7 -delete`. pipefail 필요 여부 검토.
17. **문제**: `set -e`가 켜진 스크립트에서 `local data=$(curl -fsS URL)`가 실패해도 즉시 종료되지 않는 이유와 수정법?  
    **해설**: 명령 치환은 함수의 단일 명령으로 간주되어 실패 시 exit. 실제론 즉시 종료 → 이를 피하려면 `if ! data=$(curl ...); then return 1; fi`로 감싼다.
18. **문제**: `[[ $path =~ ^/home/.+ ]]` 정규식 매칭이 실패한다. `$path`에 `/`가 포함되어서일까?  
    **해설**: 인용하면 리터럴로 처리되어 정규식 동작. `[[ $path =~ ^/home/.+ ]]`에서 `$path`를 인용하지 않는다. 또는 정규식에 `^/home/.+` 올바른지 확인.
19. **문제**: cron에서 실행되는 스크립트가 `python`을 못 찾는다.  
    **해설**: PATH 짧음(`/usr/bin:/bin`). crontab 상단에 `PATH=/usr/local/bin:/usr/bin:/bin` 추가하거나 절대경로 사용.
20. **문제**: `sed -i 's/foo/bar/' file`이 macOS에서 실패한다.  
    **해설**: BSD sed는 인플레이스 옵션에 백업 확장자 필요. `sed -i '' 's/foo/bar/' file` 또는 GNU sed 사용.
21. **문제**: `readlink -f`가 macOS에서 없다.  
    **해설**: `python - <<'PY'`로 realpath 대체, 또는 coreutils `greadlink` 설치.
22. **문제**: `timeout`이 없는 환경에서 명령을 5초 뒤 강제 종료하고 싶다.  
    **해설**: `perl -e 'alarm 5; exec @ARGV' cmd` 또는 `python - <<'PY'` 대안.
23. **문제**: `grep -q pattern file || echo not found`를 `set -e` 상태에서 실행하면 어떻게 되는가?  
    **해설**: `-q` 실패(패턴 미매치) 시 종료 코드 1 → `||` 오른쪽 실행되고, `set -e`는 `||`의 오른쪽이 있으므로 종료 안 함.
24. **문제**: `arr=($(cat file))`로 배열을 만들 때 생길 수 있는 문제?  
    **해설**: 단어 분리/글로브로 요소가 잘림. `mapfile -t arr < file` 또는 NUL-종단 사용.
25. **문제**: `[[ -s $file ]]`와 `[ -s "$file" ]`의 차이는?  
    **해설**: 거의 없음. 단, `[[ ]]`는 인용 필요 없고, 글로브/단어분리 억제.

## Part D. 명령/옵션 매칭
- `grep -nE 'ERROR|WARN'` → **줄 번호 포함, 확장 정규식**
- `sed -n '1,10p'` → **출력 억제(-n) 후 1~10행 출력**
- `awk -F, 'NR>1 {sum+=$3} END{print sum}'` → **CSV 3열 합계(헤더 건너뜀)**
- `cut -d: -f1,7 /etc/passwd` → **계정명과 쉘 추출**
- `tr -d '\r'` → **CR 제거 (Windows 개행 정리)**
- `sort -u` → **중복 제거(정렬 필요)**
- `uniq -c` → **연속 중복 카운트**
- `join -1 1 -2 1` → **정렬된 두 파일을 첫 필드 기준 병합**

## Part E. 장문 서술 예시
### 1) `set -Eeuo pipefail`을 안전하게 사용하는 절차
1. 스크립트 최상단에서 설정하고, 왜 필요한지 주석 달기.  
2. 필수 인자/환경을 `${var:?msg}`로 검사.  
3. 파이프라인 실패 감지를 위해 `set -o pipefail`; 필요한 곳에 `|| true` 주석 명시.  
4. `trap 'cleanup' EXIT`로 임시 리소스 정리. ERR trap은 과도하면 루프를 깨트릴 수 있으므로 필요할 때만.  
5. `local var`에 명령 치환 결과를 담을 때 `if ! var=$(cmd); then ...; fi` 패턴 사용.  
6. 외부 명령은 실패 시 메시지와 종료 코드 변환을 명확히(`exit 2` 등).  
7. 테스트 환경(cron/CI)에서 한 번 돌려보고 예상치 못한 조기 종료가 없는지 확인.

### 2) POSIX sh와 Bash 선택 가이드
- 시스템 초기화/부팅 스크립트, cron 등 최소 의존성이 필요한 경우 POSIX sh 사용. 배열/연관배열 필요하면 awk/perl로 처리.  
- 팀 내 자동화, 복잡한 문자열 처리, 연관배열이 필요한 경우 Bash 선택. `#!/usr/bin/env bash`로 버전 의존성을 적고, Bash 4+ 기능 사용 시 주석.  
- POSIX 호환을 유지해야 하는 코드에서는 `set -o posix`로 테스트하고, `command -v`/`printf`/`$( )`만 사용.

### 3) 안전한 파일 처리 기본형
```bash
while IFS= read -r -d '' path; do
  [[ -f $path ]] || continue
  printf '%s\n' "$path"
done < <(find /data -type f -name '*.csv' -print0)
```
- 공백/개행/비ASCII 파일명에도 안전. `find`와 `xargs` 조합으로 대체 가능.

## Part F. 미니 모의고사 (15분)
- **Q1**: 현재 셸이 로그인/인터랙티브인지 확인하는 명령과 그 결과 해석을 쓰시오.
- **Q2**: `PATH`에 `/usr/local/bin`을 중복 없이 맨 앞에 추가하는 함수를 작성하시오.
- **Q3**: `cmd1 | cmd2 | cmd3`에서 cmd1이 실패했을 때도 스크립트를 실패시키는 설정과 검증 코드를 작성하시오.
- **Q4**: Bash 배열을 사용해 옵션을 쌓은 뒤 명령을 실행하는 예를 드시오.
- **Q5**: cron에서 실행할 때와 인터랙티브 셸에서 실행할 때 출력/환경이 어떻게 다른지 두 가지 이상 설명하시오.
- **Q6**: `trap`을 사용해 임시 디렉터리와 백그라운드 PID를 정리하는 코드 스니펫을 작성하시오.
- **Q7**: `grep -F`와 `grep -E`의 차이와 사용 시나리오를 비교하시오.
- **Q8**: `mktemp` 실패 시 어떻게 처리해야 하는지, 실패 가능 이유를 두 가지 쓰시오.
- **Q9**: `read -r line` 루프에서 마지막 줄이 개행 없이 끝날 때 누락되지 않도록 하는 패턴을 쓰시오.
- **Q10**: Bash 3.x 환경에서 연관배열이 필요할 때 대체 방법을 설명하시오.

**풀이 가이드**: 각 문항에 2~4줄로 핵심만 적고, 가능하면 코드 예시 1줄을 포함하라. 시간 관리: 15분 내에 Q1~Q6 해결, 남은 시간에 Q7~Q10.

## Part G. 복합 시나리오 (서술형 해설 포함)
### G1. 로그 집계 및 알림
- **문제**: `app.log`에서 최근 10분간 ERROR 비율이 5% 이상이면 슬랙 웹훅으로 알림을 보내라. 로그는 `YYYY-MM-DD hh:mm:ss LEVEL msg` 형식.
- **풀이 포인트**: `cut -d' ' -f1,2`로 시간 추출 → `date -d '-10 min'`(macOS는 `-v -10M`)와 비교 → `grep 'ERROR'` 개수/전체 개수 계산 → 백분율 산출 → `curl -X POST -H 'Content-Type: application/json' -d '{"text":"..."}'` 호출. 시간 계산에서 GNU/BSD 차이를 언급하면 가점.

### G2. 안전한 배포 스크립트 골격
- **문제**: `deploy.sh`에서 빌드, 아티팩트 업로드, 서비스 재시작을 수행한다. 중간 실패 시 롤백하고, 로그를 남겨야 한다. 의존 명령: `git`, `tar`, `scp`, `ssh`.
- **풀이 포인트**: `set -Eeuo pipefail`, `trap 'rollback' ERR EXIT`, `command -v` 체크, `mktemp -d`로 임시 공간, `tar czf`로 패키징, `scp` 업로드, `ssh 'systemctl restart app'`. 롤백은 업로드한 파일 삭제/서비스 이전 상태 복구 등 언급.

### G3. POSIX 호환 스크립트 변환
- **문제**: Bash 배열/`[[ ]]`를 사용한 스크립트를 `/bin/sh` 호환으로 고쳐라.
- **풀이 포인트**: 배열 대신 줄 단위 파일 또는 스페이스 구분 문자열 사용, `set --`/`for`로 순회. `[[ ... ]]` → `[ ... ]` + 인용. `function` 키워드 제거, `$(())`는 POSIX 지원되나 `(( ))`는 사용 자제. process substitution 제거 후 명명 파이프/임시 파일로 대체.

### G4. 권한/보안 검토 질문 예시
- **문제**: 루트로 실행되는 백업 스크립트가 있다. 보안 측면에서 점검할 항목을 서술하라.
- **풀이 포인트**: 입력 검증(경로 화이트리스트), `umask 077`, 임시 파일 `mktemp`, PATH 제한, 외부 명령 절대경로 사용, 로그에 비밀번호 미출력, `set -euo pipefail`과 명시적 에러 처리, sudo 권한 최소화.

## Part H. 짧은 OX/선택 문제
- `[[ -v VAR ]]`는 변수가 설정되었는지 확인한다. (O)
- `echo`는 항상 `-e`를 지원한다. (X, 이식성 없음 → `printf`)
- `readarray`/`mapfile`는 Bash 4+ 기능이다. (O)
- `PIPESTATUS`는 POSIX sh에서도 제공된다. (X, Bash 배열)
- `set -o nounset`는 unset 변수를 읽을 때 항상 종료시킨다. `${var:-}`처럼 디폴트 사용 시에는 종료하지 않는다. (O)
- `trap '...' ERR`는 `set -E` 없이도 함수 안에서 작동한다. (X, 기본은 함수 내부 전달 안 됨)
- `[[ foo > bar ]]`는 문자열 사전순 비교다. (O)
- `printf '%q'`는 문자열을 재사용 가능한 셸 인자로 이스케이프한다. (O)
- `bash -n script.sh`는 모든 런타임 오류를 잡는다. (X, 문법만 검사)
- `set -C`(noclobber)는 `>file` 덮어쓰기를 막지만 `>|file`은 예외다. (O)

## Part I. 추가 연습 문제 (짧은 서술)
1. `shopt -s nullglob`와 `failglob`의 차이와 사용 시점을 설명하라.  
2. `mapfile -t arr < <(cmd)` 패턴이 `arr=($(cmd))`보다 안전한 이유를 두 가지 쓰라.  
3. `select` 구문을 이용해 메뉴를 만들 때, 사용자가 빈 입력을 넣으면 어떻게 처리할지 로직을 제시하라.  
4. `find . -type f -mtime -1 -print0 | xargs -0 sha256sum`의 동작을 단계별로 설명하라.  
5. `printf '%s\\0' \"${arr[@]}\" | xargs -0` 패턴이 언제 필요한지 사례를 들어라.  
6. `[[ $PS1 ]]` 체크가 의미하는 바를 설명하고, 비인터랙티브 셸에서 실행될 코드를 제한하는 방법을 적어라.  
7. `read -r -d '' var <<'EOF'` 패턴의 용도와 장점을 설명하라.  
8. `ssh host 'source ~/.bashrc; cmd'`가 예상대로 동작하지 않을 수 있는 이유와 해결책을 적어라.  
9. `awk`에서 `ORS`/`OFS`를 설정하는 위치와 영향에 대해 설명하라.  
10. `set -m`을 스크립트에서 켜면 어떤 일이 일어나는지, 켜야 하는 경우가 있는지 설명하라.
