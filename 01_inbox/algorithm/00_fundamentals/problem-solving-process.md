---
title: problem-solving-process
tags: [debugging, framework, fundamentals, logic, problem-solving]
aliases: [문제 접근법, 문제 해결 프로세스, 사고 프레임워크, 해결 전략]
date modified: 2025-12-19 18:49:47 +09:00
date created: 2025-12-18 12:00:00 +09:00
---

## Problem Solving Process: 문제를 이기는 방법론

알고리즘 문제를 푸는 것은 단순히 코드를 짜는 것이 아니라, **논리적인 설계**를 완성하는 과정입니다. 실무에서도 복잡한 요구사항을 기술적으로 분해할 때 동일한 프로세스가 적용됩니다.

>[!NOTE] **파이썬: 실행 가능한 의사코드 (Executable Pseudocode)**
>파이썬은 문법이 간결하여 알고리즘 구현 자체에 집중할 수 있게 해줍니다. 압도적인 생산성 덕분에 제한된 시간 내에 최적의 해답을 찾아야 하는 코딩 테스트에서 가장 강력한 무기가 됩니다.

### 💡 Why it matters (Context)

- **시간 단축**: 코드를 쓰다 말고 다시 엎는 시간을 줄여줍니다.
- **정확도**: 놓치기 쉬운 예외 상황(Edge Cases)을 설계 단계에서 잡아냅니다.
- **커뮤니케이션**: 면접관이나 동료에게 내 사고 과정을 구조적으로 설명할 수 있습니다.

---

## 🏗️ 4 단계 해결 프로세스 (Framework)

### 1 단계: 이해 (Understand)
ㅋ무작정 키보드에 손을 올리기 전에 다음 질문을 스스로에게 던집니다.

- **입력 데이터의 크기(N)** 는 얼마인가? (Big-O 결정의 결정적 힌트!)
- **제한 시간**과 **메모리 한도**는 얼마인가?
- **특이 사항**이 있는가? (중복 값, 음수, 빈 입력, 거대한 숫자 등)

### 2 단계: 계획 (Plan)

종이와 펜(또는 주석)을 사용하여 흐름을 설계합니다.

- **자료구조와 알고리즘**을 매칭합니다. (어떤 것을 쓸지 막막하다면 **[알고리즘 선택 결정 트리](algorithm-selection-decision-tree.md)** 를 참조하세요.)
- **의사 코드(Pseudo-code)** 를 작성하며 로직을 검증합니다.
- **예상 복잡도**를 계산하여 제한 시간 내에 들어오는지 확인합니다.

### 3 단계: 구현 (Implement)

설계한 로직을 코드로 옮깁니다.

- **가독성 있는 변수명**을 사용합니다.
- **모듈화**: 반복되는 로직은 함수로 뺍니다.
- **주석**: 복잡한 조건문 옆에는 이유를 짧게 적습니다.

### 4 단계: 검토 및 개선 (Review & Refine)

코드가 돌아간다고 끝난 것이 아닙니다.

- **예외 케이스 테스트**: 빈 배열, N=1, 모든 값이 같은 경우 등.
- **리팩토링**: 더 간결하고 효율적인 방법이 없는가?
- **회고**: 왜 이 방법으로 풀었는가? 다른 방법(Trade-off)은 무엇인가?

---

## 🏢 실무 사례

### 프로세스의 힘

- **장애 대응**: 서버 장애 시 `이해 -> 원인 분석 -> 계획 -> 복구` 의 프로세스를 따름으로써 더 큰 참사를 막습니다.
- **시스템 설계**: 새로운 기능을 추가할 때 예상 트래픽(N)을 분석하여 초기 아키텍처(알고리즘 선택)를 결정합니다.
- **코드 리뷰**: 동료의 코드가 엣지 케이스를 잘 처리했는지 체계적으로 점검합니다.

---

## 🚨 흔한 실수 (Common Mistakes)

1. **지문 대충 읽기** ❌
    - "오름차순" 정렬인데 내림차순으로 풀거나, "중복 없음" 조건을 놓쳐서 로직이 꼬이는 경우.
2. **N 의 크기 무시** ❌
    - N 이 100 만인데 $O(N^2)$ 으로 설계하는 경우. (Big-O 감각이 필요한 이유)
3. **엣지 케이스(Edge Case)를 나중에 생각함**
    - 로직을 다 짜고 나서야 "아, 0 일 때 에러 나네?"라며 코드를 땜질하다가 스파게티 코드가 됩니다.
4. **디버깅 없이 제출**
    - 간단한 `print` 나 디버거 활용 없이 감으로만 코드를 고치는 버릇.

---

## 🎮 실전 코딩테스트 전략 (Applied Strategy)

실제 시험장에서는 평소 실력보다 **운영 능력**이 합패를 가르는 경우가 많습니다.

### 1. 멘탈 관리 (Don't Get Stuck)

특정 문제의 잘못된 풀이나 지나치게 복잡한 구현에 시간을 다 써버리는 것이 가장 위험합니다. "이건 아니다" 싶을 때 과감히 손을 떼는 용기가 필요합니다.

### 2. 문제 미리 읽기 (Recommendation)

- **비추천**: 1 번 해결 → 2 번 접근 → 3 번 접근… (중간에 막히면 전체 일정 붕괴)
- **추천**: 초반 10~15 분 동안 **출제된 모든 문제를 훑어봅니다.** 가장 자신 있는 문제(보통은 앞번호)부터 공략하여 안정적인 점수를 먼저 확보하세요.

### 3. 예외 상황 방어 (Edge Case Defense)

HackerRank 나 프로그래머스 같은 플랫폼은 테스트 케이스의 일부를 숨깁니다. `null` 입력, 빈 리스트, `0` 나누기 등 예외 처리를 스스로 고민하지 않으면 80% 의 점수에서 멈추게 됩니다.

### 4. 커뮤니케이션 (Communication)

화이트보드나 온사이트 면접에서는 정답보다 **사고 과정**이 훨씬 중요합니다. 막히면 힌트를 요청하고, 내 논리적 흐름을 대화로 풀어내세요. 인터뷰어는 당신의 '정답 갯수'가 아니라 '함께 일하고 싶은 동료인가'를 평가합니다.

### 5. 응시 환경 적응

대부분의 기업 코딩테스트는 **프로그래머스** 와 유사한 함수형 인터페이스를 사용합니다.

- **표준 입력(`input()`)보다는 매개변수 활용**: `def solution(n, lost, reserve):` 와 같은 형태에 익숙해져야 합니다.
- **상대 평가**: 합격 컷은 항상 지원자들의 수준에 따라 변하므로, 한 문제라도 더 '정확하게' 푸는 확률을 높여야 합니다.

### 6. 백준(BOJ) 전용 Python 필승법

백준은 C++ 과 파이썬에 동일한 시간 제한을 주는 경우가 많아, 파이썬 유저에게 조금 까다로울 수 있습니다. 이때 다음 두 가지를 기억하세요.

1. **PyPy3 로 제출하기**: 일반 Python3 보다 실행 속도가 훨씬 빠릅니다. (JIT 컴파일러 활용) 로직이 맞는데 시간 초과가 난다면 PyPy3 로 다시 제출해 보세요.
2. **빠른 입출력 사용**: `input()` 대신 `sys.stdin.readline().rstrip()` 을 사용하세요. 입력 데이터가 많을 때(10 만 줄 이상) 시간을 획기적으로 줄여줍니다.

```python
import sys
input = lambda: sys.stdin.readline().rstrip() # 맨 위에 추가하면 input()을 그대로 쓸 수 있음
```

---

## 🧪 실전 팁: 제약 조건별 알고리즘 선택 가이드

알고리즘 문제를 풀 때 가장 중요한 감각은 **"N 의 크기를 보고 내 코드의 운명을 예견하는 것"** 입니다.

### ⏱️ $10^8$ 법칙 (The Rule of $10^8$)

현대 컴퓨터(또는 온라인 저지 환경)는 보통 **1 초에 약 1 억($10^8$) 번의 연산**을 수행할 수 있다고 가정합니다. 이를 기준으로 내 로직의 전체 연산 횟수를 추정해야 합니다.

| 입력 크기 (N)         | 허용 시간 복잡도     | 이유 (수학적 근거)                                            | 추천 알고리즘                  |
| :---------------- | :------------ | :----------------------------------------------------- | :----------------------- |
| **$N \le 10$**    | $O(N!)$       | $10! \approx 362$ 만. $11!$ 부터는 위험 ($10^8$ 초과)          | 순열 생성, 완전 탐색             |
| **$N \le 25$**    | $O(2^N)$      | $2^{20} \approx 104$ 만. $2^{25} \approx 3,355$ 만.      | 백트래킹, **[비트마스크 DP](../02_algorithms/dynamic-programming.md#Bitmask DP)** |
| **$N \le 500$**   | $O(N^3)$      | $500^3 = 1.25 \times 10^8$. 1 초 한도에 근접                 | 플로이드 - 와샬, 3 중 루프        |
| **$N \le 5,000$** | $O(N^2)$      | $5,000^2 = 2.5 \times 10^7$. $10^4$ 가 넘어가면 조심          | 2 중 루프 브루트포스, **[기본 DP](../02_algorithms/dynamic-programming.md)** |
| **$N \le 10^5$**  | $O(N \log N)$ | $10^5 \times \log_2(10^5) \approx 1.7 \times 10^6$. 안전 | **정렬**, **이진 탐색**, **힙** |
| **$N \le 10^7$**  | $O(N)$        | $10^7 = 10 \text{ million}$. 0.1 초 내외로 처리 가능           | 슬라이딩 윈도우, 스택, 그리디        |
| **$N > 10^7$**    | $O(\log N)$   | 입력을 다 읽기조차 힘든 수준. 쿼리 최적화 필요                            | **이진 탐색**, 수학적 공식 활용     |

>[!IMPORTANT] **TLE (Time Limit Exceeded) 를 피하는 법**
>만약 문제의 $N$ 이 $10^5$ 인데 내 설계가 $O(N^2)$ 이라면, 필요한 연산은 $10^{10}$ 번입니다. 이는 약 **100 초**가 걸린다는 뜻이며, 1~2 초의 시간 제한이 있는 시스템에서는 반드시 **시간 초과(TLE)** 가 발생합니다. 이때는 반드시 $O(N \log N)$ 이하의 알고리즘으로 갈아타야 합니다.

---

## 📚 관련 문서

- [복잡도 분석](complexity-and-big-o.md) - 알고리즘 선택의 척도인 시간/공간 복잡도
- [알고리즘 선택 결정 트리](algorithm-selection-decision-tree.md) - 어떤 무기를 고를지 결정하는 논리 체계.
- [최적화 전략](../03_patterns/optimization.md) - 비효율적인 코드의 병목 현상 개선
- [부동 소수점과 정밀도](floating-point-guide.md) - 실수 연산 시 주의해야 할 정밀도 오차
- [분할 정복](../02_algorithms/divide-and-conquer.md) - 복잡한 문제를 작은 단위로 쪼개는 설계 기법
