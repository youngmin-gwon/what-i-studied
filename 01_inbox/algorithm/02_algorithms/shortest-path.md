---
title: shortest-path-algorithms
tags: [algorithm, graph, shortest-path, dijkstra, bellman-ford, floyd-warshall]
aliases: [ìµœë‹¨ ê²½ë¡œ, ë‹¤ìµìŠ¤íŠ¸ë¼, ë²¨ë§Œ-í¬ë“œ, í”Œë¡œì´ë“œ-ì™€ìƒ¬]
date modified: 2025-12-18 11:48:24 +09:00
date created: 2025-12-18 11:48:24 +09:00
---

## Shortest Path Algorithms: "ê°€ì¥ ë¹ ë¥¸ ê¸¸ ì°¾ê¸°"

**í•µì‹¬**: ê·¸ë˜í”„ì˜ ì§€ì (Node) ê°„ì„ ì—°ê²°í•˜ëŠ” ê°„ì„ (Edge)ì˜ ê°€ì¤‘ì¹˜ í•©ì´ **ìµœì†Œê°€ ë˜ëŠ” ê²½ë¡œ**ë¥¼ ì°¾ëŠ” ì•Œê³ ë¦¬ì¦˜ì…ë‹ˆë‹¤.

### ğŸ’¡ Why it matters (Context)

- **ë‚´ë¹„ê²Œì´ì…˜**: ì¶œë°œì§€ì—ì„œ ëª©ì ì§€ê¹Œì§€ ê°€ì¥ ë¹ ë¥¸ ë„ë¡œ ì°¾ê¸°
- **ë„¤íŠ¸ì›Œí¬ ë¼ìš°íŒ…**: ë°ì´í„° íŒ¨í‚·ì„ ê°€ì¥ ì ì€ ì‹œê°„ ë‚´ì— ëª©ì ì§€ ì„œë²„ë¡œ ì „ì†¡
- **SNS**: ë‘ ì‚¬ëŒ ì‚¬ì´ì˜ ìµœë‹¨ ì¸ë§¥ ê±°ë¦¬ ì¸¡ì •
- **ê²Œì„ AI**: ìºë¦­í„°ê°€ ì¥ì• ë¬¼ì„ í”¼í•´ ëª©í‘œë¬¼ë¡œ ì´ë™í•˜ëŠ” ìµœë‹¨ ê±°ë¦¬ ê³„ì‚°

---

### ğŸ¢ ì‹¤ë¬´ ì‚¬ë¡€

#### Shortest Path í™œìš©
- **Google Maps / T-Map**: ì‹¤ì‹œê°„ êµí†µ ìƒí™©ì„ ë°˜ì˜í•œ ê²½ë¡œ íƒìƒ‰ (Dijkstra ë³€í˜•)
- **Ride-sharing (Uber/Grab)**: ìŠ¹ê°ê³¼ ê°€ì¥ ê°€ê¹Œìš´ ê¸°ì‚¬ ë§¤ì¹­ ë° ìµœì  ìš´í–‰ ê²½ë¡œ ì‚°ì¶œ
- **Internet Routing Protocol (OSPF)**: ëŒ€ì—­í­ê³¼ í˜¼ì¡ë„ë¥¼ ê³ ë ¤í•œ ìµœì  ë°ì´í„° ì „ì†¡ ê²½ë¡œ ì„ ì •
- **Logistics (FedEx/DHL)**: í—ˆë¸Œ ê°„ ìµœì  ìš´ì†¡ë§ êµ¬ì¶•ì„ í†µí•œ ë¹„ìš© ì ˆê°
- **Blockchain**: P2P ë„¤íŠ¸ì›Œí¬ ë…¸ë“œ ê°„ ë©”ì‹œì§€ ì „íŒŒ ê²½ë¡œ ìµœì í™”
- **Game Development**: NPC ì˜ A* Pathfinding (Dijkstra ì˜ ë°œì „ëœ í˜•íƒœ)

---

## ğŸ§­ ì•Œê³ ë¦¬ì¦˜ ì„ íƒ ê°€ì´ë“œ

| ìƒí™© | ì¶”ì²œ ì•Œê³ ë¦¬ì¦˜ | ë³µì¡ë„ | íŠ¹ì´ì‚¬í•­ |
|:---|:---|:---|:---|
| **í•œ ì§€ì  â†’ ëª¨ë“  ì§€ì ** (ì–‘ìˆ˜ ê°€ì¤‘ì¹˜) | **Dijkstra** (ë‹¤ìµìŠ¤íŠ¸ë¼) | O(E log V) | ê°€ì¥ ë²”ìš©ì ì„ â­ |
| **í•œ ì§€ì  â†’ ëª¨ë“  ì§€ì ** (ìŒìˆ˜ ê°€ì¤‘ì¹˜ í¬í•¨) | **Bellman-Ford** (ë²¨ë§Œ-í¬ë“œ) | O(VE) | ìŒìˆ˜ ì‚¬ì´í´ íƒì§€ ê°€ëŠ¥ |
| **ëª¨ë“  ì§€ì  â†’ ëª¨ë“  ì§€ì ** | **Floyd-Warshall** (í”Œë¡œì´ë“œ-ì™€ìƒ¬) | O(VÂ³) | ë…¸ë“œ ìˆ˜ê°€ ì ì„ ë•Œ ìœ ë¦¬ |
| **ê°€ì¤‘ì¹˜ ì—†ëŠ” ê·¸ë˜í”„** | **BFS** | O(V+E) | ê°€ì¥ ë¹ ë¦„ |

---

## âš¡ Dijkstra's Algorithm (ë‹¤ìµìŠ¤íŠ¸ë¼)

**"ë§¤ ìˆœê°„ ê°€ì¥ ê°€ê¹Œìš´ ë…¸ë“œë¶€í„° í™•ì •í•˜ê¸°"**

ê·¸ë¦¬ë”” ë°©ì‹ì„ ì‚¬ìš©í•˜ë©°, í˜„ì¬ê¹Œì§€ ì•Œê³  ìˆëŠ” ê°€ì¥ ì§§ì€ ê²½ë¡œë¥¼ ê°€ì§„ ë…¸ë“œë¥¼ ì„ íƒí•´ ë‚˜ê°‘ë‹ˆë‹¤.

### ğŸ”§ êµ¬í˜„ (ìš°ì„ ìˆœìœ„ í í™œìš©)

```python
import heapq

def dijkstra(graph, start):
    # 1. ê±°ë¦¬ í…Œì´ë¸” ì´ˆê¸°í™” (ë¬´í•œëŒ€)
    distances = {node: float('inf') for node in graph}
    distances[start] = 0
    
    # 2. ìš°ì„ ìˆœìœ„ í ìƒì„± (ê±°ë¦¬, ë…¸ë“œ)
    priority_queue = [(0, start)]
    
    while priority_queue:
        current_dist, current_node = heapq.heappop(priority_queue)
        
        # 3. ì´ë¯¸ ì²˜ë¦¬ëœ ì  ìˆëŠ” ë…¸ë“œë¼ë©´ ë¬´ì‹œ
        if current_dist > distances[current_node]:
            continue
            
        # 4. ì´ì›ƒ ë…¸ë“œ í™•ì¸ ë° ê±°ë¦¬ ì—…ë°ì´íŠ¸
        for neighbor, weight in graph[current_node].items():
            distance = current_dist + weight
            
            # ë” ì§§ì€ ê²½ë¡œë¥¼ ì°¾ì•˜ë‹¤ë©´ ì—…ë°ì´íŠ¸
            if distance < distances[neighbor]:
                distances[neighbor] = distance
                heapq.heappush(priority_queue, (distance, neighbor))
                
    return distances

# graph = {'A': {'B': 1, 'C': 4}, 'B': {'C': 2, 'D': 5}, ...}
```

> [!IMPORTANT] **ë‹¤ìµìŠ¤íŠ¸ë¼ì˜ ì¡°ê±´**
> ê°„ì„ ì˜ ê°€ì¤‘ì¹˜ê°€ **ìŒìˆ˜**ì´ë©´ ì‚¬ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ê°€ì¤‘ì¹˜ê°€ ìŒìˆ˜ë©´ ì´ë¯¸ ë°©ë¬¸í•œ ë…¸ë“œì˜ ìµœë‹¨ ê±°ë¦¬ê°€ ë‚˜ì¤‘ì— ë°”ë€” ìˆ˜ ìˆê¸° ë•Œë¬¸ì…ë‹ˆë‹¤.

---

## ğŸ“‰ Bellman-Ford Algorithm (ë²¨ë§Œ-í¬ë“œ)

**"ëª¨ë“  ê°„ì„ ì„ V-1ë²ˆ ë°˜ë³µí•´ì„œ í™•ì¸í•˜ê¸°"**

ìŒìˆ˜ ê°€ì¤‘ì¹˜ê°€ ìˆì–´ë„ ì‘ë™í•˜ë©°, **ìŒìˆ˜ ì‚¬ì´í´**(ë¬´í•œíˆ ê±°ë¦¬ê°€ ì¤„ì–´ë“œëŠ” ìˆœí™˜) ì¡´ì¬ ì—¬ë¶€ë¥¼ íŒë³„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

### ğŸ”§ êµ¬í˜„

```python
def bellman_ford(graph, start, num_nodes):
    distances = [float('inf')] * num_nodes
    distances[start] = 0
    
    # ë…¸ë“œ ìˆ˜ - 1 ë²ˆ ë°˜ë³µ
    for i in range(num_nodes):
        for u in graph:
            for v, weight in graph[u]:
                if distances[u] != float('inf') and distances[u] + weight < distances[v]:
                    distances[v] = distances[u] + weight
                    # V ë²ˆì§¸ ë°˜ë³µì—ë„ ê°’ì´ ê°±ì‹ ë˜ë©´ ìŒìˆ˜ ì‚¬ì´í´ ì¡´ì¬
                    if i == num_nodes - 1:
                        return "Negative cycle detected"
                        
    return distances
```

---

## ğŸŒ Floyd-Warshall Algorithm (í”Œë¡œì´ë“œ-ì™€ìƒ¬)

**"ê±°ì³ê°€ëŠ” ë…¸ë“œë¥¼ ê¸°ì¤€ìœ¼ë¡œ í…Œì´ë¸” ì—…ë°ì´íŠ¸"**

ê±°ë¦¬ê°€ ê°±ì‹ ë  ë•Œë§ˆë‹¤ `D[i][j] = min(D[i][j], D[i][k] + D[k][j])` ê³µì‹ì„ ì‚¬ìš©í•©ë‹ˆë‹¤.

### ğŸ”§ êµ¬í˜„

```python
def floyd_warshall(matrix, n):
    # matrixëŠ” ì¸ì ‘ í–‰ë ¬
    dist = [row[:] for row in matrix]
    
    # k = ê±°ì³ê°€ëŠ” ë…¸ë“œ
    for k in range(n):
        # i = ì¶œë°œ ë…¸ë“œ
        for i in range(n):
            # j = ë„ì°© ë…¸ë“œ
            for j in range(n):
                if dist[i][k] + dist[k][j] < dist[i][j]:
                    dist[i][j] = dist[i][k] + dist[k][j]
                    
    return dist
```

---

## ğŸ“ ìµœë‹¨ ê²½ë¡œ ë¬¸ì œ í•´ê²° ì „ëµ

### 1. **ê·¸ë˜í”„ ì¢…ë¥˜ íŒŒì•…**
- ê°€ì¤‘ì¹˜ê°€ ìˆëŠ”ê°€? (ì—†ìœ¼ë©´ BFS)
- ìŒìˆ˜ ê°€ì¤‘ì¹˜ê°€ ìˆëŠ”ê°€? (ìˆìœ¼ë©´ Bellman-Ford)

### 2. **ì§ˆë¬¸ì˜ ë²”ìœ„ í™•ì¸**
- í•œ ê³³ì—ì„œ ê°€ë‚˜? (Dijkstra)
- ëª¨ë“  ë…¸ë“œë¼ë¦¬ì˜ ê´€ê³„ë¥¼ ë³´ë‚˜? (Floyd-Warshall)

### 3. **êµ¬í˜„ íš¨ìœ¨ì„±**
- ë…¸ë“œì™€ ê°„ì„ ì˜ ìˆ˜ì— ë”°ë¼ ì–´ë–¤ ì•Œê³ ë¦¬ì¦˜ì´ ì‹œê°„ ë‚´ì— í†µê³¼í• ì§€ ê³„ì‚° ë£¨í”„ë¥¼ ë¯¸ë¦¬ ì˜ˆìƒí•˜ì„¸ìš”.

---

## ğŸš¨ í”í•œ ì‹¤ìˆ˜

1. **ì¸ì ‘ í–‰ë ¬ vs ì¸ì ‘ ë¦¬ìŠ¤íŠ¸ ì„ íƒ** âŒ
   - ê°„ì„ ì´ ì ì€ ê·¸ë˜í”„(Sparse Graph)ì—ì„œ ì¸ì ‘ í–‰ë ¬ì„ ì“°ë©´ ë©”ëª¨ë¦¬ì™€ ì‹œê°„ì´ ë‚­ë¹„ë©ë‹ˆë‹¤ (Dijkstra êµ¬í˜„ ì‹œ íŠ¹íˆ ì£¼ì˜).

2. **ìš°ì„ ìˆœìœ„ í ê°±ì‹  ëˆ„ë½**
   - ë‹¤ìµìŠ¤íŠ¸ë¼ì—ì„œ `current_dist > distances[current_node]` ì²´í¬ë¥¼ ìƒëµí•˜ë©´ íì— ë“¤ì–´ìˆëŠ” ë‚¡ì€ ì •ë³´ë“¤ì„ ëª¨ë‘ ì²˜ë¦¬í•˜ëŠë¼ ì†ë„ê°€ ë§¤ìš° ëŠë ¤ì§‘ë‹ˆë‹¤.

3. **ë‹¤ìµìŠ¤íŠ¸ë¼ì—ì„œ ìŒìˆ˜ ê°€ì¤‘ì¹˜ ì²˜ë¦¬ ì‹œë„** âŒ
   - ë¬´í•œ ë£¨í”„ì— ë¹ ì§€ê±°ë‚˜ ì˜ëª»ëœ ê²°ê³¼ë¥¼ ë‚¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

---

### ğŸ“š ì—°ê²° ë¬¸ì„œ
- [[02_algorithms/graph-traversal|ê·¸ë˜í”„ íƒìƒ‰]] - ê°€ì¤‘ì¹˜ ì—†ëŠ” ìµœë‹¨ ê²½ë¡œëŠ” BFS ë¡œ!
- [[01_data-structures/heap-and-priority-queue|Heap]] - ë‹¤ìµìŠ¤íŠ¸ë¼ì˜ í•µì‹¬ ì—”ì§„
- [[01_data-structures/disjoint-set|Union-Find]] - ê·¸ë˜í”„ ì—°ê²° ìƒíƒœ í™•ì¸ì˜ ë‹¬ì¸
- [[02_algorithms/greedy|Greedy]] - ë‹¤ìµìŠ¤íŠ¸ë¼ê°€ ê·¸ë¦¬ë””ì¸ ì´ìœ 
- [[02_algorithms/dynamic-programming|DP]] - í”Œë¡œì´ë“œ-ì™€ìƒ¬ì´ DP ì¸ ì´ìœ 
