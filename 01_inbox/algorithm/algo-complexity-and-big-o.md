---
title: algo-complexity-and-big-o
tags: [algorithm, big-o, complexity, optimization, performance]
aliases: [Big-O, ê³µê°„ ë³µì¡ë„, ì‹œê°„ ë³µì¡ë„]
date modified: 2025-12-18 10:15:31 +09:00
date created: 2025-12-17 19:00:00 +09:00
---

## ë³µì¡ë„ ì´ë¡ ê³¼ Big-O: ì—”ì§€ë‹ˆì–´ì˜ ìì› ê´€ë¦¬ë²•

"ì´ ì½”ë“œëŠ” O(n) ì…ë‹ˆë‹¤"ë¼ëŠ” ë§ì€ ë©´ì ‘ìš© ì •ë‹µì´ ì•„ë‹™ë‹ˆë‹¤.

**"ë°ì´í„°ê°€ 10 ë°° ëŠ˜ì–´ë‚  ë•Œ, ì„œë²„ ë¹„ìš©ì€ ëª‡ ë°° ëŠ˜ì–´ë‚˜ëŠ”ê°€?"** ì— ëŒ€í•œ ê²½ì œí•™ì  ëŒ€ë‹µì…ë‹ˆë‹¤.

### ğŸ’¡ Why it matters (Context)

- **Scalability (í™•ì¥ì„±)**: ì‚¬ìš©ìê°€ 100 ëª…ì¼ ë•Œ 0.1 ì´ˆ ê±¸ë¦¬ë˜ API ê°€, 100 ë§Œ ëª…ì´ ë˜ë©´ 1000 ì´ˆê°€ ê±¸ë¦°ë‹¤ë©´? ê·¸ ì„œë¹„ìŠ¤ëŠ” ë§í•©ë‹ˆë‹¤. ë³µì¡ë„ëŠ” **ì„œë¹„ìŠ¤ì˜ ìˆ˜ëª…**ì„ ì˜ˆì¸¡í•˜ëŠ” ì§€í‘œì…ë‹ˆë‹¤.
- **DoS ê³µê²© ë°©ì–´**: í•´ì‹œ ì¶©ëŒì„ ìœ ë„í•´ O(1) ì¡°íšŒë¥¼ O(n) ìœ¼ë¡œ ë§Œë“¤ë©´ ì„œë²„ CPU ê°€ 100% ê°€ ë©ë‹ˆë‹¤. ì•Œê³ ë¦¬ì¦˜ì„ ëª¨ë¥´ë©´ ë³´ì•ˆ ì·¨ì•½ì ì´ ë©ë‹ˆë‹¤. (ReDoS ë“±)
- **Latency Guarantee**: ì‹¤ì‹œê°„ ì‹œìŠ¤í…œ (ê²Œì„, ì£¼ì‹ ê±°ë˜) ì—ì„œëŠ” O(1) ë³´ë‹¤ **Worst Case ê°€ O(log n) ì¸ ê²ƒ**ì´ ë” ë‚˜ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì˜ˆì¸¡ ë¶ˆê°€ëŠ¥í•œ íŠ€ëŠ” ê°’ (Spike) ì´ ì—†ì–´ì•¼ í•˜ê¸° ë•Œë¬¸ì…ë‹ˆë‹¤.

---

### ğŸš¦ Big-O í‘œê¸°ë²•ì˜ ì‹¤ì²´

Big-O ëŠ” **ìƒí•œì„  (Upper Bound)** ì…ë‹ˆë‹¤. "ì•„ë¬´ë¦¬ ëŠë ¤ë„ ì´ ì •ë„ëŠ” ë³´ì¥í•œë‹¤"ëŠ” ì•½ì†ì…ë‹ˆë‹¤.

#### ì£¼ìš” ë³µì¡ë„ ìŠ¤í™íŠ¸ëŸ¼

| í‘œê¸°             | ë³„ëª…               | ì‹¤í–‰ ì‹œê°„ (N=100) | ì‹¤í–‰ ì‹œê°„ (N=1 ë§Œ) | ì˜ˆì‹œ                                            |
| :------------- | :--------------- | :------------ | :------------ | :-------------------------------------------- |
| **O(1)**       | Constant (ìƒìˆ˜)    | 1             | 1             | Hash Map ì¡°íšŒ, Array ì¸ë±ìŠ¤ ì ‘ê·¼                     |
| **O(log n)**   | Logarithmic (ë¡œê·¸) | 7             | 14            | Binary Search, Balanced Tree (Red-Black, AVL) |
| **O(n)**       | Linear (ì„ í˜•)      | 100           | 10,000        | for loop, Linked List íƒìƒ‰                      |
| **O(n log n)** | Lineariths       | 700           | 140,000       | Merge Sort, Quick Sort (Avg), Heap Sort       |
| **O(n^2)**     | Quadratic (ì œê³±)   | 10,000        | 1 ì–µ (ìœ„í—˜)      | 2 ì¤‘ for loop, Insertion Sort, Selection Sort  |
| **O(2^n)**     | Exponential (ì§€ìˆ˜) | ìš°ì£¼ ë©¸ë§         | ê³„ì‚° ë¶ˆê°€         | ì¬ê·€ í”¼ë³´ë‚˜ì¹˜, ì™¸íŒì› ìˆœíšŒ (TSP)                         |

>[!TIP] **í˜„ì‹¤ì ì¸ í•œê³„**
> -   **O(n^2)**: N=10,000 ì„ ë„˜ì–´ê°€ë©´ íƒ€ì„ì•„ì›ƒ (1 ì´ˆ) ìœ„í—˜ì´ í½ë‹ˆë‹¤.
> -   **O(n!)**: N=12 ë§Œ ë¼ë„ 4 ì–µ 7 ì²œë§Œì…ë‹ˆë‹¤. ìˆœì—´ (Permutation) ë¬¸ì œëŠ” N ì´ ì‘ì„ ë•Œë§Œ ê°€ëŠ¥í•©ë‹ˆë‹¤.

---

#### ğŸ“Š ë³µì¡ë„ë³„ ì„±ì¥ë¥  ê·¸ë˜í”„

**O(1) - Constant Time**

![[../../_assets/algorithm/o_1_graph.png]]

ì…ë ¥ í¬ê¸°ì™€ ë¬´ê´€í•˜ê²Œ í•­ìƒ ì¼ì •í•œ ì‹œê°„ì´ ê±¸ë¦½ë‹ˆë‹¤.

**O(log n) - Logarithmic Time**

![[../../_assets/algorithm/o_log_n_graph.png]]

ì…ë ¥ì´ ì»¤ì ¸ë„ ì‹¤í–‰ ì‹œê°„ì€ ì™„ë§Œí•˜ê²Œ ì¦ê°€í•©ë‹ˆë‹¤. ë§¤ìš° íš¨ìœ¨ì ì…ë‹ˆë‹¤.

**O(n) - Linear Time**

![[../../_assets/algorithm/o_n_graph.png]]

ì…ë ¥ í¬ê¸°ì— ë¹„ë¡€í•´ì„œ ì‹œê°„ì´ ì¦ê°€í•©ë‹ˆë‹¤.

**O(n log n) - Quasi-linear Time**

![[../../_assets/algorithm/o_n_log_n_graph.png]]

íš¨ìœ¨ì ì¸ ì •ë ¬ ì•Œê³ ë¦¬ì¦˜ë“¤ì´ ì´ ë³µì¡ë„ë¥¼ ê°€ì§‘ë‹ˆë‹¤.

**O(nÂ²) - Quadratic Time**

![[../../_assets/algorithm/o_n_2_graph.png]]

ì…ë ¥ì´ 2 ë°°ê°€ ë˜ë©´ ì‹œê°„ì€ 4 ë°°ê°€ ë©ë‹ˆë‹¤. í° ë°ì´í„°ì—ëŠ” ë¶€ì í•©í•©ë‹ˆë‹¤.

**ì „ì²´ ë³µì¡ë„ ë¹„êµ**

![[../../_assets/algorithm/o_graph.png]]

ìœ„ ê·¸ë˜í”„ëŠ” ê° ë³µì¡ë„ê°€ ì…ë ¥ í¬ê¸°ì— ë”°ë¼ ì–´ë–»ê²Œ ì¦ê°€í•˜ëŠ”ì§€ í•œëˆˆì— ë³´ì—¬ì¤ë‹ˆë‹¤.

---

### ğŸ“ Code Examples (Dart)

ì‹¤ì œ ì½”ë“œë¡œ ê° ë³µì¡ë„ë¥¼ ì²´í—˜í•´ë´…ì‹œë‹¤.

#### O(1) - Constant Time

```dart
void checkFirst(List<String> names) {
  if (names.isNotEmpty) {
    print(names.first);
  } else {
    print("no names");
  }
}
```

ì…ë ¥ ë¦¬ìŠ¤íŠ¸ì˜ í¬ê¸°ì™€ ë¬´ê´€í•˜ê²Œ ì²« ë²ˆì§¸ ìš”ì†Œë§Œ í™•ì¸í•©ë‹ˆë‹¤.

#### O(log n) - Logarithmic Time

```dart
// 1. contains()ì˜ ê°€ì¥ ë‹¨ìˆœí•œ ë°©ë²• - O(n)
const numbers = [1, 3, 56, 66, 68, 80, 99, 105, 450];

bool naiveContains(int value, List<int> list) {
  for (final element in list) {
    if (element == value) {
      return true;
    }
  }
  return false;
}

// 2. contains() ê°œì„ ëœ ë°©ë²• (ì •ë ¬ëœ ê²½ìš°) - O(log n)
bool betterNaiveContains(int value, List<int> list) {
  if (list.isEmpty) return false;
  final middleIndex = list.length ~/ 2;

  if (value > list[middleIndex]) {
    for (var i = middleIndex; i < list.length; i++) {
      if (list[i] == value) return true;
    }
  } else {
    for (var i = middleIndex; i >= 0; i--) {
      if (list[i] == value) return true;
    }
  }

  return false;
}
```

ì •ë ¬ëœ ë¦¬ìŠ¤íŠ¸ì—ì„œ ì¤‘ê°„ê°’ì„ ê¸°ì¤€ìœ¼ë¡œ ë²”ìœ„ë¥¼ ì ˆë°˜ìœ¼ë¡œ ì¤„ì…ë‹ˆë‹¤.

#### O(n) - Linear Time

```dart
void printNames(List<String> names) {
  for (final name in names) {
    print(name);
  }
}
```

ëª¨ë“  ìš”ì†Œë¥¼ ì •í™•íˆ í•œ ë²ˆì”© ìˆœíšŒí•©ë‹ˆë‹¤.

#### O(nÂ²) - Quadratic Time

```dart
void printMoreNames(List<String> names) {
  for (final _ in names) {
    for (final name in names) {
      print(name);
    }
  }
}
```

ì¤‘ì²©ëœ ë£¨í”„ë¡œ ì¸í•´ ì…ë ¥ í¬ê¸°ì˜ ì œê³±ë§Œí¼ ì—°ì‚°ì´ ë°œìƒí•©ë‹ˆë‹¤.

#### ê³µê°„ ë³µì¡ë„ ì˜ˆì œ

```dart
// O(n) Space
List<String> fillList(int length) {
  return List.filled(length, 'a');
}

// O(nÂ²) Space
List<String> stuffList(int length) {
  return List.filled(length, 'a' * length);
}
```

`stuffList` ëŠ” ê° ìš”ì†Œê°€ `length` ë§Œí¼ì˜ ë¬¸ìì—´ì´ë¯€ë¡œ ì´ ê³µê°„ì€ O(nÂ²) ì…ë‹ˆë‹¤.

---

### âš–ï¸ Time vs Space Trade-off

"ì‹œê°„ì„ ì•„ë¼ë ¤ë©´ ë©”ëª¨ë¦¬ë¥¼ ì¨ë¼. ë©”ëª¨ë¦¬ë¥¼ ì•„ë¼ë ¤ë©´ ì‹œê°„ì„ ì¨ë¼."

#### 1. Space-Time Trade-off
- **Hash Table**: ë©”ëª¨ë¦¬ë¥¼ ë§ì´ ì¨ì„œ (ê³µê°„ O(n)), ê²€ìƒ‰ì„ ë¹ ë¥´ê²Œ (ì‹œê°„ O(1)) ë§Œë“­ë‹ˆë‹¤.
- **Memoization (DP)**: ì´ë¯¸ ê³„ì‚°í•œ ê°’ì„ ë©”ëª¨ë°°ì—´ì— ì €ì¥í•´ (ê³µê°„ O(n)), ì¤‘ë³µ ê³„ì‚°ì„ ì—†ì•° (ì‹œê°„ O(2^n) -> O(n)).

#### 2. In-Place Algorithm

ì¶”ê°€ ë©”ëª¨ë¦¬ë¥¼ ê±°ì˜ ì•ˆ ì“°ëŠ” (O(1) Space) ì•Œê³ ë¦¬ì¦˜ì…ë‹ˆë‹¤.

- **Quick Sort**: ì¶”ê°€ ë°°ì—´ ì—†ì´ swap ë§Œìœ¼ë¡œ ì •ë ¬í•©ë‹ˆë‹¤. ê³µê°„ íš¨ìœ¨ì ì´ë¼ ìºì‹œ íˆíŠ¸ìœ¨ì´ ì¢‹ìŠµë‹ˆë‹¤.
- **Merge Sort**: í•„ì—°ì ìœ¼ë¡œ O(n) ì˜ ë³´ì¡° ë°°ì—´ì´ í•„ìš”í•©ë‹ˆë‹¤. ë©”ëª¨ë¦¬ê°€ ë¶€ì¡±í•œ ì„ë² ë””ë“œ í™˜ê²½ì—ì„œëŠ” Quick Sort ê°€ ì„ í˜¸ë˜ëŠ” ì´ìœ ì…ë‹ˆë‹¤.

---

### ğŸ’¾ Amortized Analysis (ë¶„í•  ìƒí™˜ ë¶„ì„)

"ê°€ë” ë¹„ì‹¼ ë¹„ìš©ì„ ì¹˜ë¥´ì§€ë§Œ, í‰ê· ë‚´ë©´ ì‹¸ë‹¤."

**ë™ì  ë°°ì—´ (Dynamic Array) ì˜ `append`**:
- ëŒ€ë¶€ë¶„ì€ O(1) ì…ë‹ˆë‹¤ (ë¹ˆ ì¹¸ì— ë„£ê¸°ë§Œ í•˜ë©´ ë¨).
- ë°°ì—´ì´ ê½‰ ì°¨ë©´ **Capacity ë¥¼ 2 ë°°ë¡œ ëŠ˜ë¦¬ê³  ë³µì‚¬ (Resize)** í•©ë‹ˆë‹¤. ì´ë•ŒëŠ” O(n) ì´ ê±¸ë¦½ë‹ˆë‹¤.
- í•˜ì§€ë§Œ Resize ëŠ” ìì£¼ ì¼ì–´ë‚˜ì§€ ì•Šìœ¼ë¯€ë¡œ, ì „ì²´ N ë²ˆì˜ `append` ë¥¼ í•˜ë©´ ì´ë¹„ìš©ì€ O(n) ì…ë‹ˆë‹¤.
- ë”°ë¼ì„œ 1 íšŒ í‰ê·  ë¹„ìš©ì€ **Amortized O(1)** ì…ë‹ˆë‹¤.

>[!WARNING] **Latency Critical ì‹œìŠ¤í…œ ì£¼ì˜**
>"í‰ê·  O(1)"ì€ ë¯¿ìœ¼ë©´ ì•ˆ ë©ë‹ˆë‹¤. Resize ê°€ í„°ì§€ëŠ” ìˆœê°„ ìˆ˜ ë°€ë¦¬ì´ˆê°€ ë©ˆì¶¥ë‹ˆë‹¤ (Jitter). ì‹¤ì‹œê°„ ì˜¤ë””ì˜¤ ì²˜ë¦¬ë‚˜ ê³ ë¹ˆë„ ê±°ë˜ (HFT) ì—ì„œëŠ” ë¯¸ë¦¬ ìš©ëŸ‰ì„ í™•ë³´ (`reserveCapacity`) í•˜ê±°ë‚˜ Linked List ë¥¼ ì¨ì•¼ í•©ë‹ˆë‹¤.

---

### ğŸ§ª Latency Numbers Every Programmer Should Know

ì•Œê³ ë¦¬ì¦˜ì´ ì‹¤ì œ í•˜ë“œì›¨ì–´ì—ì„œ ì–¼ë§ˆë‚˜ ê±¸ë¦¬ëŠ”ì§€ ê°ì„ ì¡ì•„ì•¼ í•©ë‹ˆë‹¤. (Jeff Dean @ Google)

- **L1 Cache ì°¸ì¡°**: 0.5 ns
- **Branch Mispredict**: 5 ns
- **L2 Cache ì°¸ì¡°**: 7 ns
- **Mutex Lock/Unlock**: 25 ns
- **Main Memory ì°¸ì¡°**: 100 ns (L1 ë³´ë‹¤ 200 ë°° ëŠë¦¼) -> [[algo-ds-linear|Linked Listê°€ ëŠë¦° ì´ìœ ]]
- **SSD Random Read**: 150,000 ns
- **Packet Roundtrip (CA->Netherlands)**: 150,000,000 ns (150ms)

ğŸ‘‰ **ê²°ë¡ **: ë„¤íŠ¸ì›Œí¬ í˜¸ì¶œ í•œ ë²ˆ (150ms) ì¤„ì´ëŠ” ê²Œ, Bubble Sort ë¥¼ Quick Sort ë¡œ ë°”ê¾¸ëŠ” ê²ƒ (ìˆ˜ ms ì ˆì•½) ë³´ë‹¤ í›¨ì”¬ í° ì„±ëŠ¥ í–¥ìƒì„ ê°€ì ¸ì˜µë‹ˆë‹¤. **ë³‘ëª© (Bottleneck)**ì„ ë¨¼ì € ì°¾ìœ¼ì„¸ìš”.

---

### ğŸ¯ ìƒí•œ (Upper Bound) vs ìµœì•… (Worst Case)

Big-O ëŠ” **ìƒí•œ (Upper Bound)**ì„ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤. "ìµœì•…ì˜ ê²½ìš°ì—ë„ ì´ ì •ë„ ì´í•˜"ë¼ëŠ” ë³´ì¥ì…ë‹ˆë‹¤.

#### Big-O í‘œê¸°ë²•ì˜ 3 í˜•ì œ

- **O (Big-O)**: ìƒí•œì„ . "ìµœì•…ì˜ ê²½ìš°ì—ë„ ì´ê²ƒë³´ë‹¤ ëŠë¦¬ì§€ ì•Šë‹¤"
- **Î© (Big Omega)**: í•˜í•œì„ . "ìµœì„ ì˜ ê²½ìš°ì—ë„ ì´ê²ƒë³´ë‹¤ ë¹ ë¥´ì§€ ì•Šë‹¤" (ëœ ìœ ìš©í•¨)
- **Î˜ (Big Theta)**: ìƒí•œê³¼ í•˜í•œì´ ê°™ì„ ë•Œ. "í•­ìƒ ì •í™•íˆ ì´ ì •ë„ë‹¤"

>[!WARNING] **ìƒí•œ â‰  ìµœì•…**
>Big-O ëŠ” **ì ê·¼ì  ìƒí•œ (Asymptotic Upper Bound)**ì´ì§€, íŠ¹ì • ì…ë ¥ì—ì„œì˜ ìµœì•… ì¼€ì´ìŠ¤ê°€ ì•„ë‹™ë‹ˆë‹¤.
>
>ì˜ˆ: Quick Sort ì˜ ê²½ìš°
> - **í‰ê·  ì¼€ì´ìŠ¤**: O(n log n)
> - **ìµœì•… ì¼€ì´ìŠ¤**: O(nÂ²) (ì´ë¯¸ ì •ë ¬ëœ ê²½ìš°)
>
>í•˜ì§€ë§Œ "Quick Sort ëŠ” O(nÂ²) ì´ë‹¤"ë¼ê³  ë§í•˜ëŠ” ê²ƒë„ í‹€ë¦° í‘œí˜„ì€ ì•„ë‹™ë‹ˆë‹¤. ë‹¤ë§Œ **í‰ê· ì ìœ¼ë¡œ O(n log n)**ì´ë¼ê³  ë§í•˜ëŠ” ê²ƒì´ ë” ìœ ìš©í•©ë‹ˆë‹¤.

---

### ğŸš€ ë³‘ë ¬í™” (Parallelization)

ë”¥ëŸ¬ë‹ì˜ ë“±ì¥ ì´í›„, ì•Œê³ ë¦¬ì¦˜ì˜ **ë³‘ë ¬í™” ê°€ëŠ¥ì„± (Parallelizability)** ì´ ì¤‘ìš”í•œ í‰ê°€ ì§€í‘œê°€ ë˜ì—ˆìŠµë‹ˆë‹¤.

- **ë³‘ë ¬í™” ê°€ëŠ¥**: Matrix Multiplication, Map-Reduce ê°™ì€ ì‘ì—…ì€ ì—¬ëŸ¬ ì½”ì–´ì—ì„œ ë™ì‹œì— ì‹¤í–‰í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. GPU ê°€ ë¹ ë¥¸ ì´ìœ ì…ë‹ˆë‹¤.
- **ë³‘ë ¬í™” ë¶ˆê°€ëŠ¥**: Linked List ìˆœíšŒì²˜ëŸ¼ "ì´ì „ ê²°ê³¼ë¥¼ ì•Œì•„ì•¼ ë‹¤ìŒì„ ê³„ì‚°í•  ìˆ˜ ìˆëŠ” (Sequential Dependency)" êµ¬ì¡°ëŠ” ë³‘ë ¬í™”ê°€ ì–´ë µìŠµë‹ˆë‹¤.

>[!TIP] **í˜„ëŒ€ì  ê´€ì **
> - **Single-threaded O(n log n)** ì•Œê³ ë¦¬ì¦˜ë³´ë‹¤
> - **Parallelizable O(nÂ²)** ì•Œê³ ë¦¬ì¦˜ì´ GPU í™˜ê²½ì—ì„œ ë” ë¹ ë¥¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
>
>ì˜ˆ: Naive Matrix Multiplication (O(nÂ³), ë³‘ë ¬í™” ì‰¬ì›€) vs Strassen Algorithm (O(n^2.8), ë³‘ë ¬í™” ì–´ë ¤ì›€)

---

#### ğŸ“š ì—°ê²° ë¬¸ì„œ
- [[algo-ds-linear]] - ë©”ëª¨ë¦¬ ë ˆì´ì•„ì›ƒê³¼ ìºì‹œ íš¨ìœ¨ì„±
- [[algo-ds-hash-and-map]] - O(1) ì˜ ë¹„ë°€ê³¼ í•´ì‹œ ì¶©ëŒ
- [[kernel#2. NUMA (Non-Uniform Memory Access)]] - ë©”ëª¨ë¦¬ ì ‘ê·¼ ë¹„ìš©ì˜ ì‹¬í™”
