---
title: segment-tree
tags: [data-structure, tree, segment-tree, range-query, optimization]
aliases: [ì„¸ê·¸ë¨¼íŠ¸ íŠ¸ë¦¬, êµ¬ê°„ íŠ¸ë¦¬, êµ¬ê°„ í•© íŠ¸ë¦¬, Segment Tree]
date modified: 2025-12-18 12:15:00 +09:00
date created: 2025-12-18 12:15:00 +09:00
---

## Segment Tree & Fenwick Tree: êµ¬ê°„ì˜ ì •ë³´ë¥¼ O(log N)ì— ì§€ë°°í•˜ê¸°

**ì„¸ê·¸ë¨¼íŠ¸ íŠ¸ë¦¬(Segment Tree)**ì™€ **íœìœ… íŠ¸ë¦¬(Fenwick Tree, BIT)**ëŠ” ë°°ì—´ì˜ íŠ¹ì • êµ¬ê°„ $[L, R]$ì— ëŒ€í•œ ì§ˆë¬¸(í•©, ìµœëŒ“ê°’, ìµœì†Ÿê°’ ë“±)ì— ì‘ë‹µí•˜ê³ , ë°ì´í„°ê°€ ë³€ê²½ë  ë•Œ íŠ¸ë¦¬ë¥¼ ì—…ë°ì´íŠ¸í•˜ëŠ” ì‘ì—…ì„ ëª¨ë‘ **$O(\log N)$** ì‹œê°„ ë³µì¡ë„ë¡œ ìˆ˜í–‰í•˜ëŠ” ì‹¬í™” ìë£Œêµ¬ì¡°ì…ë‹ˆë‹¤.

### ğŸ’¡ Why it matters (Context)

- **ë™ì  ë°ì´í„°**: ë°°ì—´ì˜ ê°’ì´ ìê¾¸ ë°”ë€ŒëŠ”ë°, êµ¬ê°„ í•© ì§ˆë¬¸ì´ ìˆ˜ë§Œ ë²ˆ ë“¤ì–´ì˜¬ ë•Œ ì‚¬ìš©í•©ë‹ˆë‹¤. (ë°°ì—´ì´ ê³ ì •ì´ë¼ë©´ [[03_patterns/prefix-sum|Prefix Sum]]ì´ ë” ë¹ ë¦…ë‹ˆë‹¤)
- **íš¨ìœ¨ì„±**: ë‹¨ìˆœ $O(N)$ ì¡°íšŒë¥¼ $O(\log N)$ìœ¼ë¡œ ì¤„ì—¬, ëŒ€ê·œëª¨ ì‹œë®¬ë ˆì´ì…˜ì´ë‚˜ ì‹¤ì‹œê°„ ì‹œìŠ¤í…œì„ ê°€ëŠ¥í•˜ê²Œ í•©ë‹ˆë‹¤.

---

### ğŸ¢ ì‹¤ë¬´ ì‚¬ë¡€

#### Segment Tree í™œìš©
- **ì£¼ì‹ ê±°ë˜ ì‹œìŠ¤í…œ**: íŠ¹ì • ì‹œê°„ ë²”ìœ„ì˜ ì£¼ê°€ ìµœëŒ€/ìµœì†Œ/í•©ê³„ë¥¼ ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸í•˜ë©° ì¡°íšŒ.
- **ë¡œê·¸ ë¶„ì„ ì„œë²„**: íŠ¹ì • ì‹œê°„ëŒ€(Interval)ì˜ íŠ¸ë˜í”½ ê¸‰ì¦ êµ¬ê°„ì„ $O(\log N)$ì— íƒìƒ‰.
- **ê²Œì„ ì—”ì§„**: íŠ¹ì • ì˜ì—­ ë‚´ ìœ ë‹›ë“¤ì˜ ì²´ë ¥ í•©ê³„ ê³„ì‚° ë˜ëŠ” ì¶©ëŒ ë²”ìœ„ ê´€ë¦¬.
- **ê´‘ê³  í”Œë«í¼**: ì‹œê°„ëŒ€ë³„ ì˜ˆì‚° ì§‘í–‰ í˜„í™©ì„ ì—…ë°ì´íŠ¸í•˜ë©° ë‚¨ì€ ì˜ˆì‚° êµ¬ê°„ ì¡°íšŒ.
- **ë°ì´í„°ë² ì´ìŠ¤ ì¸ë±ìŠ¤**: ë²”ìœ„ ê²€ìƒ‰(Range Search)ì„ ì§€ì›í•˜ëŠ” ê³ ê¸‰ ì¸ë±ì‹± êµ¬ì¡°.

---

## ğŸ—ï¸ íŠ¸ë¦¬ êµ¬ì¡°ì™€ ë©”ëª¨ë¦¬

- **ë£¨íŠ¸ ë…¸ë“œ**: ì „ì²´ êµ¬ê°„ $[0, n-1]$ì˜ ì •ë³´.
- **ë¦¬í”„ ë…¸ë“œ**: ë°°ì—´ì˜ ê°œë³„ ìš”ë¦¬ ì •ë³´.
- **ì¤‘ê°„ ë…¸ë“œ**: ìì‹ ë…¸ë“œë“¤ì˜ ì •ë³´ë¥¼ í•©ì¹œ êµ¬ê°„ ì •ë³´ ($[L, mid]$, $[mid+1, R]$).
- **ë©”ëª¨ë¦¬**: ë³´í†µ $4 \times N$ í¬ê¸°ì˜ ë¦¬ìŠ¤íŠ¸ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.

---

## ğŸ› ï¸ í•µì‹¬ êµ¬í˜„ (êµ¬ê°„ í•© ì˜ˆì‹œ)

```python
class SegmentTree:
    def __init__(self, data):
        self.n = len(data)
        self.tree = [0] * (4 * self.n)
        self._build(data, 1, 0, self.n - 1)

    def _build(self, data, node, start, end):
        # 1. ë¦¬í”„ ë…¸ë“œì— ë„ë‹¬í•¨
        if start == end:
            self.tree[node] = data[start]
            return
        
        # 2. ìì‹ë“¤ë¡œ ìª¼ê°¬
        mid = (start + end) // 2
        self._build(data, 2 * node, start, mid)
        self._build(data, 2 * node + 1, mid + 1, end)
        
        # 3. ì˜¬ë¼ì˜¬ ë•Œ í•©ì¹¨ (Conquer)
        self.tree[node] = self.tree[2 * node] + self.tree[2 * node + 1]

    def query(self, node, start, end, left, right):
        # 1. êµ¬ê°„ì´ ì•„ì˜ˆ ì•ˆ ê²¹ì¹¨
        if left > end or right < start:
            return 0
        
        # 2. ì¿¼ë¦¬ ë²”ìœ„ê°€ ë…¸ë“œ ë²”ìœ„ë¥¼ ì™„ì „íˆ í¬í•¨í•¨
        if left <= start and end <= right:
            return self.tree[node]
        
        # 3. ê±¸ì³ ìˆìŒ -> ì–‘ìª½ ë‹¤ íƒìƒ‰
        mid = (start + end) // 2
        lsum = self.query(2 * node, start, mid, left, right)
        rsum = self.query(2 * node + 1, mid + 1, end, left, right)
        return lsum + rsum

    def update(self, node, start, end, idx, val):
        if start == end:
            self.tree[node] = val
            return
        
        mid = (start + end) // 2
        if idx <= mid:
            self.update(2 * node, start, mid, idx, val)
        else:
            self.update(2 * node + 1, mid + 1, end, idx, val)
            
        # ìì‹ ê°’ì´ ë°”ë€Œì—ˆìœ¼ë‹ˆ ë¶€ëª¨ë„ ê°±ì‹ 
        self.tree[node] = self.tree[2 * node] + self.tree[2 * node + 1]
```

---

## ğŸš¨ í”í•œ ì‹¤ìˆ˜ (Common Mistakes)

1. **ë°°ì—´ í¬ê¸° ì˜¤íŒ** âŒ
   - íŠ¸ë¦¬ ë°°ì—´ì˜ í¬ê¸°ê°€ $2^k$ ê¼´ë¡œ ë”± ë–¨ì–´ì§€ì§€ ì•ŠëŠ” ê²½ìš°, ì•ˆì „í•˜ê²Œ $4 \times N$ì„ í• ë‹¹í•´ì•¼ í•©ë‹ˆë‹¤. (í˜¹ì€ $2^{\lceil \log_2 N \rceil + 1}$)
2. **ì¸ë±ìŠ¤ ì²˜ë¦¬ (1-based vs 0-based)**
   - íŠ¸ë¦¬ì˜ ë…¸ë“œ ë²ˆí˜¸ëŠ” ë³´í†µ ê³„ì‚° í¸ì˜ìƒ 1ë²ˆ(ë£¨íŠ¸)ë¶€í„° ì‹œì‘í•©ë‹ˆë‹¤. ë°°ì—´ ì¸ë±ìŠ¤(0-based)ì™€ í—·ê°ˆë¦¬ì§€ ì•Šë„ë¡ ì£¼ì˜í•˜ì„¸ìš”.
3. **ì—…ë°ì´íŠ¸ ëˆ„ë½**
   - ë¦¬í”„ ë…¸ë“œë§Œ ë°”ê¾¸ê³  ë¶€ëª¨ ë…¸ë“œë“¤ì„ ë‹¤ì‹œ í•©ì¹˜ì§€ ì•Šìœ¼ë©´ $O(1)$ ì¡°íšŒê°€ ì•„ë‹Œ ì˜¤ë‹µ ì¡°íšŒê°€ ë©ë‹ˆë‹¤.
4. **Prefix Sumê³¼ì˜ í˜¼ë™** âŒ
   - ë°ì´í„°ê°€ ë³€í•˜ì§€ ì•ŠëŠ” ì •ì  ë°°ì—´ì´ë¼ë©´ Prefix Sumì´ ë©”ëª¨ë¦¬ ê³µê°„($O(N)$)ê³¼ ì†ë„ ë©´ì—ì„œ í›¨ì”¬ ìœ ë¦¬í•©ë‹ˆë‹¤. ë°ì´í„° ë³€í™”ê°€ ìˆì„ ë•Œë§Œ ì„¸ê·¸ë¨¼íŠ¸ íŠ¸ë¦¬ë¥¼ êº¼ë‚´ì„¸ìš”.

---

---

## âš¡ íœìœ… íŠ¸ë¦¬ (Fenwick Tree / Binary Indexed Tree)

ì„¸ê·¸ë¨¼íŠ¸ íŠ¸ë¦¬ë³´ë‹¤ êµ¬í˜„ì´ í›¨ì”¬ ê°„ê²°í•˜ê³  ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ì´ ì ì€($O(N)$) ìë£Œêµ¬ì¡°ì…ë‹ˆë‹¤. ì£¼ë¡œ **ëˆ„ì  í•©(Prefix Sum)ì˜ ë™ì  ì—…ë°ì´íŠ¸**ê°€ í•„ìš”í•  ë•Œ ì‚¬ìš©ë©ë‹ˆë‹¤.

### ğŸ’¡ í•µì‹¬ ì›ë¦¬: "ë¹„íŠ¸ì˜ ëìë¦¬ 1ì„ í™œìš©"
`i & -i` ì—°ì‚°ì„ í†µí•´ ê°€ì¥ ë‚®ì€ ìë¦¬ì˜ ë¹„íŠ¸(LSB)ë¥¼ êµ¬í•˜ê³ , ì´ë¥¼ ì´ìš©í•´ íŠ¸ë¦¬ë¥¼ íƒìƒ‰í•©ë‹ˆë‹¤.

### ğŸ”§ êµ¬í˜„ (êµ¬ê°„ í•©)
```python
class FenwickTree:
    def __init__(self, n):
        self.tree = [0] * (n + 1)

    def update(self, i, delta):
        # ië²ˆì§¸ ê°’ì„ deltaë§Œí¼ ì¦ê°€ì‹œí‚´
        while i < len(self.tree):
            self.tree[i] += delta
            i += (i & -i)

    def query(self, i):
        # 1ë¶€í„° iê¹Œì§€ì˜ í•© êµ¬í•˜ê¸°
        s = 0
        while i > 0:
            s += self.tree[i]
            i -= (i & -i)
        return s

# êµ¬ê°„ [L, R] í•©: query(R) - query(L-1)
```

### âš”ï¸ Segment Tree vs Fenwick Tree

| íŠ¹ì§• | Segment Tree | Fenwick Tree |
|:---|:---|:---|
| **ë©”ëª¨ë¦¬** | $4N$ | $N$ |
| **êµ¬í˜„ ë‚œì´ë„** | ë†’ìŒ (ì¬ê·€/ë³µì¡) | ë§¤ìš° ë‚®ìŒ (ê°„ê²°) |
| **ìœ ì—°ì„±** | ìµœëŒ“ê°’, ìµœì†Ÿê°’ ë“± ììœ ë¡œì›€ | ì£¼ë¡œ ëˆ„ì  í•©(êµ¬ê°„ í•©)ì— íŠ¹í™” |
| **ì†ë„** | ì•½ê°„ ë” ë¬´ê±°ì›€ | ë§¤ìš° ë¹ ë¦„ |

---

## âš¡ ì‹¬í™”: ëŠë¦¬ê²Œ ê°±ì‹ ë˜ëŠ” ì„¸ê·¸ë¨¼íŠ¸ íŠ¸ë¦¬ (Lazy Propagation)

ë²”ìœ„$[L, R]$ ì „ì²´ì— íŠ¹ì • ê°’ì„ ë”í•´ì•¼ í•  ë•Œ, ëª¨ë“  ë¦¬í”„ë¥¼ ì¼ì¼ì´ ì—…ë°ì´íŠ¸($O(N \log N)$)í•˜ëŠ” ëŒ€ì‹ , "ë‚˜ì¤‘ì— ìì‹ ê°ˆ ë•Œ í•´ì£¼ì"ê³  ë©”ëª¨í•´ë‘ëŠ” ë°©ì‹ì…ë‹ˆë‹¤. ì´ë¥¼ í†µí•´ **êµ¬ê°„ ì—…ë°ì´íŠ¸ë„ $O(\log N)$** ë§Œì— ëë‚¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

---

### ğŸ“š ì—°ê²° ë¬¸ì„œ
- [[03_patterns/prefix-sum|ëˆ„ì  í•©]] - ì •ì  ë°ì´í„°ì˜ êµ¬ê°„ í•© ìµœê°•ì
- [[00_fundamentals/complexity-and-big-o|ë³µì¡ë„]] - $O(N)$ ì¡°íšŒë¥¼ $O(\log N)$ìœ¼ë¡œ ì¤„ì´ëŠ” ìœ„ë ¥
- [[02_algorithms/divide-and-conquer|ë¶„í•  ì •ë³µ]] - íŠ¸ë¦¬ë¥¼ ìª¼ê°œê³  í•©ì¹˜ëŠ” ê·¼ë³¸ íŒ¨ëŸ¬ë‹¤ì„
- [[01_data-structures/tree-and-graph|íŠ¸ë¦¬]] - ì„¸ê·¸ë¨¼íŠ¸ íŠ¸ë¦¬ì˜ ë¬¼ë¦¬ì  êµ¬ì¡°
