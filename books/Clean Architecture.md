# Clean Architecture 정리

#book, #clean-architecture

## 서문

- 소프트웨어 아키텍처라는 말은 뜬구름처럼 손에 잡히지 않는 어떤 것처럼 느껴짐
- 다음 질문을 해보아라
    - 그렇다면 소프트웨어 시스템이란 무엇인가?
    - 소프트웨어 시스템을 통해서 우리가 얻고자 하는 것은 무엇인가?
    - 잘 설계한 소프트웨어 아키텍처는 소프트웨어 시스템을 만들 때 왜 중요한가?
- 아키텍처의 매력은 **구조**에 있다
    - 패러다임을 지배하고 소프트웨어 개발의 논의를 지배하는 무언가
    - ex) 컴포넌트, 클래스, 함수, 모듈, 계층, 서비스
- 건축물에는 명확한 물리적 구조가 있지만, 소프트웨어는 무엇을 구조로 가지는가?
    - 소프트웨어는 소프트웨어로 구성된다
    - 큰 소프트웨어 구조물은 작은 소프트웨어 컴포넌트로 만들어지며, 이 컴포넌트는 더 작은 컴포넌트로 만들어지는 것을 반복함
- 즉, **소프트웨어는 본질적으로 재귀적이고 프랙털 구조로 되어있으며, 코드를 통해 아로새겨지고 스케치된다**
- 현실과 다르게 소프트웨어 아키텍처에서 물리학이나 물리적 **규모**를 말하는 것은 의미가 없더라도, 반드시 인정하고 신경써야 할 부분이 존재함
    ⇒ 프로세서 속도와 네트워크 대역폭은 시스템 성능을 한정 짓는 결정적 제약이 될 수 있음
- 즉, 소프트웨어에서 신경써야될 규모는 **시간**, **비용**, **노력** 이라는 요소가 된다
    - 큰 것과 작은 것을 정렬할 수 있게 해주고, 아키텍처적인 것과 아닌 것을 구분하게 해줌
    - 이 척도를 이용해 아키텍처의 좋고 나쁨을 결정할 수 있는 방법을 설명 해줌
        - **좋은 아키텍처는 사용자, 개발자, 소유자를 특정 시점에도 반드시 충족시켜줄 뿐만 아니라, 시간이 흐르더라도 반드시 충족시켜 준다**

> 아키텍처는 시스템을 구체화하는 중요한 설계 결정을 표현하며, 그 결정의 중요도는 변경에 드는 비용으로 측정된다. -Grady Booch-

- 어떻게 하면 좋은 아키텍처를 만들 수 있을까?
    - 권위적이고 엄격한 방법
        - 변경 비용이 크면 변경 자체를 제거하게 되어 좋지 않음
    - 추측성 일반화를 이용한 방법
        - 추측에 의한 하드코딩, 셀 수 없이 많은 파라미터, dead code, 복잡성이 늘어나 좋지 않음
    - 가장 깔끔한 방법
        - 소프트웨어의 softness를 인지하고, 이 부드러움을 시스템에서 최우선으로 보존하는 것을 목표로 해야함
        - 우리가 불완전한 지식에 기초해 행동한다는 사실을 인정할 뿐만 아니라, 불완전한 지식으로 행동하는 것이야 말로 인간으로서 우리가 무엇인가를 하는 방식이며, 우리의 뛰어난 부분임을 이해해야함
        - 주의와 관심, 사고와 관찰, 실천과 원칙이 필요함
- 모든 종류의 소프트웨어에 적용될 수 있는 규칙
    - 소프트웨어 아키텍처의 규칙은 다른 모든 변수에 독립적이다. 즉, 아키텍처 규칙이 동일하다.
    - 이유?
        - 컴퓨터와 프로그래밍 언어는 발전했지만 코드는 여전히 순차, 분기, 반복의 집합체일 뿐
        - 코드가 변하지 않았다는 사실이 시스템의 종류와 관계없이 소프트웨어 아키텍처의 규칙이 일관된 이유
- 소프트웨어를 제대로 만들면 ⇒ 아주 적은 인력만으로 유지가 가능하게 됨
- 제대로 만들려면 ⇒ 서로 강하게 연관되어 있으면 안됨
    - 변경하는게 힘들어짐

## 1부. 소개

### 1. 설계와 아키텍처란?

- 설계와 아키텍처의 차이
    - 둘 사이에 큰 차이가 없다
1. 아키텍처
    - 고수준의 무언가를 나타낼 때 사용
2. 설계
    - 저수준의 구조 또는 결정사항을 나타낼 때 사용
- 사실 모든 고수준의 결정사항을 지탱하는 모든 것은 저수준의 결정사항에서 확인할 수 있다
    - 단절없이 이어진 직물처럼, 개별로서 존재할 수 없고, 이 둘을 구분 짓는 경계가 뚜렷하지 않다
    - 고수준에서 저수준으로 향하는 의사결정의 연속성만 존재함
- **좋은 소프트웨어 설계의 목표**
    - **필요한 시스템을 만들고 유지 보수하는데 투입되는 인력을 최소화**
- 개발자가 쉽게 빠지는 착각
    ⇒ 지저분한 코드를 작성하면 단기간에 빠르게 갈 수 있고, 장기적으로 볼 때만 생산성이 낮아짐
    - 엉망으로 만들면 깔끔하게 유지할 때보다 항상 더 느리다는 것이 작가의 논리
    - 빨리 가는 유일한 방법은 제대로 가는 것이다

### 2. 두 가지 가치에 대한 이야기

- 소프트웨어 시스템이 제공하는 두 가지 가치
    1. 행위
    2. 구조
        - 소프트웨어는 부드러움을 지니도록 만들어졌음
        - 부드러움을 가지기 위해서는 변경이 쉬워야 함
        - 구조가 특정 형태를 다른형태 보다 선호하면 할수록, 새로운 기능을 이 구조에 맞추는게 힘들어짐
            ⇒ **아키텍처는 형태에 독립적이어야 하고, 그럴수록 더 실용적임**
- 두 가지 가치 모두 반드시 높게 유지해야 하는 책임이 있음
- 그 중 더 중요도가 높은 가치는 무엇인가?
    - 이해관계자는 행위가 더 높은 가치라고 할 것임
    - 하지만 프로그래머는 **구조를 더 높은 최우선 가치로 생각해야 함**
        - 완벽하게 동작하지만 수정이 아예 불가능한 프로그램
            ⇒ 요구사항이 변경될 때 마다 동작하지 않게 되므로 프로그램이 쓸모없게 됨
        - 동작은 하지 않지만 변경이 쉬운 프로그램
            ⇒ 프로그램이 돌아가게 만들 수 있고, 변경사항이 있더라도 여전히 동작하도록 유지하게 할 수 있음
- 프로그래머는 소프트웨어를 안전하게 보호해야할 책임이 있음
    - 아키텍처가 후순위가 되면 시스템을 개발하는 비용이 더 많이 들고, 일부 또는 전체 시스템 변경을 가하는 일이 현실적으로 불가능 해짐

## 2부. 벽돌부터 시작하기: 프로그래밍 패러다임

- 패러다임
    - 프로그래밍을 하는 방법
    - 언어에 독립적
    - 어떤 프로그래밍 구조를 사용할지, 언제 이 구조를 사용해야 하는지를 결정
- 이러한 종류의 프로그래밍 패러다임은 3가지 밖에 존재하지 않음
    - 구조적 프로그래밍(Structured Programming)
    - 객체지향 프로그래밍(Object-Oriented Programming)
    - 함수형 프로그래밍(Functional Programming)

### 3. 패러다임 개요

1. 구조적 프로그래밍
    - 제어흐름의 직접적인 전환에 대해 규칙을 부과
    - **모듈**의 기반 알고리즘으로 사용됨
2. 객체지향 프로그래밍
    - 제어흐름의 간접적인 전환에 대해 규칙을 부과
    - **다형성을 이용하여 아키텍처 경계를 넘나들 수 있게 해줌**
3. 함수형 프로그래밍
    - 할당문에 대해 규칙을 부과함
    - **데이터의 위치와 접근 방법에 대해 규칙을 부여**함
- 각 패러다임은 프로그래머에게서 권한을 박탈한다
    - 부정적인 의도를 가지는 일종의 추가적인 규칙을 부과
    - 무엇을 하면 안되는지 말해줌
- 더 빼앗아갈 규칙이 존재하는가?
    - 아마 없을 것이다
    - 그러므로 프로그래밍 패러다임은 앞으로도 이 세가지 밖에 없을 것이다

### 4. 구조적 프로그래밍

- 최초로 적용된 패러다임
- 네덜란드 프로그래머 데이크스트라가 어려운 프로그래밍을 해결하기 위해서 증명한 패러다임
    - 증명이라는 수학적 원리를 적용하여, 프로그래밍에 공리, 정리, 따름정리, 보조정리로 구성되는 유클리드 계층구조를 만드는 방식을 차용
    - 프로그래머는 입증된 구조를 이용하고, 이들 구조를 코드와 결합시키며, 그래서 코드가 올바르다는 사실을 스스로 증명하게 되는 방식
    - goto 문은 모듈을 더 작은 단위로 재귀적으로 분해하는 과정을 방해 하기 때문에 사용하는 것을 자제하고, 단순한 제어 구조인 if/then/else 와 do/while 을 사용해야 한다함
    - 이러한 제어 구조는 순차실행(sequential execution)과 결합하여 모든 프로그램을 순차,분기,반복이라는 세 가지 구조 만으로 표현할 수 있다는 사실을 증명함(단순 열거법 이용)
- 핵심
1. 구조적 프로그래밍을 통해 **모듈을 증명 가능한 더 작은 단위로 재귀적으로 분해**할 수 있게 되었고, 이는 결국 모듈을 기능적으로 분해할 수 있음을 뜻함
    - 거대한 문제 기술서 → 고수준의 기능으로 분해 → 저수준의 함수들로 분해 → … 가 가능해짐
2. 모듈과 컴포넌트는 **입증할 수 있는 아주 작은 기능들로 분해**할 수 있음

⇒ 소프트웨어 아키텍트는 **모듈, 컴포넌트, 서비스가 쉽게 반증 가능하도록 만들기 위해 분주히 노력해야 함**

### 5. 객체 지향 프로그래밍

- 좋은 아키텍처를 만드는 일 → 객체 지향 설계 원칙을 이해하고 응용하는데서 출발함
- 객체 지향 설계 원칙(OO)의 본질
    - 다형성(Polymorphism)
        - 하나의 객체가 여러가지 타입을 가질 수 있음
        - 객체 지향 언어 이전에도 다형성을 구현하고 있었음
        - 객체지향언어 이전 프로그래머들은 다형성 행위를 수행하기 위해 함수를 가리키는 포인터를 사용하여 표현함
            - 반드시 포인터를 초기화 해줘야함 ⇒ 실수할 위험이 있음
        - 객체 지향 언어는 이러한 위험을 차단하여 편리하게 다형성을 구현할 수 있게 해줌
- **제어흐름을 간접적으로 전환하는 규칙을 부여**함
- 다형성이 좋은 이유?
    - 플러그인 형태의 인터페이스를 이용하면, 추후에 비슷한 유형을 추가할 때 기존의 코드를 수정할 필요 없이 새로운 기능을 추가하기만 하면 됨
    - 또한, 이전 기능을 컴파일할 필요가 없음
    - 고수준 → 저수준으로 따르던 제어흐름을 마음대로 역전시키는 것이 가능하다 → 의존성 역전(Dependency Inversion)
        - UI, Database 등에 의존하던 업무규칙을 반대로, 업무규칙에 UI 와 Database 를 의존하게 만드는 것이 가능함
        - 업무 규칙의 소스코드는 UI, Database를 부르지 않음
        - 결과적으로 세가지로 분리된 컴포넌트로 따로 컴파일이 가능함 → 독립적으로 배포 가능 → 배포 독립성
        - 이렇게 모듈을 따로 배포할 수 있으면, 서로 다른 팀에서 각 모듈을 독립적으로 개발할 수 있음 → 개발 독립성
- 핵심
    - OO는 **다형성 지원을 이용**하여 전체 시스템의 모든 소스 코드 **의존성에 대한 절대적인 제어 권한**을 획득할 수 있는 능력을 줌
    - **고수준 정책을 포함하는 모듈은 저수준의 세부사항을 포함하는 모듈에 대해 독립성 보장**
- 여담
    - 객체 지향 언어의 특징인 캡슐화, 상속은, OO 이전에 발명된 언어인 C언어에서도 가능하다
    - 오히려 캡슐화의 경우, 객체지향언어가 정의에서 데이터를 노출 시키기 때문에 C언어보다 좋지 않다
    - 상속은 객체지향언어에서 편리한 기능을 제공하는 것은 맞지만 C언어에서도 구현이 가능했다

### 6. 함수형 프로그래밍

- 가변 변수를 사용하지 않는 프로그래밍 패러다임
- 한번 저장된 변수는 변하지 않고 트랜잭션만 저장해서 결과를 표현할 때는 변수와 함수를 계산한 값을 연산해서 보여주는 방식
- 중요한 이유?
    - 동시성 애플리케이션(=멀티 스레드 프로그램)에서 마주치는 모든 문제는 가변변수에 의해서 발생하기 때문
- 불변성은 정말 가능한가?
    - 저장공간이 무한하다면 가능
    - 저장공간이 무한하지 않다면?
        - 타협을 통해서 가능
        - 가변 컴포넌트와 불변 컴포넌트를 분리하고, 가능한 한 많은 처리를 불변 컴포넌트로 옮기면 가능
- 트랜잭션 자체를 저장하고, 상태가 필요해지면 단순히 상태의 시작점부터 모든 트랜잭션을 처리하는 전략 ⇒ 이벤트 소싱
    - 저장공간이 많이 필요할 것이다
    - 트랜잭션을 무한히 저장할 수 없으므로, 수명주기 동안 문제 없이 돌아갈 수 있도록 처리하면 된다
- CRUD가 아니라 CR만 처리하기 때문에 동시 업데이트 문제가 발생하지 않음
- 핵심
    - **함수형 프로그래밍은 변수 할당에 부과하는 규칙**

## 3부. 설계 원칙

- 좋은 소프트웨어 프로그램은 깔끔한 코드로 부터 시작함
    - 좋은 벽돌로 좋은 구조를 정의하는 원칙이 필요함 ⇒ SOLID 원칙
- SOLID 원칙
    - 함수와 데이터 구조를 클래스로 배치하는 방법
    - 목적
        - 중간 수준의 소프트웨어 구조가 아래와 같도록 만드는 데 있음
        1. 변경에 유연하다
        2. 이해하기 쉽다
        3. 많은 소프트웨어 시스템에 사용될 수 있는 컴포넌트의 기반이 된다
    - 중간수준의 소프트웨어 구조
        - 프로그래머가 이들 원칙을 모듈 수준에서 작업할 때 적용할 수 있다는 의미
        - 코드 수준보다는 조금 상위에서 적용되며 모듈과 컴포넌트 내부에서 사용되는 소프트웨어 구조를 정의하는데 도움을 줄 수 있음
    - SOLID 원칙의 개략적 설명
    1. Single Responsibility Principle
        - 소프트웨어 모듈은 변경의 이유가 단 하나여야만 한다
        - 코드 단위가 아니라 모듈 단위 어야 한다는 것 자세히 보기
    2. Open-Closed Principle
        - 새로운 코드를 추가하는 방식에는 열려있고, 기존 코드를 수정하는 방식에는 닫혀있도록 설계해야만 소프트웨어 시스템을 쉽게 변경할 수 있다
    3. Liskov Substitution Principle
        - 상호 대체 가능한 구성요소를 이용해 소프트웨어 시스템을 만들 수 있으려면, 이들 구성요소는 반드시 서로 치환 가능해야 한다는 계약을 반드시 지켜야 한다
    4. Interface Segregation Principle
        - 소프트웨어 설계는 사용하지 않은 것에 의존하지 않아야 한다
    5. Dependency Inversion Principle
        - 고수준 정책을 구현하는 코드는 저수준 세부사항을 구현하는 코드에 절대로 의존해서는 안된다. 대신 세부사항이 정책에 의존해야 한다

### 7. SRP: 단일 책임 원칙

- 가장 의미가 잘 전달되지 못한 원칙
    - 모듈이 단 하나의 일만 해야된다는 의미가 아님
        - 이는 커다란 함수를 작은 함수들로 리팩토링 하는 저수준에서 사용하는 원칙
- 단일 모듈은 변경의 이유가 하나, 오직 하나 뿐이어야 한다
    - 즉, 하나의 모듈은 하나의, **오직 하나의 액터에 대해서만 책임져야 한다**
- 모듈
    - 함수의 데이터 구조로 구성된 응집된 집합
    - 응집된?
        - 단일 액터를 책임지는 코드를 함께 묶어주는 힘
- 원칙을 위배하는 징후들
    1.  우발적 중복
    - 급여 애플리케이션에서 다음과 같은 구조를 가짐

```dart
class Employee {
    // used by Account
    void calculatePay() {}
    // used by HR
    void reportHours() {}
    // used by DBA
    void save() {}
}
```

- SRP를 위반
	- 세 가지 메서드가 매우 다른 세 명의 액터를 가지기 때문
        - 세 명의 액터를 결합하므로 일부에서 결정한 조치가 다른 액터에 영향을 줄 수 있음
1. 병합
	- 서로 다른 팀의 사용자들이 동시에 위의 Employee class를 수정하기 시작하면 변경사항이 충돌하여 병합이 일어날 것임
	- 소스 병합이 일어나면서 큰 문제가 발생하게 될 것임
	
⇒ 서로 다른 액터를 뒷받침 하는 코드를 서로 분리하자

- 해결책
    - 메서드를 각기 다른 클래스로 이동시키는 방식을 사용하자
        - 확실한 방법: 데이터와 메서드를 분리하는 방식

```dart
/// 데이터
class EmployeeData {
  // data
}

/// 메소드 분리
class PayCalculator {
  void calculatePay(EmployeeData employee) {}
}

class HourReporter {
  void reportHours(EmployeeData employee) {}
}

class EmploySaver {
  void save(EmployeeData employee) {}
}

/// 따로 관리해줘야하는 것이 불편하기 때문에
/// Facade 패턴을 사용하라
class EmployFacade {
  const EmployFacade({
    required this.calculator,
    required this.reporter,
    required this.saver,
  });

  final PayCalculator calculator;
  final HourReporter reporter;
  final EmploySaver saver;

  void calculate(EmployeeData employee) {
    calculator.calculatePay(employee);
  }

  void report(EmployeeData employee) {
    reporter.reportHours(employee);
  }

  void save(EmployeeData employee) {
    saver.save(employee);
  }
}
```

- 결론
    - 단일책임원칙은 메서드와 클래스 수준의 원칙임
    - 뒤에서 살펴볼 공통 폐쇄 원칙(Common Closure Principle)은 컴포넌트 수준의 원칙임
        - 아키텍처 경계의 생성을 책임지는 변경의 축(Axis of Change)이 됨

### 8. OCP: 개방-폐쇄 원칙

- 1988년 버트란트 마이어에 의해서 만들어진 원칙
- 소프트웨어는 확장에는 열려있어야 하고, 변경에는 닫혀있어야 한다는 원칙
- 소프트웨어 설계를 공부하기 시작한 지 얼마 안되는 사람 들 대다수는 OCP를 클래스와 모듈을 설계할 때 도움이 되는 원칙으로 알고 있음
	- 하지만 아키텍처 컴포넌트 수준에서 OCP를 고려할 때 훨씬 중요한 의미를 가짐
- 실험
	- 재무제표를 웹 페이지로 보여주는 시스템
	- 웹페이지에 표시되는 데이터는 스크롤 할 수 있고, 음수는 빨간색으로 출력
	- 같은 내용을 보고서 형태로 변환해서 흑백 프린터로 출력해달라고 요청이 들어옴
		- 페이지 번호가 제대로 있어야함
	        - 페이지마다 적절한 머리글과 바닥글이 있어야 함
	        - 표의 각 열에는 레이블이 있어야 함
	        - 음수는 괄호로 감싸야함
	-   코드를 추가하고 수정해야함 ⇒ 원래 작성된 코드를 얼마나 많이 수정해야 좋은 구조일까?
		- 이상적 변경량 = 0
		- 변경을 최소화 하는 것이 좋은 구조
	- 어떻게 수행할 수 있을까?
		- SRP 원칙에 따라 서로 다른 목적으로 변경되는 요소를 적절하게 분리
		- DIP 원칙에 따라 요소 사이의 의존성을 체계화
    
    ![OCP example](ocp_0.png)
-   가장 중요한 영감
	-   보고서 생성이 두 개의 책임으로 분리 됨
		1.  보고서용 데이터를 계산하는 책임
		2.  데이터를 웹으로 보여주거나 종이로 프린트 하기 적합한 형태로 표현하는 책임
-   목표
	-   책임을 분리했기 때문에 두 책임 중 하나에서 변경이 발생하더라도 다른 하나는 변경되지 않도록 소스 코드 의존성을 조직화 해야함
	-   새로 조직화한 구조에서는 행위가 확장될 때 변경이 발생하지 않음을 보장해야 함
-   달성하기 위한 과정
	-   처리과정을 클래스 단위로 분할
	-   클래스를 컴포넌트 단위로 구분
    ![OCP Example Map](ocp_1.png)
    ![OCP Example Map 2](ocp_2.png)
- **방향성은 오직 한방향으로만 교차**함
- 다른 어떤 요소를 변경해도 Interactor는 영향을 받지 않는 것을 주목
	- Interactor는 업무 규칙을 포함하기 때문
	- 애플리케이션의 가장 높은 수준의 정책을 포함
	- 보호의 계층구조가 ‘수준’ 이라는 개념을 바탕으로 생성되는 것을 주목
		- Interactor는 가장 높은 수준
		- View는 가장 낮은 수준의 개념 중 하나
- **FinancialDataGateway** 인터페이스는 FinancialReportGenerator와 FinancialDataMapper 사이에 위치해 **의존성 역전을 통해 방향성을 제어**하는 역할을 함
- **FinancialReportRequester** 인터페이스는 FinancialReportController가 Interactor 내부에 대해 많이 알지 못하도록 하는 **정보은닉 역할**을 함

### 9. LSP: 리스코프 치환 원칙

- 1988년 바바라 리스코프에 의해 정의된 원칙
- S 타입 객체 o1 각각에 대응하는 T 타입 객체 o2가 있고, T 타입을 이용해서 정의한 모든 프로그램 P에서 o2의 자리에 o1을 치환하더라도 P의 행위가 변하지 않는다면 S는 T의 하위 타입이다
- 상속할 때 하위타입으로 적절한지를 판단하는 원칙이 될 수도 있음
    - Rectangle의 하위 타입으로 Square은 적절하지 않음
        - Square는 높이와 너비가 반드시 함께 변경되지만, Rectangle은 높이와 너비가 독립적이기 때문
- 치환 가능성을 조금이라도 위배하면 시스템 아키텍처가 오염되기 때문에 항상 주의할 것
- 아키텍처 수준까지 LSP는 확장할 수 있고, 반드시 확장해야만 한다

### 10. ISP: 인터페이스 분리 원칙

![ISP wrong example](isp_0.png)
- 다수의 사용자가 OPS 클래스의 오퍼레이션을 사용하지만, User1은 op1, User2은 op2, User3은 op3 만 사용하는 경우가 있다고 한다
- 전혀 사용하지 않는 코드 에도 의존하게 되는 상황이 발생함
    → Operation을 인터페이스 단위로 분리하여 해결
![ISP right example](isp_1.png)
- **필요 이상으로 많은 것을 포함하는 모듈에 의존하는 것은 해롭다는 우려가 들어있는 원칙**
    - 불필요한 소스코드 의존성을 만들어 불필요한 재컴파일과 재배포를 강제함

### 11. DIP: 의존성 역전 원칙

- ‘유연성이 극대화된 시스템’ 이란 소스코드 의존성이 추상(abstraction)에 의존하며 구체(implementation)에는 의존하지 않는 시스템이라는 원칙
- 자바 같은 정적 타입 언어에서 이는 use, import, include 구문은 오직 인터페이스나 추상 클래스 같은 추상적인 선언만을 참조해야함을 의미
	- 구체적인 대상에는 절대로 의존해서는 안됨
- 규칙으로 보기에는 확실히 비현실적인 부분이 있음
	- 소프트웨어 시스템이라면 구체적인 많은 장치에 의존하기 때문
		- 의존하지 않도록 피해야하는 것
			- 변동성이 큰 구체적 요소(ex. 개발자가 열심히 개발하는 중이라 자주 변경될 수 밖에 없는 모듈들)
- 안정적인 추상화
	- 구현체들을 바꾸면 변경이 필요가 없지만, 인터페이스를 변경하면 변동을 해야한다
	- 뛰어난 소프트웨어 설계자와 아키텍트라면 인터페이스의 변동성을 낮추기 위해 노력해야 함
- 코딩 실천법
	- 변동이 큰 구체 클래스를 참고하지마라. 대신 추상 인터페이스를 참조하라. 이 규칙은 객체 생성 방식을 강하게 제약 하며, 일반적으로 추상 팩토리를 사용하도록 강제함
	- 변동성이 큰 구체 클래스로 부터 파생하지 말라 (이전 규칙의 따름정리)
	- 구체함수를 오버라이드 하지 말라. 대체로 구체함수는 소스코드 의존성을 필요로 하기 때문에 의존성을 제거할 수 없으니 그 의존성을 상속하게 된다
	- 구체적이며 변동성이 크다면 절대로 그 이름을 언급하지 말라
- 이 규칙을 준수 하려면 변동성이 큰 구체적인 객체는 특별히 주의해서 생성해야 함
	- 대다수 객체 지향 언어에서 **이처럼 바람직하지 못한 의존성을 처리할 때 추상 팩토리를 사용**하곤 함
	- 예시
        ![DIP](dip.png)
- 곡선은 아키텍처의 경계
	- 구체적인 것들로부터 추상적인 것들을 분리
	- 위쪽을 추상 컴포넌트, 아랫쪽을 구체 컴포넌트로 나누게 됨
	- 추상 컴포넌트는 고수준의 업무규칙, 구체 컴포넌트는 업무규칙을 다루기 위한 세부사항 포함
	- 구체 컴포넌트에는 구체적인 의존성이 하나 있음 (ServiceFactory ← ServiceFactoryImpl)
		- DIP를 위배하지만, 일반적인 일임
		- DIP 위배를 모두 없앨수 없기 때문에 적은 수의 구체 컴포넌트로 DIP를 위배하는 클래스를 모으는 것이 중요함

## 4부. 컴포넌트 원칙

- SOLID 원칙이 벽과 방에 벽돌을 배치하는 방법을 알려줬다면, 컴포넌트 원칙은 빌딩에 방을 배치하는 방법을 설명함
- 소프트웨어 **컴포넌트**가 무엇인지, **컴포넌트를 구성하는 요소**는 무엇인지, **컴포넌트를 결합하여 시스템을 구성하는 방법**은 무엇인지 논의

### 12. 컴포넌트

- 컴포넌트는 **배포 단위**
- **시스템의 구성 요소로 배포할 수 있는 가장 작은 단위**
	- jar(java), gem(ruby), dll(.net)
- 컴포넌트 배포 형태
	- 컴포넌트를 묶어서 .war 파일와 같은 단일 아카이브로 만들 수 있음
	- 혹은 .jar, .dll 같이 동적으로 로드할 수 있는 플러그인이나, .exe 파일로 만들어서 독립적으로 배포할 수 있음
- 컴포넌트가 어떤 형태로 배포되든, **잘 설계된 컴포넌트라면 반드시 독립적으로 배포 가능한, 따라서 독립적으로 개발 가능한 능력을 갖춰야 함**

### 13. 컴포넌트 응집도

- 어떤 클래스를 어떤 컴포넌트에 포함시켜야 할까?
	- 컴포넌트 응집도가 높은 방향으로
- 컴포넌트 응집도에 관한 세 가지 원칙
1. REP(Reuse/Release Equivalence Principle): 재사용 등가 원칙
	- 재사용의 단위는 릴리스의 단위와 같다
	- 소프트웨어 설계 관점
		- 단일 컴포넌트는 응집성 높은 클래스와 모듈들로 구성되어야 함을 의미
			- 중요한 테마나 목적을 서로 공유하는 모듈로 구성해야 함
	- 제작자/사용자 관점
		- 하나의 컴포넌트로 묶인 클래스와 모듈은 릴리스 번호가 같다
		- 소프트웨어 컴포넌트가 릴리스 절차를 통해 추적 관리를 하지 않거나 릴리스 번호가 부여되지 않는다면 해당 컴포넌트를 재사용하고 싶어도 할 수 없고, 하지도 않을 것임
	- 고로 동일한 릴리스 단위로 컴포넌트를 구성하는 것이 이치에 맞다
		- 이치에 맞다는 말은 권위 있는 척하는 것에 불과함
		- 하지만 원칙 자체는 중요함
			- 이 원칙을 어기면 쉽게 발견할 수 있기 때문
		- 이러한 원칙의 약점은 CCP, CRP의 강점을 통해 보완할 수 있음
2. CCP(Common Closure Principle): 공통 폐쇄 원칙
	- 동일한 이유로 동일한 시점에 변경되는 클래스를 같은 컴포넌트로 묶어라
	- 클래스 수준의 원칙인 SRP를 컴포넌트 관점에서 강조한 원칙
	- OCP와도 밀접하게 연관되어 있음
		- 변경이 필요한 요구사항이 발생했을 때, 그 변경이 영향을 주는 컴포넌트들이 최소한으로 한정될 가능성이 높아지는 원칙
3. CRP(Common Reuse Principle): 공통 재사용 원칙
	- 컴포넌트 사용자들을 필요하지 않는 것에 의존하게 강요하지 말라
	- 클래스 수준의 원칙인 ISP의 연장이라고 볼 수 있음
	- 같이 재사용되는 경향이 있는 클래스와 모듈들은 같은 컴포넌트에 포함해야 한다고 말함
	- 컴포넌트에 속한 클래스들은 더 작게 그룹지을 수 없음
		- 그 중 일부만 독립적일 수 없음
	- 컴포넌트 응집도에 대한 균형 다이어그램
		- 응집도에 관한 세 원칙은 서로 상충됨
			- REP, CCP는 포함 원칙 → 컴포넌트를 더 크게 만듬
			- CRP는 배제 원칙 → 컴포넌트를 더욱 작게 만듬
	- 세 원칙을 조정하면서 균형을 찾아야 함
    ![Component Triangle](component_triangle.png)
- 오로지 REP, CRP에만 중점을 두면 사소한 변경이 생겼을 때 너무 많은 컴포넌트에 영향을 미침
- CCP와 REP에만 집중하면 과도한 릴리스가 너무 빈번해짐
- 시간이 흐르면서 주의를 기울이는 부분을 변경해야 한다는 것을 알아야 함
	- 프로젝트 초기에는 CCP가 REP보다 훨씬 더 중요한데, 개발 가능성이 재사용성보다 더욱 중요하기 때문
	- 일반적으로 프로젝트는 삼각형의 오른쪽에서 시작해서, 성숙해지면 점점 왼쪽으로 이동하게 된다
- 과거에는 응집도에 대한 우리의 인식 수준이 매우 단순 했음
	- 모듈은 단 하나의 기능만 수행해야지!
- 하지만 **컴포넌트 응집도의 세 가지 원칙은 응집도가 가질 수 있는 훨씬 복잡한 다양성을 설명**함
	- **컴포넌트를 구성할 때, 재사용성과 개발가능성이라는 상충하는 힘을 반드시 고려**해야 함
	- 또한, 이 힘은 유동적이기 때문에, 현재 잘 맞게 분배 했더라도, 내년이 되면 맞지 않을 수 있다

### 14. 컴포넌트 결합

- 컴포넌트 사이의 관계를 설명하는 세 가지 원칙
1. ADP(Acyclic Depedency Principle): 의존성 비순환 원칙
2. SDP(Stable Dependency Principle): 안정된 의존성 원칙
3. SAP(Stable Abstraction Principle): 안정된 추상화 원칙

1. **의존성 비순환 원칙(ADP)**

    > 컴포넌트의 의존성 그래프에 순환이 있어서는 안 된다
	
- 어느 컴포넌트에서 시작하더라도 의존성 관계를 따라가면서 최초의 컴포넌트로 되돌아갈 수 없음
- 즉, 비순환 방향 그래프가 되어야함(DAG, Directed Acyclic Graph)
- 여러 명이서 같은 모듈을 작업하기 때문에 의존성 순환이 발생하는 경우가 있는 경우를 막아야 한다
- 해결 방법
- 주단위 빌드 ⇒ 병합에 너무 오랜 시간이 걸리기 때문에 패스
- 개발 환경을 릴리스 가능한 컴포넌트 단위로 분리하기
	- 어떠한 팀도 다른 팀에 좌우되지 않기 때문에 널리 사용됨
	- 이 절차가 성공적으로 동작하려면?
		- 의존성 구조를 반드시 관리해야 함
	- 구성요소 간 의존성을 파악하고 있으면 시스템을 빌드하는 방법을 알 수 있음
- 예시
- Presenters 컴포넌트를 담당하는 팀이 컴포넌트의 새로운 릴리스를 만들면 영향을 받는 팀은 (화살표를 거꾸로 따라가봤을 때) View, Main을 만드는 팀 밖에 없음
- Main은 어디에도 영향을 받지 않음
- Presenters 컴포넌트를 만드는 개발자가 이 컴포넌트를 테스트 하려고 한다면 사용 중인 Interactors 와 Entities를 이용해서 Presenters를 테스트, 빌드하면 된다
- 시스템 전체를 릴리스 할 때는 Entities → Database, Interactors → Presenters, Authorizer → View, Controllers → Main의 순서로 테스트 후 릴리스 하면 된다
![ADP 1](component_adp1.png)
-   의존성 순환이 발생하면 생기는 영향
-   Database 컴포넌트를 릴리스하려면 Entities 컴포넌트 뿐만 아니라 Entities 컴포넌트는 Authorizer에 의존하므로 Authorizer, 또 연쇄작용으로 Interactors까지 테스트 해야한다
-   Entities, Authorizer, Interactors가 하나의 거대한 컴포넌트가 되어버림
-   Entities, Authorizer, Interactors 각각을 테스트 할 때도 다른 컴포넌트 역시 테스트 해야 함
	-   어떤 순서로 빌드해야 하는지도 알 수 없게 됨
![ADP 2](component_adp2.png)
-   의존성 순환 끊는 방법
	1.  의존성 역전 원칙 적용
		-   Entities 내의 User가 필요로 하는 Permission Interface를 만들어 의존성 역전 시킴
![ADP 3](component_adp3.png)
		2. 양쪽 모두 의존하는 새로운 컴포넌트 생성
				-   Entities와 Authorizer가 모두 의존하는 새로운 컴포넌트 생성
![ADP 4](component_adp4.png)
-   두번째 해결책이 시사하는 바
-   요구사항이 변경되면 컴포넌트 구조도 변경될 수 있음! ⇒ Jitters(흐트러짐)
-   애플리케이션이 성장함에 따라 컴포넌트 의존성 구조는 서서히 흐트러지며 또 성장함
-   지금까지 논의로 깨달을수 있는 점
-   컴포넌트 구조는 하향식으로 설계될 수 없음
	-   컴포넌트는 시스템에서 가장 먼저 설계할 수 있는 대상이 아니며, 오히려 시스템이 성장하고 변경될 때 함께 진화함
	-   오히려 아무런 클래스도 설계하지 않은 상태에서 컴포넌트 의존성 구조를 설계하려고 시도한다면 상당히 큰 실패를 맞볼 수 있음
		-   아무것도 없으니 공통폐쇄에 대해 그다지 많이 파악하지 못하고 있고, 재사용 가능한 요소로 알지 못하며, 컴포넌트 설계할 때 거의 확실히 순환 의존성이 발생할 것이기 때문
-   컴포넌트 의존성 다이어그램은 기능과 전혀 관련이 없다
	-   오히려 애플리케이션의 빌드 가능성, 유지보수성을 보여주는 지도
		-   구현과 설계가 이뤄지는 프로젝트 초기에 모듈 들이 점차 쌓이기 시작하면서 ‘숙취증후군’ 을 겪지 않기 위해 의존성 관리에 대한 요구가 점차 늘어나게 됨
		-   변경되는 범위가 시스템의 가능한 한 작은 일부로 한정 되기를 원함
		-   SRP와 CCP에 관심을 갖기 시작하고, 이를 적용해 함께 변경되는 클래스는 같은 위치에 배치 되도록 만듬

2.  **안정된 의존성 원칙(SDP)**
    
    > 더 안정된 쪽에 의존 하라
    
-   변경이 쉽지 않은 컴포넌트가 변동이 예상되는 컴포넌트에 의존하게 만들어서는 절대로 안됨
	-   설계는 결코 정적일 수 없고 변경은 불가피 함 ⇒ 컴포넌트 중 일부는 변동성을 지니도록 설계됨
	-   변경이 쉽지 않은 컴포넌트가 변동성이 큰 컴포넌트에 의존하게 되면, 결국 변동성이 큰 컴포넌트도 변경이 어려워짐
-   안정성이란?
	-   변경을 만들기 위해 필요한 작업량이 많다
	-   소프트웨어 컴포넌트를 안정하게 만드는 방법 → 다른 컴포넌트가 해당 컴포넌트에 의존하게 만듬
	-   컴포넌트 안쪽으로 들어오는 의존성이 많아지면 상당히 안정적임
		-   사소한 변경이라도 의존하는 모든 컴포넌트를 만족 시키며 변경 하려면 상당한 노력이 들기 때문
	-   안정된 컴포넌트
		-   안쪽으로 들어오는 의존성이 많음
		-   X는 독립적
        ![SDP 1](component_sdp1.png)
-   불안정한 컴포넌트
	-   어떤 컴포넌트에도 의존하지 않음
	-   Y는 의존적
        ![SDP 2](component_sdp2.png)
	-   안정성 지표
		-   컴포넌트의 안정성은 컴포넌트로 들어오고 나가는 의존성의 개수로 판단
		-   Fan-in: 안으로 들어오는 의존성. 컴포넌트 내부의 클래스에 의존하는 컴포넌트 외부 클래스의 개수
		-   Fan-out: 바깥으로 나가는 의존성. 컴포넌트 외부 클래스에 의존하는 컴포넌트 내부 클래스의 개수
		-   $I$ (불안정성, Instability) : $I = Fanout / (Fanin+Fanout)$
			-   [0,1] 범위, 0일 때 최고로 안정된 컴포넌트
	-   SDP에서 $I$ 지표는 의존성 방향으로 갈수록 $I$ 지표 값이 감소해야 함
	-   모든 컴포넌트가 안정되어야 하는가?
		-   최고로 안정적인 시스템이라면 변경이 불가능함 ⇒ 소프트웨어 설계에서 원하는 방향이 아님
		-   컴포넌트 구조를 설계할 때 기대하는 것: (불안정한 컴포넌트 + 안정된 컴포넌트) 가 존재하는 상태
		-   안정적인 구조
			-   다음처럼 불안정한 컴포넌트를 관례적으로 위로 배치하는데, 이는 위로 향하는 화살표가 있으면 SDP를 어기는지 확인할 수 있기 때문에 유용함
		![SDP 3](component_sdp3.png)
	-   안정적인 구조를 변경이 발생하는 컴포넌트에 의존하게 만듬 → SDP 위반
![SDP 4](component_sdp4.png)
-   어떻게 해결하는가?
	-   DIP 사용
![SDP 5](component_sdp5.png)
-   오로지 인터페이스만 포함하는 컴포넌트는 이상하지 않은가?
	-   전혀 아님. 정적 타입 언어를 사용할 때 이 방식은 상당히 흔하게 쓰임
	-   상당히 안정적이며, 덜 안정적인 컴포넌트가 의존할 수 있는 이상적인 대상
	 
3. **안정된 추상화 원칙(SAP)**
    
    > 컴포넌트는 안정된 정도만큼만 추상화 되어야 한다
    
    -   시스템에는 자주 변경해서는 절대로 안되는 소프트웨어도 있음 → 고수준 정책
        -   반드시 안정된 컴포넌트($I=0$)에 위치 해야함
    -   이로 발생하는 문제
        -   정책을 포함한 소스코드는 안정적이기 때문에 소스코드를 수정하기 어려워 짐
    -   안정된 상태이면서 동시에 충분히 대응할 수 있을 정도로 유연하게 만드는 방법은?
        -   추상클래스를 이용한 OCP 활용
    -   안정된 추상화 원칙
        -   안정성과 추상화 정도 사이의 관계를 정의
        -   수칙
        1.  안정된 컴포넌트는 추상 컴포넌트여야 하며, 이를 통해 안정성이 컴포넌트를 확장하는 일을 방해해서는 안 된다
        2.  불안정한 컴포넌트는 반드시 구체 컴포넌트 여야 함
        -   이상적인 컴포넌트라면 반드시 인터페이스와 추상 클래스로 구성되어 쉽게 확장할 수 있어야 함
            -   유연성 확보 및 아키텍처 제약을 완화
        -   SDP, SAP는 컴포넌트에 대한 DIP 원칙임
    -   추상화 정도 측정
        -   $N_c$ : 컴포넌트의 클래스 개수
        -   $N_a$ : 컴포넌트의 추상클래스와 인터페이스 개수
        -   $A(=Abstraction)$ : 추상화 정도
            -   $A = N_a/N_c$
        -   [0,1] 값을 가짐
        -   0일 때는 추상클래스가 하나도 없음, 1일 때는 오로지 추상클래스만 존재한다는 의미
-   안정성과 추상화 정도 사이의 관계
    -   안정성과 추상화 정도를 그래프로 나타낸 주계열(Main Sequence)로 판단할 수 있음
        ![SAP 1](component_sap1.png)
    -   (0,1): 최고로 안정적이며 추상화된 컴포넌트
    -   (1,0): 최고로 불안정하며 구체화된 컴포넌트
    -   배제할 구역을 찾게 도와주는 그래프
        -   모든 컴포넌트가 (0,1), (1,0)에 위치할 수 없으므로 컴포넌트가 위치할 수 있는 합리적인 지점을 찾는 그래프
    -   고통의 구역
        -   매우 안정적이고 구체적인 컴포넌트
        -   뻣뻣하기 때문에 바람직하지 않고, 그때문에 배제 해야하는 컴포넌트
        -   변동성이 거의 없는 경우 배제하지 않아도 됨
            -   ex) String component
        -   변동성이 있는 (내가 짠) 컴포넌트만 문제가 되기 때문에 배제해야 함
        -   어쩔 수 없이 위치하는 경우
            -   데이터베이스 스키마
    -   쓸모없는 영역
        -   누구도 의존하지 않지만 추상적 이기 때문에 쓸모가 없음
    -   가장 이상적인 지점
        -   주계열의 종점
        -   하지만 모든 컴포넌트가 완전히 추상적이거나 오나전히 안정적일 수 없음
            -   이런 경우는 주계열 바로 위 또는 가깝게 위치할 때 가장 이상적임
    -   주계열과의 거리
        -   $I, A$에 이어 또다른 지표
        -   $D^4$ : $D=|A+I-1|$
        -   [0,1] 범위의 값
        -   0이면 주계열 바로 위에 위치하고, 1이면 주계열에서 가장 멀리 위치함
    -   주계열을 이용해 할 수 있는 일
        -   주계열에 대체로 일치하도록 설계되었는지 확인
        -   설계를 통계적으로 분석
            -   표준편차에서 벗어난 지역을 확인해볼 수 있음
        ![SAP 2](component_sap2.png)
        -   컴포넌트의 D값을 시간에 따라 그려볼 수 있음
            -   의존성이 어떻게 변해왔는지 확인 가능
        ![SAP 3](component_sap3.png)
    -   지표는 그저 임의로 결정한 기준이기 때문에 불완전하다는 것을 항상 인지하자

## 5부. 아키텍처

### 15. 아키텍처란?

-   소프트웨어 아키텍트
    -   프로그래머이며, 앞으로도 프로그래머로 남는다
    -   고수준의 문제에 집중해야 한다는 거짓말에 절대 속아 넘어가서는 안된다
        -   다른 프로그래머만큼 코드를 많이 작성하지 않을 수 있지만, 코드와 동떨어져서는 안된다
    -   소프트웨어 아키텍트는 최고의 프로그래머이며, 앞으로도 계속 프로그래밍 작업을 맡을 뿐 아니라 동시에 나머지 팀원들이 생산성을 극대화 할 수 있는 설계를 하도록 방향을 이끌어야 함
    -   프로그래밍 작업을 계속 해야하는 이유는, 발생하는 문제를 경험해보지 않는다면 다른 프로그래머를 지원하는 작업을 제대로 수행할 수 없기 때문
-   소프트웨어 아키텍처
    -   시스템을 구축했던 사람들이 만들어낸 시스템의 형태
    -   1.  컴포넌트로 분할하는 방법, 2) 분할된 컴포넌트를 배치하는 방법, 3) 컴포넌트가 서로 의사소통하는 방식에 따라 정해짐
    -   이 시스템의 형태는 아키텍처 안에 담긴 **소프트웨어 시스템이 쉽게 개발, 배포, 운영, 유지보수 되도록 만들어져야 함**
-   시스템 아키텍처는 시스템의 동작 여부와는 거의 관련이 없음
    -   형편 없는 아키텍처를 갖춘 시스템은 수없이 많지만, 그런대로 잘 동작하기 때문. 이런 경우 운영보다는 배포, 유지보수, 개발 과정에서 문제가 생김
    -   제대로 동작하도록 지원하는 데 아무런 역할을 하지 않는다는 말이 아님
        -   동작하게 하는 것은 매우 중요하지만, 이 역할은 수동적이며 피상적인 것이지, 능동적이거나 본질적인 것은 아님
        -   아키텍처 선택지에 행위가 끼치는 영향은 매우 적음
-   아키텍처의 주된 목적
    -   시스템의 생명주기를 지원 하는 것
    -   시스템의 수명과 관련된 비용은 최소화하고, 프로그래머의 생산성을 최대화 하는데 있음
    -   좋은 아키텍처는 시스템을 쉽게 이해하고, 개발하며, 유지보수하고, 배포하게 해줌

1.  **개발**
    -   개발하기 힘든 시스템이라면 수명이 길지도 않고 건강하지도 않을 것임 ⇒ 시스템 아키텍처는 시스템을 쉽게 개발할 수 있도록 뒷받침 해야함
    -   팀 구조가 다르다면 아키텍처 관련 결정에서도 차이가 남
        -   소규모 팀: 모노리틱 아키텍처 되기 쉬움
        -   대규모 팀: 컴포넌트별 분리 되야 프로젝트 진전이 있음
2.  **배포**
    -   소프트웨어 시스템이 사용될 수 있으려면 반드시 배포할 수 있어야 함
    -   배포 비용이 높을 수록 시스템의 유용성이 떨어짐
    -   따라서, 소프트웨어 아키텍처는 시스템을 단 한 번에 쉽게 배포할 수 있도록 만드는 데 목표를 두어야 함
    -   개발하기 쉬워 초기 개발 단계에서 배포 전략을 고려하지 않으면 후에 배포하기 상당히 어려운 아키텍처가 만들어 짐
        -   예로, 마이크로 아키텍처를 사용했을 때 컴포넌트 경계가 뚜렷해지고 인터페이스가 대체로 안정화 되므로 시스템을 쉽게 개발할 수 있을지 모르지만, 배포 시기가 되면 너무 많이 늘어난 마이크로서비스 때문에 배포가 어려울 것임. 또한, 서로 연결하기 위해 설정하고 작동 순서를 결정하는 과정에서 오작동이 발생할 원천이 스며들 수 있음
        -   처음부터 더 적은 서비스를 사용하고, 서비스 컴포넌트와 프로세스 수준의 컴포넌트를 하이브리드 형태로 융합하며, 좀 더 통합된 도구를 사용하여 상호 연결하면 배포 문제를 어느정도 해결할 수 있었음
3.  **운영**
    -   아키텍처가 개발, 배포, 유지보수에 미치는 영향보다 운영에 미치는 영향력이 적음
    -   아키텍처가 비효율적이라도, 단순히 스토리지와 서버를 추가하는 것 만으로도 제대로 동작하게 만들 수 있음
        -   하드웨어는 값싸고 인력은 비싸다 ⇒ 운영을 방해하는 아키텍처가 개발, 배포, 유지보수를 방해하는 아키텍처보다는 비용이 덜 들어간다는 의미
    -   비용 공식 관점에서 개발, 배포, 유지보수 쪽의 중요도가 더 높다는 의미이지 운영 용이성이 중요하지 않은 것은 절대 아님
        -   좋은 소프트웨어 아키텍처는 시스템을 운영하는 데 필요한 요구를 알려줌
        -   즉, 시스템 아키텍처가 개발자에게 시스템의 운영방식을 잘 드러내 준다
        -   시스템 아키텍처는 유스케이스, 기능, 시스템의 필수 행위를 일급 엔티티로 격상시키고, 이들 요소가 개발자에게 주요 목표로 인식되도록 해야 함 ⇒ 시스템을 이해하기 쉬워지며, 따라서 개발과 유지보수에 큰 도움이 됨
4.  **유지보수**
    -   소프트웨어 시스템에서 비용이 가장 많이 들어가는 부분
    -   유비 보수 중 가장 큰 비용: 탐사(spelunking)와 이로 인한 위험부담
        -   탐사: 기존 소프트웨어에 새로운 기능을 추가하거나 결함을 수정할 때, 소프트웨어를 파헤쳐서 어디를 고치는 게 최선인지, 그리고 어떤 전략을 쓰는게 최적일지를 결정할 때 드는 비용
        -   이러한 변경사항을 반영할 때 의도치 않은 결함이 발생할 가능성은 항상 존재하며, 이로 인한 위험부담 비용이 추가됨
    -   시스템을 컴포넌트로 분리하고, 안정된 인터페이스를 두어 서로 격리시키면 이 비용을 크게 줄일 수 있음
        -   추후에 추가될 기능에 대한 길을 밝혀 둘 수 있을 뿐 아니라 의도치 않은 장애가 발생할 위험을 크게 줄임

-   **선택사항 열어두기**
    -   소프트웨어는 앞서 언급한 것처럼 행위적 가치보다는 구조적 가치가 더 중요함(소프트웨어를 부드럽게 만드는 것이 바로 구조적 가치이기 때문)
        
    -   소프트웨어를 만드는 이유는 기계의 행위를 빠르고 쉽게 변경하는 방법이 필요하기 때문
        
        -   하지만 이러한 유연성은 시스템의 형태, 컴포넌트의 배치 방식, 컴포넌트가 상호 연결되는 방식에 상당히 크게 의존함
    -   소프트웨어를 부드럽게 유지하는 방법
        
        -   선택사항을 가능한 많이, 그리고 가능한 오랫동안 열어두는 것
        -   열어둬야할 선택사항? ⇒ 중요하지 않은 세부사항!
    -   소프트웨어 시스템은 두 가지 구성요소로 분해할 수 있음
        
        1.  정책(policy)
            -   모든 업무규칙과 업무절차를 구체화
            -   시스템의 진정한 가치가 살아 있는 곳
        2.  세부사항(detail)
            -   사람, 외부 시스템, 프로그래머가 정책과 소통할 때 필요한 요소
            -   정책이 가진 행위에는 조금도 영향을 미치지 않음
            -   ex) 데이터베이스, 입출력 장치, 웹 시스템, 서버, 프레임 워크, 통신 프로토콜
    -   아키텍트의 목표
        
        ⇒ 정책을 가장 핵심적인 요소로 식별하고, 동시에 세부사항은 정책과 무관하게 만들 수 있는 형태의 시스템을 구축
        
        -   이를 통해 세부사항을 결정하는 일을 미루거나 연기할 수 있게 됨
        -   예시
            -   개발 초기에는 데이터베이스 시스템을 선택할 필요 없음. 고수준의 정책은 어떤 종류의 데이터베이스를 사용하는지 신경 써서는 안됨. 고수준의 정책을 데이터베이스가 관계형인지, 분산형인지, 계층형 인지, 파일형태인지 관련없이 만들어야 함
            -   개발 초기에는 웹서버를 선택할 필요가 없음. 고수준 정책은 자신이 웹을 통해 전달된다는 사실을 알아서는 안됨. HTML, AJAX, JSF 같은 웹 개발 기술들에 대해 고수준의 정책이 전혀 알지 못하게 만들면, 프로젝트 후반까지 어떤 종류의 웹을 사용할 것인지 결정하지 않아도 됨
            -   개발 초기에는 REST를 적용할 필요가 없음. 고수준의 정책은 외부 세계로의 인터페이스에 대해 독립적이어야 하기 때문. 마이크로서비스 프레임워크 또는 SOA 프레임워크도 적용할 필요 없음.
            -   개발 초기에는 의존성 주입 프레임워크를 적용할 필요가 없음. 고수준의 정책은 의존성을 해석하는 방식에 대해 신경써서는 안됨
        -   이러한 결정을 더 오래 참을 수 있다면, 더 많은 정보를 얻을 수 있고, 이를 기초로 제대로된 결정을 내릴 수 있게 됨
        -   또한 선택사항을 더 오랫동안 열어 둘 수 있다면 더 많은 실험을 해볼 수 있고 더 많은 것을 시도할 수 있음.
            -   다양한 데이터베이스를 후보로 두고 그 적용 가능성과 성능 검토 가능
        -   이미 세부사항을 결정 했더라도 아직 내려지지 않은 것 처럼 행동하며, 여전히 결정을 가능한 한 오랫동안 연기하거나 변경할 수 있는 형태로 시스템을 만들어야 함
        
        > 좋은 아키텍트는 결정되지 않은 사항의 수를 최대화한다
        

### 16. 독립성

-   좋은 아키텍처가 지원해야 하는 것
    1.  시스템의 유스케이스
    2.  시스템의 운영
    3.  시스템의 개발
    4.  시스템의 배포

1.  유스케이스
    -   시스템의 아키텍처는 시스템의 의도를 지원해야 한다는 의미
        -   만약, 시스템이 장바구니 애플리케이션이라면, 이 아키텍처는 장바구니와 관련된 유스케이스를 지원해야 함
    -   아키텍처의 최우선 관심사
    -   아키텍처는 반드시 유스케이스를 지원해야 함
    -   아키텍처는 시스템의 행위에 그다지 큰 영향을 주지 않는다고 하지 않았는가?
        -   행위와 관련하여 아키텍처가 열어 둘 수 있는 선택사항은 없음
        -   하지만 좋은 아키텍처가 행위를 지원하기 위해 할 수 있는 일 중에서 가장 중요한 사항은 행위를 명확히 하고 외부로 드러내며, 이를 통해 시스템이 지닌 의도를 아키텍처 수준에서 알아볼 수 있게 만드는 것
            -   장바구니 애플리케이션이 좋은 아키텍처를 갖춘다면, 이 애플리케이션은 장바구니 애플리케이션처럼 보일 것임
            -   즉, 해당 시스템의 유스케이스는 시스템 구조 자체에서 한눈에 드러날 것
                -   이들 행위는 일급 요소(first-class element)이며 시스템의 최상위 수준에서 알아볼 수 있으므로, 개발자가 일일이 찾아 해매지 않아도 됨
                -   이들 요소는 클래스이거나 함수 또는 모듈로서 아키텍처 내에서 핵심적인 자리를 차지할 뿐만 아니라, 자신의 기능을 분명하게 설명하는 이름을 가짐 ⇒ **소리치는 아키텍처**
2.  운영
    -   시스템의 운영 지원 관점에서 볼 때 아키텍처는 더 실질적이며 덜 피상적인 역할을 맡음
        -   시스템이 초당 100,000명의 고객을 처리해야 한다면, 아키텍처는 이러한 운영 작업을 허용할 수 있는 형태로 아키텍처를 구조화 해야함
    -   이러한 형태를 지원한다는 의미는 시스템에 따라 다양한 의미를 가짐
        -   어떤 시스템에서는 시스템의 처리 요소를 일련의 작은 서비스들로 배열하여, 서로 다른 많은 서버에서 병렬로 실행할 수 있게 만들어야 함을 의미일 수 있음
        -   다른 시스템에서는 경량의 수많은 스레드가 단일 프로세서에서 같은 주소 공간을 공유하도록 만든다는 의미일 수 있음
        -   어떤 시스템은 단일프로세서에서 실행되는 단순한 모노리틱 프로그램 정도의 의미일 수 있음
    -   뛰어난 아키텍트라면 열어 두어야하는 선택사항 중 하나
3.  개발
    -   아키텍처는 개발 환경을 지원하는 데 있어 핵심적인 역할을 수행함
        
    -   콘웨이의 법칙이 작용하는 지점
        
        -   콘웨이 법칙(Conway’s law)
        
        > 시스템을 설계하는 조직이라면 어디든지 그 조직의 의사소통 구조와 동일한 구조의 설계를 만들어 낼 것이다.
        
    -   많은 팀으로 구성되며 관심사가 다양한 조직에서는 각 팀이 독립적으로 행동하기 편한 아키텍처를 반드시 확보하여 개발하는 동안 팀들이 서로 방해받지 않도록 해야함
        
        -   그러기 위해서는 독립적으로 개발 가능한 컴포넌트 단위로 시스템을 분할할 수 있어야 함
4.  배포
    -   아키텍처는 배포 용이성을 결정하는데 중요한 역할을 함
    -   목표: 즉각적인 배포(immediate deployment)
    -   좋은 아키텍처는 꼭 필요한 디렉터리나 파일을 수작업으로 생성하게 내버려 두지 않는다
    -   좋은 아키텍처라면 시스템이 빌드 된 후 즉각 배포할 수 있도록 지원해야 함
        -   이런 아키텍처를 만들려면 시스템을 컴포넌트 단위로 적절하게 격리시켜야한다
        -   마스터 컴포넌트 역시 포함해야함

-   선택사항 열어 놓기
    -   좋은 아키텍처는 컴포넌트 구조와 관련된 이 관심사들 사이에서 균형을 맞추고, 각 관심사 모두를 만족 시킴
        
        -   현실에서는 이런 균형을 잡기 매우 힘들다
        -   모든 유스케이스를 알 수 없고, 운영에 따르는 제약사항, 팀 구조, 배포 요구사항도 알지 못하기 때문
        -   또한 시스템 생명주기의 한단계를 거쳐나갈 때마다 이러한 사항들이 변해 나가는 것도 제약사항
        -   하지만 몇 가지 아키텍처 원칙은 구현 비용이 비싸지 않고, 균형 잡는데 도움이 됨
        -   원칙
        1.  계층 결합 분리
            -   유스케이스를 전부 알지는 못하지만, 아키텍처 시스템의 기본적인 의도(ex. 장바구니 시스템, 자재 명세서 시스템, …)는 알고 있다는 것에서 출발
            -   아키텍트는 단일 책임 원칙과 공통 폐쇄 원칙을 적용하여, 그 의도의 맥락에 따라서 다른 이유로 변경되는 것들을 분리하고, 동일한 이유로 변경되는 것들은 묶는다
        2.  유스케이스 결합 분리
            -   유스케이스는 서로 다른 이유로 변경 됨 ⇒ 분리해야할 대상
                
            -   유스케이스는 UI의 일부, 애플리케이션 특화 업무 규칙의 일부, 애플리케이션 독립적 업무 규칙의 일부, 데이터베이스 기능의 일부 사용하므로 이를 각각 분리해야 함
                
                ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7b746eea-eaaa-488c-839a-0ffa64933ec8/Untitled.png)
                
            -   시스템에서 서로 다른 이유로 변경되는 요소들의 결합을 분리하므로 기존 요소에 지장을 주지 않고 새로운 유스케이스를 계속해서 추가할 수 있게 됨
                
            -   다른 이점
                
                -   개발 독립성
                    -   유스케이스의 결합이 분리되면 addOrder 유스케이스와 deleteOrder 유스케이스에 중점을 둔 팀이 개입할 가능성이 거의 없어짐
                -   배포 독립성
                    -   결합을 제대로 분리했다면 운영 중인 시스템에서도 계층과 유스케이스를 교체할 수 있음
                    -   새로운 유스케이스를 추가하는 일은 시스템의 나머지는 그대로 둔 채 jar파일이나 서비스 몇 개를 추가하는 것처럼 단순한 일이 됨
        3.  중복
            -   중복에도 종류가 있으므로 따져보고 중복을 줄여야함
            -   종류
                1.  진짜 중복
                2.  거짓 중복 혹은 우발적 중복
                    -   중복으로 보이지만 추후에 서로 다른 속도와 다른 이유로 변경됨
                    -   몇 년이 지나면 두 코드가 매우 달라짐
                    -   ex) 두 유스케이스의 화면 구조가 매우 비슷하다고 해서 모두 진짜 중복이 아니다 ⇒ 만약 통합한다면 추후에 다시 분리하느라 수고를 감수해야 함
        4.  계층/유스케이스 결합 분리
            
            -   다양한 수준에서 분리하기
            1.  소스 코드 수준 분리 모드
                -   소스 코드 모듈 사이 의존성을 제어
                -   이를 통해 하나의 모듈이 변하더라도 다른 모듈을 변경하거나 재컴파일 하지 않도록 만들 수 있음
                -   ex) Gem (Ruby)
                -   이 모드에서는 모든 컴포넌트가 같은 주소 공간에서 실행, 하나의 실행파일로 메모리에 로드 되고, 서로 통신할 때는 간단한 호출을 사용 ⇒ 모노리틱 구조
            2.  바이너리(배포) 수준 분리 모드
                -   배포 가능한 단위들 사이의 의존성을 제어할 수 있음
                -   한 모듈의 소스 코드가 변하더라도 다른 모듈을 재빌드하거나 재배포 하지 않도록 만들 수 있음
                -   많은 컴포넌트가 여전히 같은 주소 공간에 상주하며, 단순한 함수 호출을 통해 통신
                -   어떤 컴포넌트는 동일한 프로세서의 다른 프로세스에 상주하고, 프로세스 간 통신, 소켓, 또는 공유 메모리를 통해 통신할 수 있음
                -   결합이 분리된 독립된 파일로 만들어 독립적으로 배포할 수 있음
                -   ex) jar (Java), dll (.Net)
            3.  실행단위(서비스) 수준 분리 모드
                -   의존하는 수준을 데이터 구조 단위까지 낮출 수 있고, 패킷을 통해서만 통신하도록 만들 수 있음
                -   모든 실행 가능한 단위는 소스와 바이너리 변경에 대해 서로 완전히 독립적이게 됨
                -   ex) microservice, service
    -   초기에 적합한 분리모드를 찾기 어렵고, 프로젝트가 성숙해져 갈 수록 최적인 모드가 달라져 갈 수 있다는 것 명심하기

### 17. 경계: 선 긋기

-   소프트웨어 아키텍처 = 선(경계) 긋는 기술
-   경계: 소프트웨어 요소를 서로 분리하고, 경계 한편에 있는 요소가 반대편에 있는 요소를 알지 못하게 막음
-   선 중 일부는 프로젝트 수명 중 아주 초기에, 일부는 나중에 그려짐
    -   초기에 그어지는 선들은 가능한 한 오랫동안 결정을 연기시키기 위해, 그래서 이들 결정이 핵심적인 업무 로직을 오염시키지 못하게 만들려는 목적으로 쓰임
-   아키텍트의 목표: 시스템을 만들고 유지하는데 드는 인적자원을 최소화하는 것
    -   인적자원의 효율을 떨어트리는 요인? ⇒ 너무 일찍 결정한 결합(coupling)
    -   업무 요구사항(=유스케이스)와 아무련 관련 없는 결정
-   어떻게, 언제 선을 그을 것인가?
    -   데이터베이스는 업무규칙과 관련이 없으므로 반드시 선이 있어야 함
        
        -   interface를 implementation 하는 방식으로 구현
            
        -   BusinessRules은 Database를 몰라도 상관 없지만 Database는 BusinessRules 없이는 존재할 수 없다
            
            ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f3afc398-b32f-46ca-9a5a-c0b5144cb361/Untitled.png)
            
    -   GUI는 업무규칙과 관련이 없으므로 반드시 선이 있어야 함
        
        -   GUI 뒤에는 인터페이스를 조작하는 모델이 존재한다는 사실을 잊어버리지 마라
        
        ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e6c432da-0434-41b7-b311-d069f22ab95d/Untitled.png)
        
    -   데이터베이스는 GUI와 관련이 없으므로 반드시 선이 있어야 함
        
    -   앞의 원칙을 살펴보았을 때 소프트웨어를 작성하는 규칙이 보인다 ⇒ 플러그인 아키텍처
        
        ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8c1bc98e-70b3-4acc-97ca-31cf6eb344b8/Untitled.png)
        
    -   유지보수가 쉬운 시스템 아키텍처를 확립할 수 있게 만드는 방법
        
    -   선택적이거나 또는 수많은 다양한 형태로 구현될 수 있는 나머지 컴포넌트로부터 핵심적인 업무 규칙은 분리되어 있음
        
-   결론: 핵심 업무 규칙을 중심으로 하여 나머지 컴포넌트(GUI, database)들을 배치하는 방식을 사용해야 한다
    -   DIP 와 SAP 를 응용한 것을 확인하자

### 18. 경계 해부학

-   경계의 형태 중 흔한 몇 가지

1.  엄격하게 구분되지 않은 형태
    -   가장 단순하며 흔한 형태
    -   함수와 데이터가 단일 프로세서에서 같은 주소 공간을 공유하며 그저 나름의 규칙에 따라 분리되어 있을 뿐임
    -   이전에 소스 수준 분리 모드로 정의함
    -   배포 관점에서 보면 단일체(monolith)라고 불리는 단일 실행 파일에 지나지 않음 = 경계가 드러나지 않음
    -   개발 관점에서는 다양한 컴포넌트를 개발하고 바이너리로 만드는 과정을 독립적으로 수행하게 할 수 있음
    -   단일체에서 컴포넌트 간 통신은 매우 빠르고 값싸다
    -   소스 수준에서 결합이 분리되면 경계를 가로지르는 통신이 상당히 빈번할 수 있음
    -   배포하는 일은 컴파일과 정적 링크 작업을 수반하므로, 대체로 이러한 시스템에서 컴포넌트는 소스 코드 형태로 전달됨
2.  배포형 컴포넌트
    -   아키텍처의 경계가 물리적으로 드러남
    -   동적 링크 라이브러리
    -   dll(.Net), jar(java), gem(ruby)
    -   이 바이너리 컴포넌트를 이대로 배포하면 따로 컴파일 하지 않고 바로 사용할 수 있음
    -   배포과정만 차이날 뿐 단일체와 통일함
    -   컴포넌트 간 통신은 함수 호출에 지나지 않으므로 값싸다
    -   쓰레드
        -   단일체, 배포형 컴포넌트 모두 사용할 수 있음
        -   실행계획과 순서를 체계화 하는 방법
3.  로컬 프로세스
    -   훨씬 강한 물리적 형태를 띠는 아키텍처 경계
    -   명령행이나 시스템 호출을 통해 생성
    -   동일한 프로세서 또는 하나의 멀티코어 시스템에 속한 여러 프로세서들에서 실행되지만, 각각 독립된 주소 공간에서 실행됨
4.  서비스
    -   물리적인 형태를 띠는 가장 강력한 경계
    -   프로세스로 일반적으로 명령행 또는 그와 동등한 시스템 호출을 통해 구동
    -   함수 호출에 비해 통신이 매우 느리다 ⇒ 주의를 기울여서, 가능하다면 빈번하게 통신하는 일을 피해야 함

### 19. 정책과 수준

-   소프트웨어 시스템 = 정책을 기술한 것
    -   각 입력을 출력으로 변환한 정책을 상세하게 기술한 설명서
-   소프트웨어 아키텍처는 정책을 신중하게 분리하고, 정책이 변경되는 양상에 따라 정책을 재 편성해야 함
-   동일한 이유로 동일한 시점에 변경되는 정책은 동일한 수준에 위치해야하고, 동일한 컴포넌트에 속해야 함
-   아키텍처 개발은 재편성된 컴포넌트들을 비순환 방향 그래프로 구성하는 기술을 포함
    -   정점(node): 동일한 수준의 정책을 포함하는 컴포넌트
    -   간선(edge): 컴포넌트 사이의 의존성
-   의존성 ⇒ 소스코드, 컴파일 타임 의존성
    -   import, using
-   수준
    -   입력과 출력까지의 거리
    -   입력과 출력 모두로부터 멀리 위치할 수록 정책의 수준은 높아짐
-   **데이터 흐름과 소스 코드의 의존성은 항상 같은 방향을 가리키지 않음을 이용**해야 한다
-   정책을 컴포넌트로 묶는 기준
    -   정책이 변경되는 방식에 달려있음
    -   SRP, CCP에 따르면 동일한 이유로 동일한 시점에 변경되는 정책은 함께 묶인다
    -   고수준 정책은 저수준 정책에 비해 덜 빈번하게 변경되고, 보다 중요한 이유로 변경되는 경향이 있음
-   좋은 아키텍처라면 각 컴포넌트를 연결할 때 의존성의 방향이 컴포넌트의 수준을 기반으로 연결되도록 만들어야 함 ⇒ 저수준 컴포넌트가 고수준 컴포넌트에 의존하도록 설계해야 함
    -   저수준 컴포넌트가 고수준 컴포넌트의 플러그인이 되어야한다는 관점으로 볼 수 있음
    -   모든 소스 코드 의존성의 방향이 고수준 정책을 향할 수 있도록 정책을 분리했다면 변경의 영향도를 줄일 수 있음

### 20. 업무 규칙

-   사업적으로 수익을 얻거나 비용을 줄일 수 있는 규칙 또는 절차
-   컴퓨터상으로 구현했는지와 전혀 상관 없음
-   핵심 업무 규칙(ex. 대출에 n% 이자 부과)과 핵심 업무 데이터(ex. 이자율, 대출 잔액, 지급 일정)은 본질적으로 결합되어 있기 때문에 이들을 하나의 유형으로 포함 ⇒ 엔티티(entity)
-   Entity
    -   컴퓨터 시스템 내부의 객체
    -   핵심 업무 데이터를 기반으로 동작하는 일련의 조그만 핵심 업무 규칙을 구체화
    -   핵심 업무 데이터를 직접 포함하거나, 핵심 업무 데이터에 매우 쉽게 접근할 수 있음
    -   업무 대표자로서 독립적으로 존재함
    -   데이터베이스, 사용자 인터페이스, 서드파티 프레임워크 등 세부사항에 대한 고려사항들로 오염 되어서는 절대 안됨
    -   꼭 객체 지향 언어를 사용하여 구현할 필요 없다
    -   유일한 요구사항은 핵심 업무 데이터와 핵심 업무 규칙을 하나로 묶어서 별도의 소프트웨어 모듈로 만들어야 한다는 것
-   Usecase
    -   자동화된 시스템이 동작하는 방법을 정의하고 제약함으로써 수익을 얻거나 비용을 줄이는 업무 규칙
    -   Entity 처럼 순수하지 않음
    -   사용자가 제공해야 하는 입력, 사용자에게 보여줄 출력, 그리고 해당 출력을 생성하기 위한 처리단계를 기술해야 함
    -   애플리케이션에 특화된 업무 규칙을 설명
    -   Entity 내부의 핵심 업무 규칙을 어떻게, 언제 호출할지 명시하는 규칙을 담음
        -   Entity가 어떻게 춤을 출지 Usecase가 제어함
    -   Usecase는 사용자 인터페이스를 정의하지 않음
        -   Usecase는 시스템이 사용자에게 어떻게 보이는지 설명하지 않음
        -   애플리케이션에 특화된 규칙을 설명하며, 이를 통해 사용자와 Entity의 상호작용을 규정함
        -   시스템에서 데이터가 들어오고 나가는 방식은 Usecase와 무관

### 21. 소리치는 아키텍처

### 22. 클린 아키텍처

### 23. 프레젠터와 험블 객체

### 24. 부분적 경계

### 25. 계층과 경계

### 26. 메인 컴포넌트

### 27. ‘크고 작은 모든' 서비스들

### 28. 테스트 경계

### 29. 클린 임베디드 아키텍처

## 6부. 세부사항

### 30. 데이터베이스는 세부사항이다

### 31. 웹은 세부사항이다

### 32. 프레임워크는 세부사항이다

### 33. 사례 연구: 비디오 판매

### 34. 빠져 있는 장

## 7부. 부록