# Preface

문제를 흠결없이 풀어냈느냐 보다 '다른 지원자보다 나은 답변을 했느냐'가 더 중요하다!

면접에서는 아무리 스펙이 좋더라도 결과를 내야한다.

'실제 문제'에 대비해야 하고, '실제 문제'를 놓고 연습하고, 그 패턴을 익혀야 한다. 이는 단순히 기존의 문제를 암기하는 것이 아니라, 새로운 알고리즘을 개발할 줄 아는 것을 말한다.

어려운 문제를 받았다고 해서 낙담할 필요 없다. 당신이 어려웠다면 다른 사람도 어려웠다.

---
# 1. 면접과정

## 평가항목

1. 분석 능력: 문제푸는 데 도움 받았나, 최적화를 얼마나 했나, 문제를 푸는데 시간이 얼마나 걸렸나, 디자인/설계를 할때에 문제의 체계를 제대로 세우고 다양한 방법에 대한 장단점에 대해 생각해봤는가
2. 코딩 능력: 알고리즘을 적절한 코드로 표현, 깔끔하고 잘 구성, 가능한 에러 생각, 코드 스타일
3. 기술적 지식 및 컴퓨터 과학 기본: 기본기가 출중한가
4. 경험: 기술적 결정 해본적 있는가, 도전적인 프로젝트를 해본적 있는가, 진취성, 결단성, 그 외 다른 중요요소를 내보인 적이 있는가
5. 문화와 얼마나 맞는지/ 의사소통 능력: 지원자 성격과 가치가 회사에 잘 맞는가

알고리즘 문제를 풀 때는 처음 세 가지 능력이 중요하다.

문제풀이 능력은 꽤 가치 있는 능력이므로, 개발하는 능력이 뛰어날 가능성이 크다는 것을 반증하는 것이다.

또한 기초적인 자료구조와 알고리즘 지식은 지원자를 평가하기에 괜찮은 proxy 라고 말한다.

---
# 2. 장막 너머

## 사전 면접(Screening Interview)

실제로 면접에 참여할 사람을 걸러내기 위한 것, 보통 전화로 이루어짐.

대면 면접만큼 어렵다.

회사 방문하기 전에 한 두번 하는 것이 보통.

기술적인 문제가 출제될지 여부를 잘 모르겠다면, 면접을 조율한 담당자에게 면접관 직위를 물어 보자.

## 대면 면접

보통 세 번에서 여섯 번 정도의 대면 면접, 이 가운데 한 번은 점심식사를 하면서 치러지기도 함


일주일 이상 걸린다면 구인 담당자에게 연락을 해봐야 한다. 답이 없다고 떨어진 것은 아니다. 가급적 송손하게 하라.

---
# 3. 특별한 상황에서의 면접

## 경력자

알고리즘 문제에 비중이 높을 수도 있고 아닐 수도 있다. 신입 지원자에게 알고리즘 문제를 물어본다면 그 회사는 경력자에게도 알고리즘 문제를 물어 볼 가능성이 크다. => 문제를 푸는 능력이 중요하다고 생각하기 때문.

시스템 디자인, 설계 관련 문제, 이력에 관련된 질문을 할 수 있다.

"가장 고치기 힘든 버그는 무엇이었나요?" 와 같은 질문에 풍부한 경험을 내세울 만한 답변을 해야 함.

## 스타트업

### 지원절차

구인 직종 리스트를 공개함.

연락을 취해 관심을 표하는 것만으로도, 여러분의 이력서를 읽어봐 줄 누군가를 찾을 가능성이 있다.

### 비자와 취업 승인

어려움. 여러 스타트업의 의뢰를 받아 일하는 전문 구인 리크루터(professional recruiter)를 찾아보거나, 아니면 좀 더 규모가 큰 스타트업으로 눈을 돌려야 함.

### 면접 과정

- 적합한 인성: 친근하고 호감가는 톤으로 대화를 진행하는 것이 아주 중요하다
- 기술: 특정한 프로그래밍 언어와 관련된 능력을 평가하려 함.
- 경력: 예전 경력에 관해 시시콜콜 묻는 경향이 있다.

---
# 4. 면접 전에

- 코딩할 수 있는 사람이어야 한다
- 영리한 사람이어야 한다

## 적절한 경험 쌓기

#### 학생이라면
- 큰 규모의 프로젝트 수업을 들으라: 실전 경험을 쌓을 수 있는 좋은 방법. 실생활과 관련성이 높을 수록 좋다
- 인턴 자리를 알아보라: 저학년일 때 꼭 인턴십 기회를 잡으라.
- 뭔가를 하라: 개인시간 프로젝트, 해커톤, 오픈 소스 프로젝트. 뭐든 코딩을 한다는 자체가 중요하다.

#### 직장인 이라면
- 코딩을 많이 할 수 있는 업무를 하라: 프로젝트 고를 때 대형 프로젝트로 고르고, 관련 기술을 많이 사용해볼 수 있게 하고, 최종적으로는 이력서의 한 두 꼭지로 넣을 수 있도록 하라
- 저녁과 주말을 활용 하라: 이력서에 '재미 삼아 만들어 본' 것이 있는 개발자 만큼 면접관에게 깊은 인상을 심어주는 사람도 없다

## 탄탄한 이력서 작성하기

오타는 절대 안된다.

영어권에서는 나이, 결혼 여부, 국적 등의 정보를 포함시키지 말아야 한다.

#### 적절한 이력서 길이

10년 미만인 경우 한 페이지로 만들고, 그 이상인 경우 1.5 ~ 2 페이지로 만들 수 있다.

이력서는 짧으면 짧을수록 인상에 남는다.

#### 고용 이력

각 직무별로, 무엇을 성취했는지 다음과 같은 방식으로 말하라

```
"Y" 를 구현해서 "X"를 성취했고, 그 결과 Z를 이루었다
```

```
분산 캐시를 구현해서 오브젝트 렌더링 시간을 75퍼센트 줄였고, 그 결과 로그인 시간을 10% 경감할 수 있었다
```

```
windiff에 기반한 새로운 비교 알고리즘을 구현한 결과, 평균 비교 정확도를 1.2에서 1.5로 개선했다
```

#### 프로젝트

가장 중요했던 프로젝트 2~4개를 적어야 한다.

세부사항은 필수가 아니므로, 언급하는게 좀 더 나을 경우에만 적으라.

자주성을 보여준다는 점에서, 대개 수업 프로젝트보다 독립된 프로젝트를 더 선호한다.

#### 소프트웨어

나열하는 것이 큰 문제는 아니지만, 이력서의 소중한 공간이 줄어들기 때문에 실익을 생각해서 결정하라.

#### 프로그래밍 언어

사용했던 모든 언어를 적되, 언어에 대한 숙련도도 함께 적자

```
프로그래밍 언어: 자바(전문가), C++(능숙), 자바스크립트(경험있음)
```

#### 낙인의 가능성에 대해 알고 있기

특정 언어를 사용하는 것이 낙인(stigma)이 될 수 있다

- 기업 언어
	- 기술적으로 탁월하다는 인상을 주기 힘들다
- 언어에 너무 몰입된 경우
	- 최고의 소프트웨어 엔지니어는 그들 자신을 특정 언어로 정의하지 않는다는 믿음이 있다
	- 회사가 어떤 것에 가치를 두는지 알고 있어야 대응할 수 있다
- 자격증
	- 어떤 경우에는 이력서에서 삭제할 필요가 있다
- 한 두 가지 언어만 알고 있을 경우
	- 능숙해지면 사용하는 언어가 많아질 것이다
	- 따라서 이력서에 표기된 능숙한 언어가 단 하나뿐이라면, 구인 담당자가 해당 지원자에 대해 아직 많은 문제를 경험해 보지 못한 사람으로 간주해 버릴 수 있다
	- 특정 기술에 대한 선호도가 너무 강하진 않을까하는 고민을 하게 할 수 있다

## 준비 절차
![[interview-process.png]]

---
# 5. 행동 문제

## 대비 요령

이력서에 표기된 프로젝트 칸의 구성 요소를 하나하나 살피면서 자세하게 이야기 할 수 있는지 확인하자. 다음 표를 채워보면 도움이 된다.

| 흔히 나오는 문제        | 프로젝트1 | 프로젝트2 | 프로젝트3 |
| ------------------  | --------- | --------- | --------- |
| 가장 도전적이었던 경험    |           |           |           |
| 실수 혹은 실패담        |           |           |           |
| 즐거웠던 것            |           |           |           |
| 리더십                |           |           |           |
| 팀원과의 갈등           |           |           |           |
| 남들과 다르게 행동했던 것  |           |           |           |

면접전에 표를 사용해서 공부하라. 각 이야기를 두 개의 키워드로 나타내면 공부하기도 기억하기도 쉬울 것이다.

세 개 정도의 프로젝트에 대해서는 자세히 말할 수 있어야 한다는 사실을 명심하라. 기술적인 부분에 대해서 깊이 있게 논의할 수 있어야 한다.

### 여러분의 단점은 무엇인가

실존하면서도 인정할 수 밖에 없는 단점을 이야기 하되, 그 단점을 극복하기 위해 어떻게 하고 있는지 강조하라.

```
때로는 세부사항을 놓칠 때가 있습니다. 그 덕에 일을 빨리 진행하지만 때로는 실수를 저지르기도 하죠. 그래서 저는 언제나 제가 한 일을 다른 사람이 검토하도록 합니다.
```

### 면접관에게는 어떤 질문을 해야하나

얼마나 양질의 질문을 던지느냐가 무의식적이든 의식적이든 면접관의 결정에 영향을 끼친다. 질문을 미리 준비해 둬야 한다.

#### 순수한 질문

실제로 궁금해하는 질문들

```
1. 테스터/개발자/프로그램 관리자 비율이 어떻게 되나요? 어떤 식으로 서로 협조합니까? 팀에서는 프로젝트 계획을 어떤 식으로 수립하나요?

2. 어떻게 이 회사에 오게 되었나요? 가장 도전적이었던 일은 무엇이었나요?
```

#### 통찰력을 보여줄 수 있는 질문

기술에 대한 지식과 이해도를 보여줄 수 있는 질문들

회사에 대한 사전 조사가 필요하다

```
1. X라는 기술을 쓰시는 걸 봤는데요. Y문제는 어떻게 해결하시나요?

2. 제품에서 Y대신 X 프로토콜을 쓰시는 이유는 무엇인가요? A, B, C 등의 장점이 있다는 것은 알고 있지만, D라는 이슈가 있어 사용하지 않는 회사들도 많다고 알고 있어서요.
```

#### 열정을 보여줄 수 있는 질문

새로운 것을 배우길 좋아하고, 회사에 많은 기여를 할 수 있는 사람으로 비춰질 수 있음

```
1. 저는 규모 확장성 문제에 관심이 많고 배우고 싶습니다. 회사 내에서 그에 관해 배울 기회가 있나요?

2. X 기술에 대해서는 잘 모르지만, 재미있는 해법이 될 것 같네요. 어떻게 동작하는지 잠시 설명해주실수 있으신가요?
```

## 기술적 프로젝트에 대한 이해

준비 과정 중 하나로, 두세 개의 프로젝트를 집중적으로 깊이 있게 알고 있어야 한다. 다음의 기준에 꼭 맞는 프로젝트를 선택할 수 있다면 더할 나위 없다

1. 단순히 많이 배웠던 것을 넘어서 도전적인 요소가 있었던 프로젝트
2. (이왕이면 핵심 부분에서) 중심 역할을 했던 프로젝트
3. 기술적으로 깊이 있는 이야기를 할 수 있는 프로젝트

위 기준으로 선택한 프로젝트에서, 여러분은 **_도전적인 면_**, **_실수_**, **_기술적 결정_**, **_기술의 선택(그에 대한 실익)_**, **_남들과는 다르게 할 수 있었던 것들_** 에 대해 이야기할 수 있어야 한다.

## 행동 질문에 대한 대처 요령

#### 구체적으로 답하고, 오만한 태도를 보이지 말라

구체적이라 함은, 사실을 전달만 하고 그 사실을 해석하는 것은 면접관에게 맡기는 것이다.

```
모든 어려운 부분은 제가 맡았습니다 (x)
```

여러분이 맡았던 도전적인 부분을 구체적으로 설명하는 것이 좋다

#### 세부사항은 최소한만 언급하라

그 문제에 정통하지 않은 면접관은 이해하기 어렵다.

세부사항은 줄이고 핵심적인 부분만 언급하도록 하라. 아니면 프로젝트에 끼친 최소한의 영향력만 설명하도록 노력하라.

면접관이 더 파고들 수 있는 여지는 항상 남겨두는 것이 좋다.

```
가장 보편적인 사용자 행위 패턴을 검사하고 Rabin-Karp 알고리즘을 적용하여, 90% 정도의 경우에 대해 검색 시간을 O(n) 에서 O(log n) 으로 줄이는 알고리즘을 설계하였습니다. 궁금하시다면 좀 더 자세하게 말씀드리도록 하겠습니다.
```

#### 팀이 아닌 여러분 자신에 초점을 맞춰라

'우리 팀' 이라는 이야기를 많이 하면 면접 후 지원자가 어떤 영향을 끼친 인물어있는지 거의 생각나지 않고 결국엔 별다른 영향력이 없었다고 결론 내릴 것이다

#### 구조적인 답변을 내놓으라

##### 1) 유용한 정보 우선(nugget first)

서두에 답변의 내용을 간결히 요약하는 방법을 말한다

면접관의 주의를 끌 뿐 아니라 여러분이 하는 이야기가 무엇인지 명확하게 만든다.

답변의 요지를 명확하게 해주기 때문에, 여러분 자신의 답변에 더 집중하도록 도와줄 것이다.

예시

_큰 변화를 이끌어 내기 위해 사람들을 설득해야 했던 상황에 대해서 이야기해 보세요_
```
학부생들이 자기 과목을 직접 가르치도록 학교 당국을 설득했던 상황에 대해 이야기해 드리죠. 제가 다니던 학교는 처음에는...
```

##### 2) S.A.R(Situation, Action, Result)

상황을 요약하는 것으로부터 출발하여, 여러분이 어떤 행동을 했는지를 설명하고, 그 결과를 기술하는 접근법

상황과 결과는 간결해야 한다.

상황, 행위, 결과를 명료하게 표현하면 며접관은 여러분이 공헌한게 무엇인지 왜 그것이 중요했는지 쉽게 알아차릴 수 있을 것이다.

다음 표를 참고하라

|         | 핵심 | 상황 | 취한행동 | 그에 대한 결과 | 말하고자 하는 것 |
| ------- | ---- | ---- | -------- | -------------- | ---------------- |
| 이야기1 |      |      |          |                |                  |
| 이야기2        |      |      |          |                |                  |

예시
_팀원들과 소통하는 과정에서 만난 도전적 문제에 대해 설명해 보세요._

```
- 상황(S): 제가 수행하고 있던 운영체제 프로젝트에 인원 세 명이 추가되었습니 다.두 명은 아주 잘 해나갔는데, 한 명은 그다지 성과가 좋지 않았습니다. 회의간에는 조용했고, 이메일로 의견을 나눌 때에도 끼어드는 일이 드풀었으며, 맡은일을 겨우 해내곤 했습니다. 이것은 단순히 우리가 더 많은 일을 떠안게 되는 문제가 아니라, 우리가 그를 믿을 수 있을까에 대한 문제였습니다.
﻿
- 행위(A): 그를 완전히 포기하고 싶지 않았기에 저는 이 상황을 해결하려고 노력 했습니다. 그래서 다음 세 가지 행동을 취했습니다. 첫째로 저는 그가 왜 그렇게 행동하는지 알고 싶었습니다. 게으른 성격 때문인가? 아니면 다른 일이 바쁜가? 저는 그와 대화를 시도했고 결국 현재 맡은 일을 어떻게 생각하는지 이야기 해 볼 수 있었습니다. 이 친구는 놀랍게도 가장 오래 걸리는 일 중 하나인 문서 작업을 하고 싶다고 이야기했습니다. 저는 그때 이 친구가 게으른 사람이 아니었다는 것을 깨달았습니다. 그는 단지 자신이 코드를 작성할 자격이 없는 사람 이라고 느꼈던 것입니다. 둘째로 저는 이제 원인을 알았으니, 그에게 엉망이 될 것을 두려워할 필요가 전혀 없다고 분명히 말하고 싶었습니다. 그에게 내가 저질렀던 더 큰 실수에 대해 이야기했고 나 또한 이 프로젝트의 많은 부분이 명확하지 않다고 인정했습니다. 마지막으로 저는 그에게 프로체트의 컴포넌트를 잘 개 쪼개는 일을 도와 달라고 이야기했습니다. 우리는 함께 큰 컴포넌트 중 하나﻿에 대한 스펙을 철저하게 설계했습니다. 일단 프로젝트의 모든 조각을 볼 수 있게 되면, 그도 생각만큼 겁낼 필요가 없는 프로젝트라는 사실을 알게 될테니까 말이에요.
﻿
﻿- 결과(R): 자신감을 되찾자, 그는 코딩의 작은 부분들을 맡았고 결국엔 큰 부분까지 도맡아 했습니다. 그는 모든 일을 제시간에 끝마쳤고 토론에도 더 자주 참여 했습니다. 다음에도 그와 함께 일할 기회가 주어진다면 기쁠 겁니다.
```

#### 취했던 행동에 대해 논하라

너무 많은 사람이 상황 묘사에만 정신을 쏟아 취했던 행동에 대해서는 아주 간단하게 언급하기 일수다

어떤 행동을 취했는지 깊이 있게 설명하라.

어떤 행동을 취했는지 가능한 한 여러 부분으로 나누어 말하라.

```
다음 세가지 행동을 취했습니다. 우선, 저는 ...
```

#### 여러분의 이야기를 되짚어 보자

이야기를 구성할 때 다음의 관점에서 생각해보아야 한다
- 자주성/리더십
- 공감 능력
- 연민
- 겸손함
- 협동력/도움의 유무

이야기를 되짚어 보면서 성격적인 특성이 잘 드러나도록 만들어 줘야 한다.

간접적으로 이야기 하는 방법을 사용하자

```
성격적 특성이 잘 드러나지 않는 경우: 고객에게 전화를 걸어 무슨 일이 있냐고 물어 보았습니다.
```

```
성격적 특성이 명확하게 드러나는 경우(공감 능력과 열의): 고객에게 전화를 걸기로 결심했습니다. 왜냐하면 내가 그에게 직접 말하면 그가 고마워할 거란 걸 알고 있었기 때문입니다.
```

## 당신에 대해 말해보세요

면접의 서문을 여는 질문 중 하나

첫인상이 결정되므로 성공적으로 해내야 한다.

### 이야기를 구성하는 법

1. 현재 직업(오직 서두에서만)
	1. 저는 Microworks에서 일하는 소프트웨어 엔지니어입니다. 저는 이 회사에서 5년동안 안드로이드 팀을 이끌어 왔습니다.
2. 학교
	1. 저는 컴퓨터 과학을 전공했습니다. 버클리에서 학사학위를 받았습니다. 여름방학에는 제 개인 사업을 시도했던 회사를 포함해서 여러 스타트업에서 일을 했습니다.
3. 졸업 후 지금까지
	1. 대학을 졸업한 뒤에 대기업에 발을 담그고 싶어서 아마존에 개발자로 취직했습니다. 엄청난 경험이었죠. 거대 시스템 디자인에 대해 굉장히 많이 배울 수 있었고 실제로 아마존 웹 서비스의 핵심 부분 출시를 추진하게 되었습니다. 이를 통해 좀 더 사업가적 자질이 요구되는 환경에서 진심으로 일하고 싶어졌습니다.
4. 현재 역할(자세하게)
	1. 아마존에 있을 때 같이 일했던 관리자가 저에게 자신의 스타트업에서 일할 것을 제안했고, 그래서 Microworks로 이직하게 되었습니다. 여기서 저는 회사의 시스템 구조(system architecture)를 바닥부터 만들었습니다. 이 시스템은 우리 회사의 빠른 성장에 꽤 잘 대처해내는, 확장 능력이 있는 시스템이었습니다. 그 뒤 안드로이드 팀을 이끌 기회가 있었고 이 팀을 이끌게 되었습니다. 세 명의 팀원을 관리하는 역할을 맡았지만, 그보다는 주로 기술 리더십 역할을 맡아서 설계와 코딩 등을 해왔습니다.
5. 업무 외에
	1. 업무 외에, 저는 해커톤에 참가한 적이 있습니다. 거기서 iOS를 더 깊게 배워보기 위해 주로 iOS를 개발했습니다. 또한 안드로이드 개발과 관련된 온라인 포럼에서 활발히 운영자(moderator) 역할을 해내고 있습니다.
6. 마무리
	1. 현재 새로운 일을 찾고 있고 이 회사가 제 눈길을 사로잡았습니다. 사용자와의 연결고리가 있는 일을 늘 원했고 다시 더 작은 규모의 환경으로 돌아가고 싶은 마음도 큽니다.

### 취미

취미가 유용할 때가 있는 경우에만 이야기 하라

- 취미가 굉장히 독특한 경우(예를 들어 불을 뿝는다던지)
	- 좀 더 호의적인 분위기에서 면접을 시작할 수 있다
- 취미에 기술적인 면이 있는 경우
	- 지원자의 실제 역량을 뽐낼 수 있을 뿐만 아니라 기술에 대한 열정도 보여줄 수 있음
- 취미가 긍정적인 성격적 특성을 보여 주는 경우
	- '집을 직접 리모델링하기'와 같은 취미는 새로운 것을 배우고, 위험을 감수하고, 손을 더럽히는 것을 두려워하지 않는다는 사실을 보여줄 수 있음

### 성공사례를 간간히 보여주라

- 앞서 지원자는 구체적으로 그의 예전 관리자를 통해 Microworks로 스카웃되었다는 사실을 언급했고, 이는 지원자가 아마존에서 일을 꽤 잘 했다는 사실을 보여준다
- 지원자는 좀 더 작은 규모의 환경으로 옮기고 싶다고 언급했고, 이 사실은 그가 문화적으로 알맞은 사람이라는 것을 보여준다
- 아마존 웹 서비스의 핵심 부분을 출시했다던지 규모 확장성이 있는 시스템을 설계했다든지 하는 사례를 통해 지원자의 성공 사례를 언급했다
- 그가 언급한 두 가지 취미 모두 그가 배우기를 좋아한다는 사실을 보여준다

---
# 6. Big-O

## 시간 복잡도

점근적 실행 시간(asymptotic runtime), 또는 big-O 시간에 대한 개념

실행시간을 설명하는 방법

### big-$O$, big-$\Theta$, big-$\Omega$

- big-$O$
    - 입력값이 무한대로 향할 때 함수의 상한을 설명하는 수학적 표기 방법
    - 주어진 (최선/최악/평균) 경우의 수행시간의 상한을 나타냄
	- 알고리즘의 실행 시간(시간 복잡도)과 함께 공간 요구사항(공간 복잡도)이 어떻게 증가하는지를 분류하는데 사용됨
	- 알고리즘의 효율성을 분석하는 데에도 매우 유용하게 활용됨
    - 점진적 실행 시간(Asymptotic Running Time)을 표기할 때 가장 널리 쓰이는 수학적 표기법 중 하나
    - 점진적 실행 시간 = 시간 복잡도(Time Complexity)
        -   어떤 알고리즘을 수행하는 데 걸리는 시간을 설명하는 계산 복잡도
        -   $4n^2+3n+4 = O(n^2)$
-  big-$\Omega$
	- 등가개념 혹은 하한을 표현
	- 해당 알고리즘은 $\Omega$ 수행시간 보다 빠를 수 없음
	- 알고리즘의 최상의 경우 runtime 측정.  항상 최상의 경우만 낼 수 없기 때문에 big O 만큼 유용하지 않음
- big-$\Theta$
	- 최상과 최악의 경우의 중간을 측정하는 알고리즘

### 최선의, 최악의, 평균적 경우

quick sort 예시
- 최선: O($N$)
- 최악: O($N^2$)
- 평균적인 경우: O($N log N$)


## 공간 복잡도

메모리(혹은 공간)도 신경 써야한다

재귀 호출에서 사용하는 스택 공간 또는 공간 복잡도 계산에 포함된다

예시) 시간: O($N$), 공간: O($N$)
```java
int sum(int n) {
	if (n <= 0) {
		return 0;
	}
	return n + sum(n-1);
}
```

## 상수항은 무시하라

O($N$) 이 반드시 O(2$N$) 보다 나은 것은 아니다

## 지배적이지 않은 항은 무시하라

O($N^2 + N$)은 O($N^2$) 이 된다

O($N + log N$)은 O($N$) 이 된다

O($5* 2^N + 1000 N^9$)은 O($2^N$) 이 된다

여전히 수식에 합이 남아있을 수도 있다.
	O($B^2 + A$)은 하나의 항으로 줄일 수 없다(A와 B 사이에 존재하는 특별한 관계를 알고 있지 않는 이상)

## 여러 부분으로 이루어진 알고리즘: 덧셈 vs. 곱셈

만약 알고리즘이 "A 일을 모두 끝마친 후에 B일을 수행하라"의 형태이면 A와 B의 수행시간을 더해야한다.

만약 알고리즘이 "A 일을 할 때마다 B일을 수행하라"의 형태라면 A와 B의 수행시간을 곱해야 한다.

## 상환 시간

동적 가변크기 배열의 삽입 연산 수행시간은 어떻게 되겠는가? 약간 까다롭다.

- 배열이 가득 차있는 경우
	- O($N$)
	- 새로 2$N$ 크기의 배열을 만들고 기존 원소를 새 배열로 복사해야 하기 때문
- 가득 차 있지 않은 일반적 경우
	- O($1$)

상환시간: 최악의 경우는 가끔 발생하지만 한번 발생하면 그 후로 꽤 오랫동안 나타나지 않으므로 비용을 분활 상환한다는 개념

X개 원소를 삽입했을 때 필요한 시간은 O($2X$)이고, 이를 분할 상환해보면 삽입 한 번에 필요한 시간은 O(1) 이다

## 재귀적으로 수행시간 구하기

O($N^2$) 이라고 성급하게 결론 내리기 쉽다. 틀렸다.

코드를 하나씩 읽어가면서 수행 시간을 계산해봐야 한다

깊이에 따라 노드의 갯수가 몇개 생기느냐에 따라 달라진다

노드와 깊이에 따라서 O($2^N$) 이 될 때도 있고 O($log N$) 이 될 때도 있다

---
# 7. 기술적 문제

## 준비하기

문제를 직접 푸는 훈련을 해야한다

문제를 만날때 마다 다음과 같이 하라
1. 직접 풀도록 노력하라: 포기하지말라. 그리고 문제를 풀 때는, 공간과 시간 효율에 대해서도 반드시 생각하라.
2. 코드를 종이에 적으라: 실제 면접을 보는 것 처럼 오래 걸리는 환경에 익숙해지라.
3. 코드를 테스트하라: 종이 위에 말이다. 일반적인 경우 뿐 아니라, 기본 조건, 오류 발생 조건 등을 전부 테스트 하라.
4. 종이에 적은 코드를 그대로 컴퓨터로 옮긴 뒤 실제로 실행해 보라: 종이에 적은 실수 목록을 만들고, 실제 면접장에서 같은 실수를 반복하지 않도록 노력하라.

친구와 가상 면접을 가능한 많이 해봐라.

## 알고 있어야 할 것들

### 핵심 자료구조, 알고리즘, 기본 개념

| 자료구조           | 알고리즘             | 개념                | 
| ------------------ | -------------------- | ------------------- |
| Linked List        | Breadth-First Search | Bit Manipulation    |
| Tree, Tries, Graph | Depth-First Search   | Stack vs. Heap      |
| Stack & Queue      | Binary Search        | Recursion           |
| Heap               | Merge Sort           | Dynamic Programming |
| Vector/ArrayList   | Quick Sort           | big-O 시간&공간     |
| Hash Table         |                      |                     |

사용법, 구현법, 애플리케이션, 그리고 가능하다면 공간과 시간 복잡도에 대해서 알아두어라.

자료구조와 알고리즘을 종이에(그 다음엔 컴퓨터로) 직접 구현해보는 건 좋은 훈련이다.

해시테이블을 아주 능숙하게 다룰 수 있도록 연습해라.

### 2의 승수(power of 2)표

반드시 외울 필요는 없지만 암기해 두면 꽤 유용하게 쓰인다. 적어도 쉽게 유도할 수 있을 정도로 익숙해져라.

전화 면접을 하는 경우에, 표를 보이는 곳에 붙여 놓으면 도움이 될 것이다.

$2^{20}$ = 1_048_576(백만) = 1MB
$2^{30}$ = 1_073_741_824(십억) = 1GB
$2^{32}$ = 4_294_967_296 = 4GB
$2^{40}$ = 1_099_511_627_776(1조) = 1TB

## 문제 풀기

### 1. 경청하기

확실하지 않은 부분은 반드시 질문을 통해 반드시 짚고 넘어가야 한다.

문제를 주의 깊게 듣고 문제와 관련된 모든 독특한 정보를 머릿속에 기억해 둬야한다.

문제를 푸는데 아무 영향도 끼치지 않는 정보를 제공하는 경우는 많지 않다.

화이트보드에 필요한 정보를 써 놓는 것도 유용한 방법일 것이다.

### 2. 예제를 직접 그려보기

바로 문제를 풀지 말고, 예제를 직접 그려보면 차원이 다른 문제풀이 능력을 발휘할 수 있을 것이다.

예제를 만들 때 유의 해야 할 점
- 명확한 예제를 쓰라: 문제에 맞는 실제 숫자와 문자열을 사용하라
- 충분히 큰 예제를 쓰라
- 특별한 예제를 지양하라: 무심코 특별한 예제를 그리기 굉장히 쉽다. 특별한 예제에 속한다 생각되면, 큰 문제가 없어 보이더라도 에제를 다시 만들어라

### 3. 무식한 방법으로 일단 해보기

첫 알고리즘이 형편없어도 괜찮다. 알고리즘의 시간 및 공간복잡도를 설명한 뒤 알고리즘 개선해 나가면 된다.

알고리즘 최적화의 시작점이 바로 무식한 방법이고, 이 과정이 문제에 집중하도록 도움을 주기 때문이다.

### 4. 최적화

1. 간과한 정보가 있는지 찾아보자
2. 새로운 예제를 만들어보자: 문제에서 새로운 패턴을 발견할 수 있다
3. '잘못된 방식'으로 문제를 풀어보자: 틀린 해법을 통해 올바른 해법을 찾아낼 수도 있다
4. 시간과 공간의 실익을 따져 보고 균형을 맞춰라: 가끔은 상태를 저장해 놓는 것이 수행 시간을 줄이는 데 도움이 되기도 한다
5. 정보를 미리 계산해 두라
6. 해시테이블을 이용하라
7. 가능한 최선의 수행 시간(BCR)이 무엇인지 생각하라

### 5. 검토하기

최적 알고리즘을 완성했다고 해도 바로 코딩에 뛰어들지 말라. 잠시 생각하면서 알고리즘에 대한 이해를 확실히 할 시간을 가지라.

가능하면 완벽에 가까운 상태로 만든 뒤에 실제 코딩에 들어가야 한다.

알고리즘을 다시 한번 훑어 나가면서 코드의 전체적인 구조에 대한 감을 잡으라.

정확히 무엇을 작성해야 하는지 잘 모른다면 코딩을 하는 데 어려움을 겪을 것이다. 코드를 완성시키는 데 더 오랜 시간이 걸릴 것이고 심각한 실수를 더 많이 할 수 있다.

pseudocode 보다는 코드를 직접 작성하는게 훨씬 빠를 것이다.

### 6. 구현하기

코드의 각 줄이 비스듬해지는 'Line Creep'을 조심하라. 코드가 더러워보일 수 있고 헷갈릴 수 있다.

아름다운 코드를 작성해서 훌륭한 개발자라는 사실을 입증해야한다.
- 모듈화된 코드를 사용하라
- 에러를 검증하라
	- 면접관에 따라 선호도가 다르기 때문에 절충안으로 코드에 TODO를 집어넣고 여기서 어떤 테스트를 하겠다고 말로 설명하면 된다
- 필요한 경우에 다른 클래스나 구조체를 사용하라
- 좋은 변수명을 사용하라
	- for 문을 제외하고 한글자 변수명을 사용하지 않는 것이 좋다
	- 그렇다고 변수명이 너무 길면 코딩 속도가 느려지기 때문에 면접관들에게 startChild 같은 것을 sc로 줄여서 쓰겠다고 설명하는 방법이 있다

### 7. 테스트

다음과 같은 방법 사용하라
1. '개념적' 테스트부터 시작하라: 한 줄 한 줄 읽어 내려가며 어떤 일을 수행하는지 머리 속으로 분석하는 테스트. 코드가 예상대로 돌아가는가?
2. 코드에서 평소와는 다르게 도아가는 부분을 유심히 살펴보라: i=1 부터 시작하는 for문 같은 것들. 사소한 실수가 자주 발생하는 부분이다.
3. 버그가 자주 발생하는 부분을 유심히 살펴보라: 재귀함수의 base case, 정수 나눗셈, 이진 트리의 널 노드, 연결리스트를 순회할 때 시작과 끝 지점 같은 곳들을 잘 확인하자.
4. 작은 규모의 테스트를 돌려보라: 작은 규모의 입력 데이터를 넣어서 테스트 해보자.
5. 특별한 경우를 테스트하라: Null, 단일 원소, 극단적인 입력, 아니면 다른 특별한 입력을 이용해서 코드 테스트하라.

## 최적화 및 문제풀이 기술 #1: BUD 찾기

Bottleneck, Unneccessary Work, Duplicated Work

알고리즘이 비효율적으로 동작하는 가장 흔한 이유

### Bottleneck

병목현상을 해결하는 것은 전체 수행 시간에 커다란 차이를 만들어 낸다

- 어떤 부분 때문에 알고리즘이 느려지는 경우
- 검색을 여러 번 하는 것처럼 반복적으로 수행하는 부분이 여러 개 있는 경우

ex) 서로 다른 정수로 이루어진 배열이 있을 때 두 정수의 차이가 k인 쌍의 개수를 세라.
- 무식한 벙법: 원소를 처음부터 훑어가면서 나머지 원소들과 쌍을 만듬
- 개선: 두번째 원소를 어떻게 더 빨리 찾을 수 있을까? -> 배열이 정렬되어 있다면 이진탐색
- 최적화: 모든 원소를 해시테이블에 넣고 x+k 혹은 x-k가 배열에 존재하는지 확인

### Unneccessary Work

ex) $a^3+b^3=c^3+d^3$을 만족하는 $a,b,c,d$
- 무식한 방법: 4중 for문으로 a,b,c,d 찾기
- 개선된 방법: $d=\sqrt{a^{3}+b^{3}-c^{3}}$ 으로 변경후 3중 for문

### Duplicated Work

ex) $a^3+b^3=c^3+d^3$을 만족하는 $a,b,c,d$
- $c^3+d^3$을 key로 하여, (a,b) 쌍의 리스트가 value가 되도록 해시테이블을 이용하여 2중 for문


## 최적화 및 문제풀이 기술 #2: 스스로 풀어보아라 DIY

"알고리즘을 설계하라"는 말은 어렵지만, 실제 예제를 쥐어 주면 인간은 직관적으로 문제를 푼다.

ex) 길이가 작은 문자열 s와 길이가 긴 문자열 b가 주어졌을 때, 문자열 b 안에 존재하는 문자열 a의 모든 순열을 찾아라
- 무식한 방법: s에서 가능한 순열을 나열한 다음 찾기 -> O(S! * B)
- 인간이 직관적으로 푼 방법: s의 길이 n에 맞춰서 b를 n개씩 끊어서 살펴본뒤 s의 순열을 만족하는지 확인
	- 없는 문자가 발견됬을 때는 더 확인하지 않고 그냥 넘어갔다. 

## 최적화 및 문제풀이 기술 #3: 단순화, 일반화하라

- 자료형과 같은 제약조건을 단순화하거나 변형시킨다.
- 단순화된 버전의 문제를 푼다.

## 최적화 및 문제풀이 기술 #4: 초기사례(base case)로부터 확장시키기

n=1 같은 상황의 해법을 구해놓은 뒤,n=3 혹은 n=4 같은 더 복잡하거나 관심을 기울여야 하는 경우의 해법을 구해나간다.

## 최적화 및 문제풀이 기술 #5: 자료구조 브레인스토밍

단순하게 일련의 자료구조를 차례차례로 살펴보면서 하나씩 적용해보면 된다.

특정 자료구조를 써보자 라는 결심만으로 문제가 자연스럽게 풀리는 경우가 있기 때문에 꽤 유용한 접근법이다.

## BCR(Best Conceivable Runtime)

가능한 최선의 수행 시간(BCR)이 무엇일까 생각해보는 것 자체로도 문제를 푸는 유용한 힌트를 발견할 수 있다.

BCR: 어떤 문제를 푸는데 여러분이 상상할 수 있는 모든 해법 중 수행시간이 가장 빠른 것
- 가능한 최선의 수행 시간보다 빠른 해법은 존재할 수 없다는 사실을 쉽게 증명할 수 있어야 한다.

BCR을 반드시 만족할 필요는 없다. 단순히 어떤 알고리즘도 이보다 나을 순 없다고 알려주는 것뿐이다.

BCR을 이용해서 어떤 부분을 줄일 수 있는지 '힌트'를 얻을 수 있다.

BCR보다 수행시간이 빠르거나 같은 모든 작업은 전체 수행 시간에 아무런 영향을 주지 않는다는 점에서 자유롭게 시도해 봐도 좋다.

BCR은 수행 시간 측면에서 최적화가 끝났다는 사실을 알려준다.

수행 시간은 객관식 문제가 아니라는 것을 명심하라! 추측하지 말고 직접 유도해야한다.

'더 개선할 수 있을까요' 라는 질문에 당황하지말고, BCR과 비교해보고 더 적은 시간이 나오기 힘들면 공간 복잡도를 개선하는 쪽으로 눈을 돌려야한다

## 오답에 대한 대처법

맞추지 못해도 된다

주로 다음으로 평가한다
- 얼마나 최적해법에 근접한가, 최종 답안을 내는데 시간이 얼마나 걸렸나, 얼마나 힌트를 필요로 했나로 평가한다.
- 지원자들을 상대적으로 평가한다.
- 대부분 문제가 아주 어렵기 때문에 실력있는 지원자라 하더라도 단번에 최적 해법을 말하긴 어렵다.

## 알고 있던 문제가 면접에 나왔을 때

알고 있는 문제라면 면접관에게 사실대로 고백하는 것이 긍정적인 평가를 얻을 수 있다.
- 문제 풀이 능력을 평가하기 위함이지 아는 것을 푸는 자리가 아니다.
- 숨겼다가 문제를 알고 풀었다는 사실이 밝혀지면 부정직한 지원자라는 인상을 줄 수 있다.

## 면접용으로 '완벽한' 언어

-  널리 사용되는 언어
-  언어 가독성
-  잠재적인 문제점
	- C++를 사용하면, 일반적인 버그뿐만 아니라 메모리 관리와 포인터 때문에 생기는 문제점들도 해결해야한다.
- 언어가 얼마나 장황한지
	- Java가 Python보다 장황하게 설명해야한다는 점이 불편할 수 있다.
- 사용하기 쉬운언어
	- 특정 언어에는 사용하기 쉬운 기능이 있을 수 있다.

## 어떤 코드가 좋아 보이나

- 정확도: 예상 가능한 혹은 불가한 입력에 대해서, 코드는 정확히 동작해야 한다.
- 효율성: 시간, 공간 두 가지 측면어세 좋은 코드여야한다.
- 간략화: 100줄짜리를 10줄짜리로 줄일 수 있으면 그렇게 해야한다.
- 가독성: 다른 개발자도 코드를 이해할 수 있어야한다. 비트 시프트 연산은 그럴듯해보여도 가독성이 좋지 않은 코드일 수 있다.
- 관리 가능성: 제품의 수명주기 동안 적절히 수정 가능해야 하고, 최초로 작성한 개발자 뿐 아니라 다른 개발자도 쉽게 관리 가능한 코드여야한다.

구체화한 내용
- 적절한 자료구조를 사용하라
- 적절한 코드의 재사용
- 모듈화
- 유연하고 튼튼한 코드
- 오류검사

## 포기하지 말라

까다로운 문제에 당당히 맞서는 자세가 중요하다.

어려운 문제를 즐기며 푸는 모습을 보이라

---
# 7. 합격한 뒤에

## 합격 또는 거절 통지에 대처하는 요령

### 입사 결정 기한과 연장

다른 회사 면접 결과도 기다려 보고 싶다면, 기한연장을 요청할 수 있다.

### 입사 제한 거절

공손한 어투로 입사 제안을 거절하고, 계속 연락을 주고받을 수 있는 채널을 열어두는 게 좋다.

공격적이지 않고 명백한 이유를 대는 것이 좋다.

### 탈락 통보 대처

재지원하는 기회로 만다는 것이 좋다. 구인 담당자에게 시간 내 줘서 고맙고 안타깝긴 하지만 충분히 이해한다고 말하는 것이 좋다.

구인 담당자에게 피드백을 공유해달라고 요청해볼 수도 있다. "다음 기회를 위해 어떻게 준비하면 좋을을지 얘기해주실 수 있나요?"라고 물어 보는 것도 나쁘지 않다.

## 입사 제안 평가

### 재정 관련 사항

연봉만 고려하지 말고 다음 사항도 고려하라
- 계약 보너스(signing bonus, sign-on bonus), 딱 한 번 주는 혜택
	- 해당 보너스를 회사에 머물거라 생각되는 기간 동안 지급받을 급여에 합산하여 입사 제안을 평가하는 것이 현명하다.
- 생활 비용 차이
- 연간 보너스
	- 구인 담당자가 평균 보너스를 알려주면 그것을 참고하고, 그렇지 않다면 회사 내의 지인에게 물어 알아보자.
- 스톡 옵션과 증여(grants)
	- 주식형태의 보상은 3년 정도 봉급에 합산하여 비교 평가하는 것이 바람직하다

### 경력 개발

다음을 질문해보자
- 이력서를 얼마나 보기 좋게 만들어 줄 것인가
- 얼마나 많이 배우게 될 것인가?
- 승진 계획은 어떤가? 개발자의 경력을 어떻게 발전시키는 회사인가?
- 관리직으로 옮기고자 할 경우, 회사가 현실적 계획을 마련해주는가?
- 회사나 팀 규모가 확대되고 있는 중인가?
- 회사를 떠나고 싶을 경우, 옮길 만한 회사가 가가이 있는가? 아니면 이사를 해야하나?

### 회사의 안정성

지원자의 가치관에 따라 달려있다

꽤 빠른 시간 내에 새로운 직장을 찾을 수 있는가? 만약 그럴 수 있다면, 불안정하더라도 빨리 성장하는회사에 입사하는 것이 낫다.

### 행복의 척도

영향을 끼칠 요소
- 제품
- 관리자와 동료: 그들과 대화하는게 즐거웠는가?
- 회사 문화: 팀 동료에게 회사 문화에 대해 설명해 달라고 부탁해보자.
- 근무 시간

다른 팀으로 옮길 기회가 쉽게 주어진다면(구글이나 페이스북 같은 경우), 여러분과 잘 맞는 팀과 제품을 찾을 또 다른 기회가 생길 수 있다는 것에도 유의하자.

## 연봉 협상

- 그냥 해보라.
- 실질적인 대안을 가져라.
- 구체적으로 요구하라.
- 많이 부를 것.
- 연봉 이외의 것도 고려하라. 
	- 지분을 더 달라고 하거나, 계약 보너스를 더 많이 달라고 해 보라.
	- 이사 비용을 회사에서 직접 지불해주는 대신, 이직 보너스를 현찰로 달라고 해 보라.

## 입사 후

회사에 입사한 뒤에는, 여러분의 경력에 대해 고민하기 시작해야 한다.

### 일정 수립

하는 일을 즐기다 보면, 거기에 빠진 나머지 여러분의 경력이 발전하지 않고 있다는 사실을 미처 깨닫지 못하기 때문에 나아갈 길을 입사할 때 미리 그려 보아야 한다.

진로를 미리 설계하고 정기적으로 점검함으로써, 현실에 안주해 버리는 일을 피할 수 있게 된다.

### 튼튼한 관계 수립

일터에서 관리자나 팀원들과 끈끈한 관계를 수립하라.

다른 직원이 퇴사하면 그들과 계속 연락을 유지하라.

이런 접근법을 여러분의 사생활에도 적용하라.

### 원하는 것을 요구하라

목표를 관리자에게 적절한 수준으로 솔직하게 표현하라. 백엔드 코딩 프로젝트에 좀 더 시간을 쓷고 싶다면, 그렇게 말하라.

### 꾸준히 면접을 보라

새로운 직장을 찾고 있지 않더라도 적어도 일 년에 한번 정도는 면접을 보라
- 최신 면접 기술을 유지할 수 있고 현재 어떤 종류의 기회가 있는지 알아볼 수도 있다.

나중에 입사하고 싶을 때를 대비해서 그 회사와 연결고리를 만들어 놓을 수도 있다.

---